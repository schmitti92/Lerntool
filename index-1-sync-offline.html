<!DOCTYPE html>

<html lang="de">
<head>
<!-- v31: dedupe pass completed (functions unified, no feature removal) -->
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, viewport-fit=cover" name="viewport"/>
<title>Lerntool ‚Äì Stabil</title>
<style style=" font-size: 200%">
:root{
  --bg:#f4f7f6;
  --bgTop:#eef6f3;
  --card:#ffffff;
  --accent:#6bbfae;
  --accent2:#8ed7c9;
  --muted:#6b7c7a;
  --text:#243333;
  --danger:#f2dede;
  --radius:26px;
  --shadow:0 10px 30px rgba(0,0,0,.08);
}
*{box-sizing:border-box}
body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
  background:linear-gradient(180deg,var(--bgTop),var(--bg));
  color:var(--text);
}
.screen{display:none; min-height:100vh;}
.screen.active{display:block;}
.wrap{max-width:980px; margin:0 auto; padding:18px;}
h1{margin:6px 0 10px; font-size:22px}
p{margin:0 0 14px; color:var(--muted)}
.row{display:flex; gap:12px; flex-wrap:wrap; align-items:center}
.card{
  background:var(--card);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  padding:18px;
}
.btn{
  appearance:none;
  border:none;
  border-radius:18px;
  padding:14px 16px;
  font-weight:900;
  cursor:pointer;
  background:linear-gradient(180deg,var(--accent2),var(--accent));
  color:#0f2e2a;
  min-width:140px;
  position:relative;
  z-index:5;
  pointer-events:auto;
}
.btn.secondary{
  background:#eef6f3;
  color:#355f58;
  box-shadow:none;
  border:1px solid rgba(0,0,0,.08);
}
.btn.ghost{
  background:transparent;
  color:var(--muted);
  box-shadow:none;
  border:1px solid rgba(0,0,0,.10);
}
.btn.danger{
  background:var(--danger);
  color:#7a1f1f;
}
.input{
  width:100%;
  padding:14px 14px;
  border-radius:18px;
  border:1px solid rgba(0,0,0,.12);
  font-size:16px;
  outline:none;
}
.grid{
  display:grid;
  grid-template-columns:repeat(2, minmax(0,1fr));
  gap:12px;
}
@media (min-width:860px){
  .grid{grid-template-columns:repeat(3, minmax(0,1fr));}
}
.tile{
  background:#fff;
  border-radius:22px;
  box-shadow:var(--shadow);
  padding:16px;
  border:1px solid rgba(0,0,0,.06);
  cursor:pointer;
}
.tile .t1{font-weight:950}
.tile .t2{color:var(--muted); font-size:13px; margin-top:4px}

/* Klausur-Kachel: Titel links, Datum rechts (im gleichen Button) */
.examTile{padding:18px 18px}
.examTile .examRow{display:flex; align-items:center; justify-content:space-between; gap:14px}
.examTile .examTitle{font-weight:950; font-size:22px; line-height:1.15}
.examTile .examDate{font-weight:800; color:var(--muted); opacity:.9; white-space:nowrap; font-size:14px}
@media(max-width:600px){
  .examTile .examTitle{font-size:20px}
  .examTile .examDate{font-size:13px}
}
.topbar{
  display:flex; justify-content:space-between; align-items:center;
  gap:10px;
}
.small{font-size:12px; color:var(--muted)}
.lf-source{font-size:12px;color:var(--muted);margin-top:6px;}
.hr{height:1px; background:rgba(0,0,0,.08); margin:14px 0}
.notice{
  background:#f7fbfa;
  border:1px solid rgba(0,0,0,.07);
  padding:12px 14px;
  border-radius:18px;
  color:#355f58;
  display:none;
}
.notice.show{display:block;}
/* Flashcard minimal look */
.stage{display:flex; justify-content:center; padding:22px 0}
.flash{
  width:100%;
  max-width:560px;
  background:#fff;
  border-radius:28px;
  box-shadow:0 12px 34px rgba(0,0,0,.10);
  padding:28px;
}
.flash .q{font-size:22px; font-weight:950; margin:0}
.flash .a{
  display:none;
  margin-top:14px;
  padding-top:14px;
  border-top:1px dashed rgba(0,0,0,.15);
  font-size:16px;
}
.flash.revealed .a{display:block}
.w100{width:100%}

/* XP BAR (Level UI) */
.xpWrap{display:flex;align-items:center;gap:10px;justify-content:flex-end;flex-wrap:wrap}
.xpBar{width:140px;height:10px;border-radius:999px;overflow:hidden;background:rgba(255,255,255,.18);box-shadow:inset 0 0 0 1px rgba(255,255,255,.14)}
.xpFill{height:100%;width:0%;background:rgba(255,255,255,.9)}
.xpMeta{white-space:nowrap}


/* ===== Level Widget (enhanced, detailreich) ===== */
.lvlWidget{
  display:flex; align-items:center; gap:10px; justify-content:flex-end;
  padding:8px 10px;
  border-radius:16px;
  background: rgba(255,255,255,.10);
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,.16),
    0 8px 18px rgba(0,0,0,.18);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  max-width: 520px;
}
.lvlBadge{
  width:34px; height:34px; border-radius:12px;
  display:grid; place-items:center;
  background:
    radial-gradient(circle at 30% 30%, rgba(255,255,255,.55), rgba(255,255,255,.08) 55%, rgba(255,255,255,.02));
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,.18),
    0 10px 16px rgba(0,0,0,.20);
  flex: 0 0 auto;
}
.lvlBadge span{ font-size:18px; filter: drop-shadow(0 2px 2px rgba(0,0,0,.25)); }
.lvlText{ display:flex; flex-direction:column; gap:2px; min-width: 110px; }
.lvlTitleRow{ display:flex; align-items:baseline; gap:8px; line-height:1; }
.lvlTitle{ font-size:11px; opacity:.85; letter-spacing:.08em; text-transform:uppercase; }
.lvlNum{ font-size:16px; font-weight:950; }
.lvlSub{ font-size:11px; opacity:.85; white-space:nowrap; }
.lvlBarWrap{ display:flex; flex-direction:column; gap:6px; flex:1 1 auto; min-width: 140px; }
.lvlBar{
  position:relative;
  height:12px;
  border-radius:999px;
  overflow:hidden;
  background: rgba(0,0,0,.18);
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,.12),
    inset 0 8px 14px rgba(0,0,0,.18);
}
.lvlFill{
  position:absolute; inset:0 auto 0 0;
  width:0%;
  border-radius:999px;
  background:
    linear-gradient(90deg, rgba(255,255,255,.95), rgba(255,255,255,.70));
  box-shadow:
    0 0 0 1px rgba(255,255,255,.18),
    0 10px 16px rgba(0,0,0,.14);
  transition: width .25s ease;
}
.lvlTicks{
  position:absolute; inset:0;
  background:
    repeating-linear-gradient(90deg,
      rgba(255,255,255,.18) 0,
      rgba(255,255,255,.18) 1px,
      rgba(255,255,255,0) 1px,
      rgba(255,255,255,0) 10%);
  mix-blend-mode: overlay;
  pointer-events:none;
  opacity:.45;
}
.lvlGlow{
  position:absolute; inset:-40% -40%;
  background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.25), rgba(255,255,255,0) 55%);
  transform: translateZ(0);
  pointer-events:none;
}
@media (max-width: 420px){
  .lvlWidget{ padding:7px 8px; border-radius:14px; gap:8px; }
  .lvlBadge{ width:32px; height:32px; border-radius:11px; }
  .lvlText{ min-width: 95px; }
  .lvlBarWrap{ min-width: 120px; }
}


/* ===== Spectacular Level Widget Overrides ===== */
.small .lvlWidget{font-size:14px !important;}
.lvlWidget{
  font-size:14px !important;
  padding:10px 12px !important;
  border-radius:18px !important;
  background: linear-gradient(135deg, rgba(255,255,255,.20), rgba(255,255,255,.06)) !important;
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,.22),
    0 14px 28px rgba(0,0,0,.22) !important;
  transform: translateZ(0) scale(1.12);
  transform-origin: right center;
}
.lvlBadge{
  width:42px !important; height:42px !important; border-radius:14px !important;
  background:
    radial-gradient(circle at 30% 30%, rgba(255,255,255,.70), rgba(255,255,255,.14) 55%, rgba(255,255,255,.04)) !important;
}
.lvlBadge span{font-size:22px !important;}
.lvlTitle{font-size:12px !important; opacity:.9 !important;}
.lvlNum{font-size:24px !important;}
.lvlSub{font-size:12px !important; opacity:.9 !important;}
.lvlBar{height:14px !important;}
.lvlFill{
  background: linear-gradient(90deg, rgba(255,255,255,1), rgba(255,255,255,.62)) !important;
}
.lvlBar::after{
  content:"";
  position:absolute; inset:-40% -80%;
  background: linear-gradient(90deg, rgba(255,255,255,0), rgba(255,255,255,.30), rgba(255,255,255,0));
  transform: rotate(10deg);
  animation: lvlShimmer 2.2s ease-in-out infinite;
  pointer-events:none;
  opacity:.65;
}
@keyframes lvlShimmer{
  0%{ transform: translateX(-30%) rotate(10deg); opacity:.15;}
  50%{ opacity:.75;}
  100%{ transform: translateX(30%) rotate(10deg); opacity:.15;}
}
@media (max-width: 520px){
  .lvlWidget{transform: scale(1.06);}
  .lvlBadge{width:40px;height:40px;}
  .lvlNum{font-size:22px;}
}



/* ===== Mode Header Level Widget (gr√∂√üer im Modi-Fenster) ===== */
#sMode .modeHdrLine{
  display:flex;
  align-items:center;
  justify-content:flex-end;
  gap:10px;
  flex-wrap:wrap;
}
#sMode .modeLvlWidget{
  transform: scale(1.18);
  padding:10px 12px;
  border-radius:18px;
  max-width: 640px;
}
#sMode .modeLvlWidget .lvlBarWrap{ min-width: 200px; }
#sMode .modeLvlWidget .lvlNum{ font-size:18px; }
@media (max-width: 520px){
  #sMode .modeLvlWidget{ transform: scale(1.08); }
  #sMode .modeLvlWidget .lvlBarWrap{ min-width: 160px; }
}

/* ===== Mode Card Count Badge ===== */
.modeCount{
  position:absolute;
  top:10px;
  right:14px;
  padding:6px 10px;
  border-radius:999px;
  font-size:12px;
  font-weight:700;
  background: linear-gradient(135deg, rgba(255,255,255,.85), rgba(255,255,255,.55));
  color:#333;
  box-shadow: 0 6px 14px rgba(0,0,0,.18), inset 0 0 0 1px rgba(255,255,255,.6);
}
.modeCard{ position:relative; }


/* ===== Count Badge Visibility Fix (tiles) ===== */
.tile{ position:relative !important; overflow:visible !important; }
.tile .modeCount{
  position:absolute;
  top:10px;
  right:14px;
  z-index:5;
  pointer-events:none;
}
@media (max-width: 520px){
  .tile .modeCount{ top:8px; right:10px; font-size:11px; padding:5px 9px; }
}



/* ===== Badge overlap fix (reserve space for modeCount) ===== */
.tile .t1, .tile .t2{
  padding-right: 128px; /* prevents text from sitting under the count pill */
  box-sizing: border-box;
}
@media (max-width: 520px){
  .tile .t1, .tile .t2{ padding-right: 104px; }
}

/* ===== Lernfokus RADIKAL (Variante A) ===== */
.flash{ padding:22px 18px; }
.flash .q{ font-size:22px; line-height:1.25; letter-spacing:.2px; }
.flash .a{ margin-top:14px; font-size:18px; line-height:1.35; display:none; }
.flash.showAnswer .a{ display:block; }

.lf-show{
  height:44px !important;
  font-size:16px !important;
  opacity:.95;
}

.row{ gap:12px; }
.row + .row{ margin-top:14px !important; }

.row:has(.lf-wrong), .row:has(.lf-right){
  display:grid !important;
  grid-template-columns: 1fr 1fr !important;
  gap:12px !important;
}

.lf-wrong, .lf-right{
  height:62px !important;
  font-size:18px !important;
  font-weight:900 !important;
  border-radius:16px !important;
}

.lf-wrong{ transform: translateZ(0); }
.lf-right{ transform: translateZ(0); }

.row:has(.lf-mini){
  display:flex !important;
  justify-content:center !important;
  flex-wrap:wrap !important;
  gap:10px !important;
  margin-top:10px !important;
}

.lf-mini{
  width:auto !important;
  padding:10px 12px !important;
  font-size:14px !important;
  border-radius:999px !important;
  background: rgba(255,255,255,.08) !important;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.14) !important;
}

.lf-next{
  height:56px !important;
  font-size:18px !important;
  font-weight:950 !important;
  border-radius:18px !important;
  margin-top:10px !important;
}

/* N√§chste erst nach Bewertung sichtbar/aktiv */
.lf-next[disabled]{ opacity:.35 !important; pointer-events:none !important; }

/* Mobile */
@media (max-width:520px){
  .flash .q{ font-size:20px; }
  .lf-wrong,.lf-right{ height:58px; font-size:17px; }
  .lf-next{ height:54px; }
}


/* ===== Auto-Next (safe) ===== */
button[onclick*="nextCard"], 
button[onclick*="nextFav"]{
  display:none !important;
}


/* ===== Quiz: Sicher/Unsicher Mastery ===== */
#quizUnsureBtn,#quizSafeBtn{ height:62px; font-size:18px; font-weight:950; border-radius:16px; }
button[onclick*="nextQuiz"]{ display:none !important; }


/* ===== Karteikarten: Zusatz-Button "Sicher" ===== */
.lf-safe{
  height:56px;
  font-size:16px;
  font-weight:950;
  border-radius:16px;
}
#cardSafeBtn[disabled]{ opacity:.35; pointer-events:none; }
button[onclick*="nextCard"]{ display:none !important; } /* Auto-Next nutzt Richtig/Falsch */


/* ===== Sicher-Button: klickbar, aber visuell gesperrt ===== */
#cardSafeBtn.isDisabled{ opacity:.35; pointer-events:auto; }


/* ===== Quiz: Richtig/Falsch/Sicher (wie Karteikarten) ===== */
.lf-qbtn{
  height:62px;
  font-size:18px;
  font-weight:950;
  border-radius:16px;
}
.lf-safe2{
  height:58px;
  font-size:17px;
}
#quizWrongBtn,#quizRightBtn{ display:none !important; }
#quizSafeBtn2{ margin-top:14px; }


/* ===== Quiz Status Bar ===== */
.quiz-status{
  margin:14px 0;
  padding:12px;
  border-radius:12px;
  font-weight:700;
  text-align:center;
  opacity:.9;
}
.quiz-status.right{ background:#dff3ee; color:#1f7a67; }
.quiz-status.wrong{ background:#f6e1e1; color:#8b2f2f; }
.quiz-status.neutral{ background:#eef4f3; color:#5f6f6b; }


/* ===== Quiz: Unsicher Button ===== */
#quizUnsureBtn2{ height:62px; font-size:18px; font-weight:950; border-radius:16px; }



/* ===== Filter Chips ===== */
.chipRow{display:flex;flex-wrap:wrap;gap:10px;margin:10px 6px 0;}
.chip{
  padding:8px 12px;
  border-radius:999px;
  font-weight:900;
  font-size:12px;
  border:1px solid rgba(0,0,0,.12);
  background:rgba(255,255,255,.65);
  color:#0f172a;
  cursor:pointer;
  user-select:none;
  box-shadow:0 6px 16px rgba(0,0,0,.06);
}
.chip:active{transform:translateY(1px);}
.chip.active{background:#16a34a !important;border-color:#16a34a !important;color:#ffffff !important;}
.filterBar{display:flex;align-items:center;justify-content:space-between;gap:10px;margin:8px 6px 0;}
.filterBtn{padding:8px 12px;border-radius:14px;font-weight:900;}
.filterBtn.on{background:rgba(22,163,74,.18) !important;border-color:rgba(22,163,74,.45) !important;color:#14532d !important;}
.filterWrap{margin-top:6px;}

/* ===== √úbersicht (Gesamt / Sicher) ===== */
.lf-overview{
  margin:12px 0 6px;
  padding:10px 12px;
  border-radius:14px;
  background: rgba(255,255,255,.65);
  border: 1px solid rgba(0,0,0,.05);
  box-shadow: 0 10px 24px rgba(0,0,0,.06);
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  font-weight:800;
}
.lf-overview small{ font-weight:700; opacity:.75; }
.lf-overview .pill{
  padding:6px 10px;
  border-radius:999px;
  background: rgba(31,122,103,.10);
  color:#1f7a67;
  border:1px solid rgba(31,122,103,.18);
  font-weight:900;
  white-space:nowrap;
}


/* === UI Upgrade: Icons + Panels === */
.tile{
  display:flex;
  gap:12px;
  align-items:flex-start;
  padding:14px 14px;
}
.tile .ico{
  width:42px;
  height:42px;
  border-radius:14px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:22px;
  background: rgba(255,255,255,.65);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,.06);
  flex:0 0 auto;
  margin-top:2px;
}
.tile .t1, .tile .t2{ width:100%; }
.modeExtras{ margin-top:14px; display:grid; grid-template-columns:1fr; gap:14px; }
#masteryBox, #highscorePanel{
  width:100%;
  margin-left:0 !important;
  margin-right:0 !important;
}
#highscorePanel h2{ font-size:18px; }
#highscorePanel ol li{ margin:6px 0; }


/* v34: Name screen click-fix */
#sName{ position:relative; z-index:120; pointer-events:auto; }
#sName *{ pointer-events:auto; }
#nameNextBtn{ position:relative; z-index:130; }


/* v35: Screen stacking fix */
.screen{ position:relative; z-index:0; }


/* v37: ensure exam weiter is clickable */
#sExam .row{ position:relative; z-index:120; }
#sExam .row .btn{ position:relative; z-index:130; pointer-events:auto; }


/* v40: visible debug layer */
#dbgWrap{position:fixed;left:12px;bottom:12px;right:12px;max-height:38vh;z-index:999999;
  background:rgba(255,255,255,.92);border:1px solid rgba(0,0,0,.08);border-radius:14px;
  box-shadow:0 12px 30px rgba(0,0,0,.12);backdrop-filter:blur(8px);display:none;overflow:hidden}
#dbgHead{display:flex;align-items:center;gap:10px;padding:10px 12px;border-bottom:1px solid rgba(0,0,0,.06);font-weight:800}
#dbgBody{padding:10px 12px;overflow:auto;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size:12px;line-height:1.35;white-space:pre-wrap}
#dbgBtn{position:fixed;right:14px;bottom:14px;z-index:1000000;border:none;border-radius:999px;padding:10px 14px;
  box-shadow:0 10px 24px rgba(0,0,0,.12);background:#111;color:#fff;font-weight:800}
#dbgBadge{margin-left:auto;font-weight:700;font-size:12px;color:rgba(0,0,0,.55)}
#dbgErr{position:fixed;top:10px;left:10px;right:10px;z-index:1000001;display:none;
  background:rgba(255,235,235,.95);border:1px solid rgba(180,0,0,.25);color:#7a0000;border-radius:14px;
  padding:10px 12px;box-shadow:0 12px 30px rgba(0,0,0,.12)}
#dbgErr b{display:block;margin-bottom:4px}


/* ===== Modus 2 (Eigene Karten) ‚Äì UI Polish v43 ===== */
#m2Badges{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0 18px}
.m2Badge{display:inline-flex;align-items:center;gap:8px;padding:10px 12px;border-radius:14px;background:rgba(255,255,255,.75);box-shadow:0 10px 30px rgba(0,0,0,.06);border:1px solid rgba(0,0,0,.06);font-weight:700}
.m2Badge small{font-weight:600;opacity:.7}
.m2Badge .dot{width:10px;height:10px;border-radius:999px;background:#5ad3b1;box-shadow:0 0 0 5px rgba(90,211,177,.18)}
.m2Badge .num{font-size:18px}
.m2Grid{display:grid;grid-template-columns:1.25fr .75fr;gap:16px}
@media (max-width: 980px){.m2Grid{grid-template-columns:1fr}}
.m2Side{background:rgba(255,255,255,.6);border:1px solid rgba(0,0,0,.06);border-radius:18px;padding:14px 14px 12px;box-shadow:0 10px 30px rgba(0,0,0,.05)}
.m2Side h3{margin:2px 0 8px;font-size:16px}
.m2Steps{display:grid;gap:10px;margin:0;padding:0;list-style:none}
.m2Steps li{display:flex;gap:10px;align-items:flex-start;background:rgba(255,255,255,.7);border:1px solid rgba(0,0,0,.06);border-radius:14px;padding:10px 10px}
.m2Steps .ico{width:28px;height:28px;border-radius:10px;display:grid;place-items:center;background:rgba(90,211,177,.18);font-size:16px}
.m2Steps b{display:block;margin-top:1px}
.m2Steps span{display:block;opacity:.75;font-size:13px;line-height:1.25;margin-top:1px}
.m2Hint{margin-top:10px;font-size:13px;opacity:.8;line-height:1.35}
#ownCardsList{display:none;gap:10px}
.ownCardRow{display:flex;gap:12px;align-items:flex-start;justify-content:space-between;background:rgba(255,255,255,.78);border:1px solid rgba(0,0,0,.06);border-radius:16px;padding:12px 12px;box-shadow:0 10px 30px rgba(0,0,0,.05)}
.ownCardLeft{flex:1;min-width:0}
.ownCardLeft b{display:block;font-size:14px;margin-bottom:4px}
.ownCardLeft div{font-size:13px;opacity:.85;line-height:1.25}
.ownActions{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end;align-items:center}
.ownActions .miniBtn{border-radius:12px;padding:9px 10px;font-weight:800;border:1px solid rgba(0,0,0,.08);background:rgba(255,255,255,.65);box-shadow:0 8px 20px rgba(0,0,0,.06)}
.ownActions .miniBtn:active{transform:translateY(1px)}
.ownActions .miniBtn.primary{background:rgba(90,211,177,.22)}
.ownActions .miniBtn.danger{background:rgba(255,99,99,.16)}
/* make Mode2 inputs feel nicer without changing layout */
#ccFront,#ccBack,#ccSource,#ccSlide{background:rgba(255,255,255,.75)}
#ccFront:focus,#ccBack:focus,#ccSource:focus,#ccSlide:focus{outline:none;box-shadow:0 0 0 4px rgba(90,211,177,.22)}

/* Mode2 list buttons ‚Äì map existing btn styles to miniBtn look */
#ownCardsList button{border-radius:12px!important;padding:9px 10px!important;font-weight:800!important}
#ownCardsList button.btn{box-shadow:0 8px 20px rgba(0,0,0,.06)!important;border:1px solid rgba(0,0,0,.08)!important;background:rgba(255,255,255,.65)!important}
#ownCardsList button.btn.primary{background:rgba(90,211,177,.22)!important}
#ownCardsList button.btn.danger{background:rgba(255,99,99,.16)!important}


/* v53fix: Modal styling (Klausur hinzuf√ºgen) */
.ltModal{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.55);
  z-index:1000002;
  display:none;
  align-items:center;
  justify-content:center;
  padding:16px;
}
.ltModalBox{
  width:min(520px, 100%);
  background:#fff;
  border-radius:22px;
  box-shadow:var(--shadow);
  padding:16px;
}

/* ===== UI-POLISH: Mode-Kacheln sauber (Tablet/Handy) ===== */
.tile{
  display:grid;
  grid-template-columns:64px 1fr;
  grid-template-rows:auto auto;
  column-gap:14px;
  row-gap:6px;
  align-items:start;
  position:relative;
  overflow:hidden;
}
.tile .ico{
  width:56px; height:56px;
  border-radius:18px;
  display:flex; align-items:center; justify-content:center;
  background:rgba(0,0,0,.04);
  font-size:28px;
  grid-row:1 / span 2;
}
.tile .tTop{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:10px;
}
.tile .t1{
  font-weight:950;
  font-size:20px;
  line-height:1.15;
  letter-spacing:-.2px;
}
.tile .t2{
  margin-top:0;
  font-size:13px;
  line-height:1.25;
  color:var(--muted);
}
.modeCount{
  position:static !important;
  top:auto !important; right:auto !important;
  padding:6px 10px;
  border-radius:999px;
  font-size:12px;
  font-weight:800;
  white-space:nowrap;
  background:rgba(255,255,255,.75);
  color:#222;
  box-shadow:0 6px 14px rgba(0,0,0,.12), inset 0 0 0 1px rgba(255,255,255,.7);
}
.tile .t1, .tile .t2{ padding-right:0 !important; } /* alte Badge-Padding-Hacks neutralisieren */
@media (max-width: 520px){
  .tile{ grid-template-columns:56px 1fr; padding:14px; }
  .tile .ico{ width:52px; height:52px; border-radius:16px; font-size:26px; }
  .tile .t1{ font-size:18px; }
  .modeCount{ font-size:11px; padding:5px 9px; }
}


/* ===========================
   COOL LEARN CARD (Modus 1)
   Visual-Redesign ohne Funktionsverlust
   =========================== */
#sCards .stage{display:flex; justify-content:center; align-items:flex-start;}
#sCards .flash{background:transparent; box-shadow:none; padding:0;}
#sCards .lf-meta{display:flex; justify-content:space-between; gap:12px; align-items:flex-start; margin:6px 6px 14px;}
#sCards .lf-overview{
  flex:1;
  background:rgba(255,255,255,.72);
  border:1px solid rgba(0,0,0,.06);
  border-radius:18px;
  padding:10px 12px;
  font-weight:800;
  color:var(--text);
  backdrop-filter: blur(10px);
}
#sCards .lf-source{
  min-width:180px;
  max-width:45%;
  background:rgba(255,255,255,.72);
  border:1px solid rgba(0,0,0,.06);
  border-radius:18px;
  padding:10px 12px;
  color:var(--muted);
  backdrop-filter: blur(10px);
}
#sCards .lf-card3d{
  width:min(820px, 100%);
  margin:0 auto;
  perspective: 1200px;
}
#sCards .lf-cardInner{
  position:relative;
  width:100%;
  min-height: 320px;
  border-radius: 28px;
  transform-style: preserve-3d;
  transition: transform .55s cubic-bezier(.2,.8,.2,1), box-shadow .55s;
  box-shadow: 0 18px 50px rgba(0,0,0,.12);
}
#sCards #flash1.revealed .lf-cardInner{ transform: rotateY(180deg); }
#sCards .lf-face{
  position:absolute;
  inset:0;
  border-radius:28px;
  padding:28px 26px;
  backface-visibility:hidden;
  overflow:hidden;
  display:flex;
  flex-direction:column;
  justify-content:center;
  gap:16px;
}
#sCards .lf-front{
  background:
    radial-gradient(1200px 420px at 30% -10%, rgba(0,200,255,.18), transparent 55%),
    radial-gradient(900px 520px at 120% 20%, rgba(0,255,170,.16), transparent 55%),
    linear-gradient(180deg, rgba(255,255,255,.96), rgba(255,255,255,.86));
  border:1px solid rgba(0,0,0,.06);
}
#sCards .lf-back{
  transform: rotateY(180deg);
  background:
    radial-gradient(1100px 520px at 30% -10%, rgba(255,200,0,.16), transparent 55%),
    radial-gradient(900px 520px at 120% 20%, rgba(255,0,150,.12), transparent 55%),
    linear-gradient(180deg, rgba(255,255,255,.96), rgba(255,255,255,.86));
  border:1px solid rgba(0,0,0,.06);
}
#sCards .q{
  font-size: clamp(22px, 2.6vw, 34px);
  line-height: 1.15;
  font-weight: 950;
  letter-spacing: -0.02em;
  margin:0;
}
#sCards .a{
  font-size: clamp(18px, 2.1vw, 26px);
  line-height: 1.25;
  font-weight: 850;
  color: #0b2b24;
  margin:0;
}
#sCards .lf-hint{
  margin-top:auto;
  font-weight:800;
  color: rgba(0,0,0,.45);
  background: rgba(0,0,0,.04);
  border: 1px dashed rgba(0,0,0,.12);
  border-radius: 18px;
  padding: 10px 12px;
}
#sCards .lf-backLabel{
  display:inline-flex;
  align-self:flex-start;
  font-weight:950;
  letter-spacing:.06em;
  text-transform:uppercase;
  font-size:12px;
  padding:8px 10px;
  border-radius: 999px;
  background: rgba(0,0,0,.05);
  border: 1px solid rgba(0,0,0,.08);
}
#sCards .lf-show{
  border-radius: 22px !important;
  padding: 16px 18px !important;
  font-weight: 950 !important;
  box-shadow: 0 10px 26px rgba(0,0,0,.10);
}
#sCards .lf-wrong, #sCards .lf-right{
  border-radius: 22px !important;
  padding: 16px 18px !important;
  font-weight: 950 !important;
  box-shadow: 0 10px 26px rgba(0,0,0,.10);
}
#sCards .lf-mini{
  border-radius: 18px !important;
  padding: 12px 14px !important;
}
#sCards .lf-safe{
  border-radius: 26px !important;
  padding: 18px 18px !important;
  font-weight: 950 !important;
  box-shadow: 0 16px 34px rgba(0,0,0,.12);
}
@media (max-width: 680px){
  #sCards .lf-meta{flex-direction:column;}
  #sCards .lf-source{max-width:100%; min-width:auto;}
  #sCards .lf-face{padding:22px 18px;}
  #sCards .lf-cardInner{min-height: 360px;}
}


/* ===============================
   üåø Ergotherapeutisches UI ‚Äì ruhige Buttons (calm, klar, seri√∂s)
   Ziel: weniger bunt, bessere Ruhe/Lesbarkeit, touch-friendly
   =============================== */

:root{
  --et-bg: #f6f8f9;
  --et-surface: #ffffff;
  --et-border: rgba(30, 60, 70, 0.14);
  --et-text: #12313a;
  --et-muted: rgba(18, 49, 58, 0.70);

  --et-primary: #2f7c87;      /* ruhiges Petrol */
  --et-primary-2: #276a73;
  --et-primary-soft: rgba(47, 124, 135, 0.10);

  --et-success: #2f8f6c;      /* gedecktes Gr√ºn */
  --et-success-soft: rgba(47, 143, 108, 0.12);

  --et-danger: #b04a4a;       /* gedecktes Rot */
  --et-danger-soft: rgba(176, 74, 74, 0.12);

  --et-shadow: 0 6px 18px rgba(14, 32, 38, 0.10);
  --et-shadow-hover: 0 10px 28px rgba(14, 32, 38, 0.14);
}

/* Button-Reset: wirkt konsistent √ºberall */
button, .btn {
  -webkit-tap-highlight-color: transparent;
  border-radius: 14px !important;
  padding: 12px 16px !important;
  font-size: 15px !important;
  font-weight: 650 !important;
  letter-spacing: 0.2px;
  line-height: 1.1;
  border: 1px solid var(--et-border) !important;
  color: var(--et-text) !important;
  background: var(--et-surface) !important;
  box-shadow: var(--et-shadow) !important;
  transition: transform 0.14s ease, box-shadow 0.14s ease, background-color 0.14s ease, border-color 0.14s ease, color 0.14s ease;
}

/* Prim√§r / Standard: ruhiger petrol Akzent */
button.primary, .btn.primary,
button[data-variant="primary"], .btn[data-variant="primary"]{
  background: linear-gradient(180deg, rgba(47,124,135,0.95), rgba(39,106,115,0.95)) !important;
  border-color: rgba(39,106,115,0.55) !important;
  color: #ffffff !important;
}

/* Sekund√§r/neutral */
button.secondary, .btn.secondary,
button[data-variant="secondary"], .btn[data-variant="secondary"]{
  background: rgba(47,124,135,0.06) !important;
  border-color: rgba(47,124,135,0.20) !important;
  color: var(--et-text) !important;
}

/* Erfolg & Gefahr ‚Äì gedeckt */
button.success, .btn.success,
button[data-variant="success"], .btn[data-variant="success"]{
  background: var(--et-success-soft) !important;
  border-color: rgba(47,143,108,0.35) !important;
  color: #0f3a2b !important;
}

button.danger, .btn.danger,
button[data-variant="danger"], .btn[data-variant="danger"]{
  background: var(--et-danger-soft) !important;
  border-color: rgba(176,74,74,0.35) !important;
  color: #4a1414 !important;
}

/* Hover/Active ‚Äì ruhig, nicht "bouncy" */
button:hover, .btn:hover {
  transform: translateY(-1px);
  box-shadow: var(--et-shadow-hover) !important;
  border-color: rgba(47,124,135,0.35) !important;
}

button:active, .btn:active {
  transform: translateY(0px);
  box-shadow: var(--et-shadow) !important;
}

/* Fokus sichtbar (A11y) */
button:focus-visible, .btn:focus-visible{
  outline: 3px solid rgba(47,124,135,0.28) !important;
  outline-offset: 2px;
}

/* Disabled */
button:disabled, .btn:disabled{
  opacity: 0.55;
  cursor: not-allowed;
  transform: none !important;
  box-shadow: none !important;
}

/* Kompakte Buttons in Toolbars/Leisten (falls vorhanden) */
.toolbar button, .topbar button, .actions button,
.toolbar .btn, .topbar .btn, .actions .btn{
  padding: 10px 14px !important;
  border-radius: 12px !important;
  box-shadow: 0 4px 14px rgba(14, 32, 38, 0.08) !important;
}

/* Reduce motion preference */
@media (prefers-reduced-motion: reduce){
  button, .btn{ transition: none !important; }
  button:hover, .btn:hover{ transform: none !important; }
}


/* üé¥ Karte per Tap drehen (ergotherapeutisch, minimal) */
#flash1 .lf-card3d{ cursor: pointer; }
#flash1 .lf-card3d:active{ transform: translateY(0px); }
#flash1 .lf-show{ display:none !important; } /* Button ‚ÄûAntwort zeigen‚Äú ausblenden ‚Äì Karte ist klickbar */


  /* Admin Gate */
  .admin-only{display:none;}
  .admin-unlocked .admin-only{display:block;}

/* === PATCH v38: Minimal & ruhig (Karten ohne "Bild"/Verlauf) === */
.lf-card3d, .lf-cardInner, .lf-face, .lf-front, .lf-back{
  background: #ffffff !important;
  background-image: none !important;
  box-shadow: 0 14px 34px rgba(0,0,0,.12) !important;
  border: 1px solid rgba(0,0,0,.08) !important;
}
.lf-front, .lf-back{
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
}
.lf-hint{
  color: rgba(0,0,0,.55) !important;
}
.lf-backLabel{
  background: rgba(0,0,0,.06) !important;
  border: 1px solid rgba(0,0,0,.08) !important;
}


/* === PATCH v39: Antwort als klare √úberschrift oben mittig === */
.lf-back{
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
}

.lf-backLabel{
  margin-top: 6px !important;
  margin-bottom: 18px !important;
  font-size: 1.25rem !important;
  font-weight: 700 !important;
  letter-spacing: .08em !important;
  text-transform: uppercase !important;
}

.lf-back .lf-content,
.lf-back .lf-text,
.lf-back .answerText{
  width: 100% !important;
  text-align: left !important;
}

.lf-back .answerText,
.lf-back .lf-text{
  font-size: 1.6rem !important;
  font-weight: 700 !important;
  line-height: 1.35 !important;
}


/* === PATCH v41: Antwort ganz oben & mittig (wie echte Karteikarte) === */
.lf-back{
  display: flex !important;
  flex-direction: column !important;
  justify-content: flex-start !important;
  align-items: center !important;
}

.lf-backLabel{
  order: 1 !important;
  margin-top: 10px !important;
  margin-bottom: 16px !important;
  align-self: center !important;
}

.lf-back .lf-text,
.lf-back .answerText{
  order: 2 !important;
  width: 100% !important;
  text-align: center !important;
  margin-top: 6px !important;
}


/* === PATCH v42: Antwort-Label oben mittig, Antworttext klar darunter mit Abstand === */
.lf-back{
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
}

/* Feld "ANTWORT" ganz oben */
.lf-backLabel{
  margin-top: 8px !important;
  margin-bottom: 32px !important; /* Abstand zum Antworttext */
  align-self: center !important;
}

/* Antworttext darunter */
.lf-back .lf-text,
.lf-back .answerText{
  width: 100% !important;
  text-align: center !important;
  margin-top: 0 !important;
}


/* === PATCH v43: Reihenfolge erzwingen -> Label 'ANTWORT' √úBER dem Antworttext === */
.lf-back{
  display:flex !important;
  flex-direction:column !important;
  justify-content:flex-start !important;
  align-items:center !important;
}

/* Label ganz nach oben */
.lf-backLabel{
  order: 0 !important;
  align-self:center !important;
  margin-top: 10px !important;
  margin-bottom: 26px !important;
}

/* Antworttext immer darunter */
.lf-back .lf-text,
.lf-back .answerText,
.lf-back [data-role="answer"],
.lf-back .lf-content{
  order: 1 !important;
  width: 100% !important;
  text-align: center !important;
  margin-top: 0 !important;
}


/* === PATCH v44: Vorderseite spiegeln -> FRAGE oben mittig, Fragetext darunter === */
.lf-front{
  display:flex !important;
  flex-direction:column !important;
  justify-content:flex-start !important;
  align-items:center !important;
}

/* Label FRAGE ganz nach oben */
.lf-frontLabel{
  order: 0 !important;
  align-self:center !important;
  margin-top: 10px !important;
  margin-bottom: 26px !important;
  font-size: 1.25rem !important;
  font-weight: 700 !important;
  letter-spacing: .08em !important;
  text-transform: uppercase !important;
}

/* Fragetext darunter */
.lf-front .lf-text,
.lf-front .questionText,
.lf-front [data-role="question"],
.lf-front .lf-content{
  order: 1 !important;
  width: 100% !important;
  text-align: center !important;
  margin-top: 0 !important;
  font-size: 1.6rem !important;
  font-weight: 700 !important;
}


/* === PATCH v45: FRAGE sichtbar machen (auch wenn kein Label im HTML existiert) === */

/* Falls kein .lf-frontLabel existiert, erzeugen wir FRAGE per Pseudo-Element */
.lf-front::before{
  content: "FRAGE";
  display: inline-flex;
  align-items: center;
  justify-content: center;
  align-self: center;
  margin-top: 10px;
  margin-bottom: 26px;
  padding: 10px 18px;
  border-radius: 999px;
  border: 2px solid rgba(0,0,0,.12);
  background: #ffffff;
  font-size: 1.25rem;
  font-weight: 700;
  letter-spacing: .08em;
  text-transform: uppercase;
}

/* Fragetext klar darunter, zentriert */
.lf-front .lf-text,
.lf-front .questionText,
.lf-front [data-role="question"],
.lf-front .lf-content{
  text-align: center !important;
  font-size: 1.6rem !important;
  font-weight: 700 !important;
  margin-top: 0 !important;
}


/* === PATCH v46: Hinweis 'Tippe auf die Karte‚Ä¶' entfernen === */
.lf-hint{
  display: none !important;
}


/* === √úbersicht (Statistik) ‚Äì klarer & kompakter === */
.lf-overview{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}
.ovLeft{ display:flex; flex-direction:column; gap:6px; }
.ovTitle{ font-weight:900; letter-spacing:.2px; }
.ovStats{ display:flex; flex-wrap:wrap; gap:6px; }
.ovChip{
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(0,0,0,.06);
  background:rgba(255,255,255,.75);
  font-size:12px;
  font-weight:800;
}
.ovChipLabel{ color:var(--muted); font-weight:900; letter-spacing:.2px; }
.ovChipVal{ font-size:13px; }
.ovRight{ display:flex; flex-direction:column; align-items:flex-end; gap:8px; min-width:160px; }
.ovPill{ font-weight:900; }
.ovBar{
  width:160px;
  height:10px;
  border-radius:999px;
  background:rgba(0,0,0,.08);
  overflow:hidden;
}
.ovBarFill{
  height:100%;
  border-radius:999px;
  background:#4CAF50;
}
@media (max-width: 520px){
  .lf-overview{ flex-direction:column; align-items:stretch; }
  .ovRight{ align-items:flex-start; min-width:unset; }
  .ovBar{ width:100%; }
}

/* === Klassen-Voting: Daumen √úBER der Karte (nur beim Lernen aus "Klasse teilen") === */
.voteBar{
  display:none;
  justify-content:center;
  gap:12px;
  margin:10px 0 8px 0;
}
.votePill{
  border:none;
  border-radius:999px;
  padding:10px 14px;
  font-weight:900;
  background:rgba(255,255,255,.9);
  box-shadow:0 6px 18px rgba(0,0,0,.10);
  cursor:pointer;
}
.votePill.ok{ background:#4CAF50; color:#fff; }
.votePill.danger{ background:#e74c3c; color:#fff; }
.votePill.ghost{ background:rgba(255,255,255,.75); color:#111; }


/* --- Level Widget in Modi: make it clearly visible --- */
.modeLvlRow{
  display:flex;
  justify-content:flex-end;
  width:100%;
  margin-top:14px;
}

/* EXTRA sichtbar (Tablet): gro√ües HUD im Modi-Header */
.modeLvlWidget{
  background: rgba(255,255,255,.92) !important;
  color:#111 !important;
  box-shadow: 0 18px 38px rgba(0,0,0,.18), inset 0 0 0 1px rgba(0,0,0,.10) !important;

  /* Gr√∂√üe/Pr√§senz */
  padding: 18px 22px !important;
  gap: 16px !important;
  border-radius: 22px !important;
  max-width: 760px !important;
  min-width: 560px !important;
}

.modeLvlWidget .lvlTitle,
.modeLvlWidget .lvlNum,
.modeLvlWidget .lvlSub{ color:#111 !important; }

.modeLvlWidget .lvlTitle{
  font-size: 15px !important;
  letter-spacing: .12em !important;
  opacity: .90 !important;
}

.modeLvlWidget .lvlNum{
  font-size: 30px !important;
  font-weight: 950 !important;
}

.modeLvlWidget .lvlSub{
  font-size: 15px !important;
  opacity: .85 !important;
}

.modeLvlWidget .lvlText{
  min-width: 190px !important;
  gap: 6px !important;
}

.modeLvlWidget .lvlBadge{
  width: 66px !important;
  height: 66px !important;
  border-radius: 22px !important;
  font-size: 30px !important;
}

.modeLvlWidget .lvlBarWrap{
  min-width: 320px !important;
  gap: 10px !important;
}

.modeLvlWidget .lvlBar{
  background: rgba(0,0,0,.10) !important;
  height: 24px !important;
  border-radius: 999px !important;
}

.modeLvlWidget .lvlFill{
  height: 24px !important;
  border-radius: 999px !important;
}

.modeLvlWidget .lvlTitleRow{
  font-size: 18px !important;
  gap: 10px !important;
}



/* vB8: Level-Anzeige neu integriert (Modus-Seite) */
.modeLvlRow{ justify-content:center; margin-top:18px; }
.modeProgressWrap{ width:100%; display:flex; justify-content:center; }
.progressCard{
  width:min(980px, 100%);
  background: rgba(255,255,255,.92);
  border-radius: 26px;
  padding: 18px 22px;
  box-shadow: 0 18px 38px rgba(0,0,0,.12), inset 0 0 0 1px rgba(0,0,0,.06);
}
.progressContent{ display:flex; flex-direction:column; gap:10px; }
.progressKicker{
  font-weight: 800;
  letter-spacing: .3px;
  opacity:.9;
  display:flex; align-items:center; gap:10px;
}
.progressLine{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  gap:14px;
  flex-wrap:wrap;
}
.progressLevelBlock{ display:flex; align-items:baseline; gap:10px; }
.progressLevelLabel{ font-weight:900; font-size: 22px; letter-spacing:.5px; }
.progressLevelNum{ font-weight:1000; font-size: 34px; line-height:1; }
.progressXpText{ font-weight:800; font-size:20px; opacity:.9; }
.progressBar{
  height: 14px;
  border-radius: 999px;
  background: rgba(0,0,0,.08);
  overflow:hidden;
  box-shadow: inset 0 2px 5px rgba(0,0,0,.12);
}
.progressFill{
  height:100%;
  width:0%;
  border-radius:999px;
  background: linear-gradient(90deg, rgba(255,196,0,.95), rgba(255,140,0,.95));
  box-shadow: 0 8px 18px rgba(255,153,0,.25);
}

/* Mobile/Tablet */
@media (max-width: 700px){
  .progressCard{ padding: 16px 16px; border-radius: 22px; }
  .progressLevelLabel{ font-size: 20px; }
  .progressLevelNum{ font-size: 32px; }
  .progressXpText{ font-size: 18px; }
}


/* ===== Dark Mode (vB10) ===== */
.themeToggleBtn{
  position:fixed;
  top:14px;
  right:14px;
  z-index:1000003;
  border-radius:999px !important;
  padding:10px 12px !important;
  min-width:auto !important;
  box-shadow:var(--shadow) !important;
  background: rgba(255,255,255,.75) !important;
  border:1px solid rgba(0,0,0,.10) !important;
  color: var(--text) !important;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}
.themeToggleBtn:active{transform: translateY(1px);}
html.dark .themeToggleBtn{
  background: rgba(22,31,33,.75) !important;
  border:1px solid rgba(255,255,255,.16) !important;
  color: var(--text) !important;
}

/* Variables override */
html.dark{
  color-scheme: dark;

  --bg:#0f1516;
  --bgTop:#0b1011;
  --card:#161f21;
  --text:#e8f1ef;
  --muted: rgba(232,241,239,.70);
  --danger: rgba(176,74,74,.20);
  --shadow:0 10px 30px rgba(0,0,0,.55);

  --et-bg:#0f1516;
  --et-surface:#161f21;
  --et-border: rgba(255,255,255,.14);
  --et-text:#e8f1ef;
  --et-muted: rgba(232,241,239,.70);
  --et-primary-soft: rgba(47,124,135,.18);
  --et-success-soft: rgba(47,143,108,.18);
  --et-danger-soft: rgba(176,74,74,.18);
  --et-shadow: 0 10px 26px rgba(0,0,0,.55);
  --et-shadow-hover: 0 14px 34px rgba(0,0,0,.62);
}

/* Core surfaces */
html.dark body{
  background: linear-gradient(180deg, var(--bgTop), var(--bg)) !important;
  color: var(--text) !important;
}
html.dark .card,
html.dark .tile,
html.dark .flash,
html.dark .ltModalBox{
  background: var(--card) !important;
  border-color: rgba(255,255,255,.10) !important;
}
html.dark .hr{ background: rgba(255,255,255,.10) !important; }

html.dark .input{
  background: rgba(255,255,255,.06) !important;
  border-color: rgba(255,255,255,.14) !important;
  color: var(--text) !important;
}
html.dark .input::placeholder{ color: rgba(232,241,239,.55) !important; }

html.dark .notice{
  background: rgba(255,255,255,.06) !important;
  border-color: rgba(255,255,255,.12) !important;
  color: var(--text) !important;
}

/* Flashcards (3D card + faces) */
html.dark .lf-card3d,
html.dark .lf-cardInner,
html.dark .lf-face,
html.dark .lf-front,
html.dark .lf-back{
  background: var(--card) !important;
  border-color: rgba(255,255,255,.12) !important;
  box-shadow: 0 14px 34px rgba(0,0,0,.55) !important;
}
html.dark .lf-hint{ color: rgba(232,241,239,.60) !important; }
html.dark .lf-backLabel{
  background: rgba(255,255,255,.08) !important;
  border-color: rgba(255,255,255,.14) !important;
}

/* Lists / mini buttons */
html.dark #ownCardsList button.btn,
html.dark #ownQuizList button.btn{
  background: rgba(255,255,255,.06) !important;
  border-color: rgba(255,255,255,.14) !important;
  color: var(--text) !important;
}
html.dark #ownCardsList button.btn.primary,
html.dark #ownQuizList button.btn.primary{
  background: rgba(47,143,108,.18) !important;
}
html.dark #ownCardsList button.btn.danger,
html.dark #ownQuizList button.btn.danger{
  background: rgba(176,74,74,.18) !important;
}

/* Level card in Modes */
html.dark .progressCard{
  background: rgba(22,31,33,.86) !important;
  border-color: rgba(255,255,255,.14) !important;
}
html.dark .progressBar{ background: rgba(255,255,255,.10) !important; }
html.dark .progressFill{ filter: brightness(1.05); }


/* üîß Dark Mode Button Fix (vB10.1) */
html.dark button,
html.dark .btn{
  color: #e8f1ef !important;
}

html.dark .btn.primary{
  color: #eafff6 !important;
}

html.dark .btn.danger{
  color: #ffecec !important;
}

html.dark button:disabled,
html.dark .btn:disabled{
  color: rgba(232,241,239,.45) !important;
}


/* üîß Dark Mode Readability Fix 2 (vB10.2) */
html.dark .lf-overview{
  background: rgba(255,255,255,.06) !important;
  border-color: rgba(255,255,255,.12) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 10px 24px rgba(0,0,0,.35) !important;
}
html.dark .lf-overview small{
  color: rgba(232,241,239,.78) !important;
  opacity: 1 !important;
}
html.dark .lf-overview .pill{
  background: rgba(232,241,239,.10) !important;
  border-color: rgba(232,241,239,.18) !important;
  color: rgba(232,241,239,.92) !important;
}

/* Filter-Chips im Dark Mode */
html.dark .chip{
  background: rgba(255,255,255,.08) !important;
  border-color: rgba(255,255,255,.18) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 6px 16px rgba(0,0,0,.25) !important;
}
html.dark .chip:active{ transform: translateY(1px); }


/* üîß Dark Mode Fix #3 ‚Äì Frage-Button Lesbarkeit */
html.dark .question-label,
html.dark .frage,
html.dark .question,
html.dark .card-front .label,
html.dark .frage-button{
  color: #0b1f1a !important;
  background: #eafff6 !important;
  font-weight: 700 !important;
  text-shadow: none !important;
}

html.dark .card-front{
  background: linear-gradient(180deg, #1e2b2a, #121b1a) !important;
}


/* üî• Dark Mode Kontrast-Overhaul (Final Analyse Fix) */

/* 1Ô∏è‚É£ Alle Texte pauschal heller */
html.dark body,
html.dark p,
html.dark span,
html.dark div,
html.dark h1,
html.dark h2,
html.dark h3,
html.dark h4,
html.dark h5,
html.dark h6,
html.dark label{
  color: #eaf4f2 !important;
}

/* 2Ô∏è‚É£ Frage / Antwort Badge */
html.dark .frage,
html.dark .antwort,
html.dark .question-label{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  font-weight: 800 !important;
  letter-spacing: 1px;
}

/* 3Ô∏è‚É£ Statistik (Gesamt / Offen / Sicher) */
html.dark .stat,
html.dark .stat span,
html.dark .stat-value{
  color: #ffffff !important;
  font-weight: 700;
}

/* 4Ô∏è‚É£ Chips & Filter */
html.dark .chip{
  background: #223332 !important;
  color: #ffffff !important;
  border: 1px solid #3d5c5a !important;
}

/* 5Ô∏è‚É£ Karteninhalt */
html.dark .card,
html.dark .card-front,
html.dark .card-back{
  background: #162221 !important;
  color: #ffffff !important;
}

/* 6Ô∏è‚É£ Platzhalter / disabled */
html.dark .muted,
html.dark .disabled{
  color: #9fb6b2 !important;
}


/* ‚úÖ Dark Mode Fix #5 ‚Äì "FRAGE" Label (Pseudo-Element & echtes Label) */
html.dark .lf-front::before,
html.dark .lf-frontLabel{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  border-color: rgba(255,255,255,.22) !important;
  text-shadow: none !important;
  font-weight: 900 !important;
}

html.dark .lf-front::before{
  box-shadow: 0 10px 30px rgba(0,0,0,.35) !important;
}

/* Falls irgendwo die Label-Farbe nochmal √ºberschrieben wird */
html.dark .lf-frontLabel *{
  color: #0b1f1a !important;
}


/* ‚úÖ Dark Mode Fix #6 ‚Äì Quiz: "Antwort ausw√§hlen" & Antworten Lesbarkeit */
html.dark .quiz-status{
  background: #223332 !important;
  color: #ffffff !important;
  border: 1px solid rgba(255,255,255,.16) !important;
}

html.dark .quiz-status.neutral{
  background: #223332 !important;
  color: #ffffff !important;
}

html.dark .quiz-status.right,
html.dark .quiz-status.correct{
  background: rgba(60, 170, 120, .22) !important;
  color: #eafff6 !important;
  border: 1px solid rgba(60,170,120,.35) !important;
}

html.dark .quiz-status.wrong,
html.dark .quiz-status.bad{
  background: rgba(220, 90, 90, .22) !important;
  color: #ffecec !important;
  border: 1px solid rgba(220,90,90,.35) !important;
}

/* Antwort-Buttons im Quiz (nur im Antworten-Bereich) */
html.dark .answers button,
html.dark .answers .btn{
  background: #1d2b2a !important;
  color: #ffffff !important;
  border: 1px solid rgba(255,255,255,.14) !important;
}

html.dark .answers button:hover{
  filter: brightness(1.08);
}

html.dark .answers button:disabled{
  background: rgba(29,43,42,.55) !important;
  color: rgba(255,255,255,.55) !important;
}


#quizQ{
  margin-top: 14px !important;
  margin-bottom: 16px !important;
}


/* ‚úÖ Filter-Suche (Chips) */
.chipSearchWrap{ flex:1 1 220px; min-width:180px; }
.chipSearch{
  width:100%;
  height:42px;
  border-radius:999px;
  border:1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.92);
  padding:0 14px;
  font-weight:800;
  outline:none;
}
html.dark .chipSearch{
  border:1px solid rgba(255,255,255,.16);
  background: rgba(20,30,29,.72);
  color: #ffffff;
}
html.dark .chipSearch::placeholder{ color: rgba(255,255,255,.55); }


/* ‚úÖ Sicher gelernt IMMER sichtbar */
#cardSafeBtn{
  display:flex !important;
  opacity:1 !important;
  pointer-events:auto !important;
}

</style>
<style>
/* START-FOKUS (v72): Home zeigt nur 3 Hauptfunktionen */
.grid .tile[onclick="openMode(2)"],
.grid .tile[onclick="openMode(6)"]{
  display:none !important;
}

/* Stats zun√§chst einklappen */
#masteryBox, #highscorePanel{
  display:none;
}

/* Toggle buttons */
.startToggles{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  justify-content:flex-start;
  margin:14px 0 0 0;
}
.startToggles .btnLite{
  border:1px solid rgba(0,0,0,.10);
  background:rgba(255,255,255,.72);
  border-radius:14px;
  padding:10px 12px;
  font-weight:800;
  cursor:pointer;
  box-shadow:0 8px 22px rgba(0,0,0,.06);
}
.startToggles .btnLite:active{ transform:translateY(1px); }

/* üîß Dark Mode Button Fix (vB10.1) */
html.dark button,
html.dark .btn{
  color: #e8f1ef !important;
}

html.dark .btn.primary{
  color: #eafff6 !important;
}

html.dark .btn.danger{
  color: #ffecec !important;
}

html.dark button:disabled,
html.dark .btn:disabled{
  color: rgba(232,241,239,.45) !important;
}


/* üîß Dark Mode Readability Fix 2 (vB10.2) */
html.dark .lf-overview{
  background: rgba(255,255,255,.06) !important;
  border-color: rgba(255,255,255,.12) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 10px 24px rgba(0,0,0,.35) !important;
}
html.dark .lf-overview small{
  color: rgba(232,241,239,.78) !important;
  opacity: 1 !important;
}
html.dark .lf-overview .pill{
  background: rgba(232,241,239,.10) !important;
  border-color: rgba(232,241,239,.18) !important;
  color: rgba(232,241,239,.92) !important;
}

/* Filter-Chips im Dark Mode */
html.dark .chip{
  background: rgba(255,255,255,.08) !important;
  border-color: rgba(255,255,255,.18) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 6px 16px rgba(0,0,0,.25) !important;
}
html.dark .chip:active{ transform: translateY(1px); }


/* üîß Dark Mode Fix #3 ‚Äì Frage-Button Lesbarkeit */
html.dark .question-label,
html.dark .frage,
html.dark .question,
html.dark .card-front .label,
html.dark .frage-button{
  color: #0b1f1a !important;
  background: #eafff6 !important;
  font-weight: 700 !important;
  text-shadow: none !important;
}

html.dark .card-front{
  background: linear-gradient(180deg, #1e2b2a, #121b1a) !important;
}


/* üî• Dark Mode Kontrast-Overhaul (Final Analyse Fix) */

/* 1Ô∏è‚É£ Alle Texte pauschal heller */
html.dark body,
html.dark p,
html.dark span,
html.dark div,
html.dark h1,
html.dark h2,
html.dark h3,
html.dark h4,
html.dark h5,
html.dark h6,
html.dark label{
  color: #eaf4f2 !important;
}

/* 2Ô∏è‚É£ Frage / Antwort Badge */
html.dark .frage,
html.dark .antwort,
html.dark .question-label{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  font-weight: 800 !important;
  letter-spacing: 1px;
}

/* 3Ô∏è‚É£ Statistik (Gesamt / Offen / Sicher) */
html.dark .stat,
html.dark .stat span,
html.dark .stat-value{
  color: #ffffff !important;
  font-weight: 700;
}

/* 4Ô∏è‚É£ Chips & Filter */
html.dark .chip{
  background: #223332 !important;
  color: #ffffff !important;
  border: 1px solid #3d5c5a !important;
}

/* 5Ô∏è‚É£ Karteninhalt */
html.dark .card,
html.dark .card-front,
html.dark .card-back{
  background: #162221 !important;
  color: #ffffff !important;
}

/* 6Ô∏è‚É£ Platzhalter / disabled */
html.dark .muted,
html.dark .disabled{
  color: #9fb6b2 !important;
}


/* ‚úÖ Dark Mode Fix #5 ‚Äì "FRAGE" Label (Pseudo-Element & echtes Label) */
html.dark .lf-front::before,
html.dark .lf-frontLabel{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  border-color: rgba(255,255,255,.22) !important;
  text-shadow: none !important;
  font-weight: 900 !important;
}

html.dark .lf-front::before{
  box-shadow: 0 10px 30px rgba(0,0,0,.35) !important;
}

/* Falls irgendwo die Label-Farbe nochmal √ºberschrieben wird */
html.dark .lf-frontLabel *{
  color: #0b1f1a !important;
}


/* ‚úÖ Sicher gelernt IMMER sichtbar */
#cardSafeBtn{
  display:flex !important;
  opacity:1 !important;
  pointer-events:auto !important;
}

</style>
<style id="lvlWidgetTinyOverride">
/* --- LVL Widget: make the COMPLETE field tiny & top-right --- */
.lvlWidget{
  position: fixed !important;
  top: 6px !important;
  right: 6px !important;
  left: auto !important;
  bottom: auto !important;
  transform: scale(0.35) !important;
  transform-origin: top right !important;
  z-index: 9999 !important;
  box-shadow: none !important;
}
.lvlWidget *{
  box-sizing: border-box !important;
}
.lvlWidget{
  padding: 6px 8px !important;
  border-radius: 14px !important;
}
.lvlWidget .lvlBar,
.lvlWidget .progress,
.lvlWidget progress{
  height: 8px !important;
  max-height: 8px !important;
}
.lvlWidget .lvlTitle,
.lvlWidget .lvlLabel,
.lvlWidget .lvlText,
.lvlWidget .lvlSub,
.lvlWidget span,
.lvlWidget div{
  font-size: 12px !important;
  line-height: 1.1 !important;
}

/* üîß Dark Mode Button Fix (vB10.1) */
html.dark button,
html.dark .btn{
  color: #e8f1ef !important;
}

html.dark .btn.primary{
  color: #eafff6 !important;
}

html.dark .btn.danger{
  color: #ffecec !important;
}

html.dark button:disabled,
html.dark .btn:disabled{
  color: rgba(232,241,239,.45) !important;
}


/* üîß Dark Mode Readability Fix 2 (vB10.2) */
html.dark .lf-overview{
  background: rgba(255,255,255,.06) !important;
  border-color: rgba(255,255,255,.12) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 10px 24px rgba(0,0,0,.35) !important;
}
html.dark .lf-overview small{
  color: rgba(232,241,239,.78) !important;
  opacity: 1 !important;
}
html.dark .lf-overview .pill{
  background: rgba(232,241,239,.10) !important;
  border-color: rgba(232,241,239,.18) !important;
  color: rgba(232,241,239,.92) !important;
}

/* Filter-Chips im Dark Mode */
html.dark .chip{
  background: rgba(255,255,255,.08) !important;
  border-color: rgba(255,255,255,.18) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 6px 16px rgba(0,0,0,.25) !important;
}
html.dark .chip:active{ transform: translateY(1px); }


/* üîß Dark Mode Fix #3 ‚Äì Frage-Button Lesbarkeit */
html.dark .question-label,
html.dark .frage,
html.dark .question,
html.dark .card-front .label,
html.dark .frage-button{
  color: #0b1f1a !important;
  background: #eafff6 !important;
  font-weight: 700 !important;
  text-shadow: none !important;
}

html.dark .card-front{
  background: linear-gradient(180deg, #1e2b2a, #121b1a) !important;
}


/* üî• Dark Mode Kontrast-Overhaul (Final Analyse Fix) */

/* 1Ô∏è‚É£ Alle Texte pauschal heller */
html.dark body,
html.dark p,
html.dark span,
html.dark div,
html.dark h1,
html.dark h2,
html.dark h3,
html.dark h4,
html.dark h5,
html.dark h6,
html.dark label{
  color: #eaf4f2 !important;
}

/* 2Ô∏è‚É£ Frage / Antwort Badge */
html.dark .frage,
html.dark .antwort,
html.dark .question-label{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  font-weight: 800 !important;
  letter-spacing: 1px;
}

/* 3Ô∏è‚É£ Statistik (Gesamt / Offen / Sicher) */
html.dark .stat,
html.dark .stat span,
html.dark .stat-value{
  color: #ffffff !important;
  font-weight: 700;
}

/* 4Ô∏è‚É£ Chips & Filter */
html.dark .chip{
  background: #223332 !important;
  color: #ffffff !important;
  border: 1px solid #3d5c5a !important;
}

/* 5Ô∏è‚É£ Karteninhalt */
html.dark .card,
html.dark .card-front,
html.dark .card-back{
  background: #162221 !important;
  color: #ffffff !important;
}

/* 6Ô∏è‚É£ Platzhalter / disabled */
html.dark .muted,
html.dark .disabled{
  color: #9fb6b2 !important;
}


/* ‚úÖ Dark Mode Fix #5 ‚Äì "FRAGE" Label (Pseudo-Element & echtes Label) */
html.dark .lf-front::before,
html.dark .lf-frontLabel{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  border-color: rgba(255,255,255,.22) !important;
  text-shadow: none !important;
  font-weight: 900 !important;
}

html.dark .lf-front::before{
  box-shadow: 0 10px 30px rgba(0,0,0,.35) !important;
}

/* Falls irgendwo die Label-Farbe nochmal √ºberschrieben wird */
html.dark .lf-frontLabel *{
  color: #0b1f1a !important;
}


/* ‚úÖ Sicher gelernt IMMER sichtbar */
#cardSafeBtn{
  display:flex !important;
  opacity:1 !important;
  pointer-events:auto !important;
}

</style>
<style id="adminCreateTileOverride">
/* Force show create tiles when admin is unlocked (overrides START-FOKUS hide rule) */
.admin-unlocked .grid .tile[onclick="openMode(2)"]{ display:flex !important; }
.admin-unlocked .tileCreate{ display:flex !important; }

/* üîß Dark Mode Button Fix (vB10.1) */
html.dark button,
html.dark .btn{
  color: #e8f1ef !important;
}

html.dark .btn.primary{
  color: #eafff6 !important;
}

html.dark .btn.danger{
  color: #ffecec !important;
}

html.dark button:disabled,
html.dark .btn:disabled{
  color: rgba(232,241,239,.45) !important;
}


/* üîß Dark Mode Readability Fix 2 (vB10.2) */
html.dark .lf-overview{
  background: rgba(255,255,255,.06) !important;
  border-color: rgba(255,255,255,.12) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 10px 24px rgba(0,0,0,.35) !important;
}
html.dark .lf-overview small{
  color: rgba(232,241,239,.78) !important;
  opacity: 1 !important;
}
html.dark .lf-overview .pill{
  background: rgba(232,241,239,.10) !important;
  border-color: rgba(232,241,239,.18) !important;
  color: rgba(232,241,239,.92) !important;
}

/* Filter-Chips im Dark Mode */
html.dark .chip{
  background: rgba(255,255,255,.08) !important;
  border-color: rgba(255,255,255,.18) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 6px 16px rgba(0,0,0,.25) !important;
}
html.dark .chip:active{ transform: translateY(1px); }


/* üîß Dark Mode Fix #3 ‚Äì Frage-Button Lesbarkeit */
html.dark .question-label,
html.dark .frage,
html.dark .question,
html.dark .card-front .label,
html.dark .frage-button{
  color: #0b1f1a !important;
  background: #eafff6 !important;
  font-weight: 700 !important;
  text-shadow: none !important;
}

html.dark .card-front{
  background: linear-gradient(180deg, #1e2b2a, #121b1a) !important;
}


/* üî• Dark Mode Kontrast-Overhaul (Final Analyse Fix) */

/* 1Ô∏è‚É£ Alle Texte pauschal heller */
html.dark body,
html.dark p,
html.dark span,
html.dark div,
html.dark h1,
html.dark h2,
html.dark h3,
html.dark h4,
html.dark h5,
html.dark h6,
html.dark label{
  color: #eaf4f2 !important;
}

/* 2Ô∏è‚É£ Frage / Antwort Badge */
html.dark .frage,
html.dark .antwort,
html.dark .question-label{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  font-weight: 800 !important;
  letter-spacing: 1px;
}

/* 3Ô∏è‚É£ Statistik (Gesamt / Offen / Sicher) */
html.dark .stat,
html.dark .stat span,
html.dark .stat-value{
  color: #ffffff !important;
  font-weight: 700;
}

/* 4Ô∏è‚É£ Chips & Filter */
html.dark .chip{
  background: #223332 !important;
  color: #ffffff !important;
  border: 1px solid #3d5c5a !important;
}

/* 5Ô∏è‚É£ Karteninhalt */
html.dark .card,
html.dark .card-front,
html.dark .card-back{
  background: #162221 !important;
  color: #ffffff !important;
}

/* 6Ô∏è‚É£ Platzhalter / disabled */
html.dark .muted,
html.dark .disabled{
  color: #9fb6b2 !important;
}


/* ‚úÖ Dark Mode Fix #5 ‚Äì "FRAGE" Label (Pseudo-Element & echtes Label) */
html.dark .lf-front::before,
html.dark .lf-frontLabel{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  border-color: rgba(255,255,255,.22) !important;
  text-shadow: none !important;
  font-weight: 900 !important;
}

html.dark .lf-front::before{
  box-shadow: 0 10px 30px rgba(0,0,0,.35) !important;
}

/* Falls irgendwo die Label-Farbe nochmal √ºberschrieben wird */
html.dark .lf-frontLabel *{
  color: #0b1f1a !important;
}


/* ‚úÖ Sicher gelernt IMMER sichtbar */
#cardSafeBtn{
  display:flex !important;
  opacity:1 !important;
  pointer-events:auto !important;
}

</style>
<style id="createForAllOverride">
/* Everyone can use favorites + create single cards: keep creation entry visible
   IMPORTANT: Keep tile layout intact (grid), otherwise titles can shift (e.g., Quiz). */
.tileCreate,
.tile[onclick="openMode(2)"],
.tile[onclick="openMode(3)"]{
  display: grid !important;
  visibility: visible !important;
  opacity: 1 !important;
}
#quickCreateBtn{
  display: block !important;
  visibility: visible !important;
  opacity: 1 !important;
}
/* Neutralize any legacy "hide create" wrapper if present */
.hideCreateTiles .tileCreate,
.hideCreateTiles .tile[onclick="openMode(2)"],
.hideCreateTiles .tile[onclick="openMode(3)"]{
  display:grid !important;
}
.hideCreateTiles #quickCreateBtn{
  display:block !important;
}

/* üîß Dark Mode Button Fix (vB10.1) */
html.dark button,
html.dark .btn{
  color: #e8f1ef !important;
}

html.dark .btn.primary{
  color: #eafff6 !important;
}

html.dark .btn.danger{
  color: #ffecec !important;
}

html.dark button:disabled,
html.dark .btn:disabled{
  color: rgba(232,241,239,.45) !important;
}


/* üîß Dark Mode Readability Fix 2 (vB10.2) */
html.dark .lf-overview{
  background: rgba(255,255,255,.06) !important;
  border-color: rgba(255,255,255,.12) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 10px 24px rgba(0,0,0,.35) !important;
}
html.dark .lf-overview small{
  color: rgba(232,241,239,.78) !important;
  opacity: 1 !important;
}
html.dark .lf-overview .pill{
  background: rgba(232,241,239,.10) !important;
  border-color: rgba(232,241,239,.18) !important;
  color: rgba(232,241,239,.92) !important;
}

/* Filter-Chips im Dark Mode */
html.dark .chip{
  background: rgba(255,255,255,.08) !important;
  border-color: rgba(255,255,255,.18) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 6px 16px rgba(0,0,0,.25) !important;
}
html.dark .chip:active{ transform: translateY(1px); }


/* üîß Dark Mode Fix #3 ‚Äì Frage-Button Lesbarkeit */
html.dark .question-label,
html.dark .frage,
html.dark .question,
html.dark .card-front .label,
html.dark .frage-button{
  color: #0b1f1a !important;
  background: #eafff6 !important;
  font-weight: 700 !important;
  text-shadow: none !important;
}

html.dark .card-front{
  background: linear-gradient(180deg, #1e2b2a, #121b1a) !important;
}


/* üî• Dark Mode Kontrast-Overhaul (Final Analyse Fix) */

/* 1Ô∏è‚É£ Alle Texte pauschal heller */
html.dark body,
html.dark p,
html.dark span,
html.dark div,
html.dark h1,
html.dark h2,
html.dark h3,
html.dark h4,
html.dark h5,
html.dark h6,
html.dark label{
  color: #eaf4f2 !important;
}

/* 2Ô∏è‚É£ Frage / Antwort Badge */
html.dark .frage,
html.dark .antwort,
html.dark .question-label{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  font-weight: 800 !important;
  letter-spacing: 1px;
}

/* 3Ô∏è‚É£ Statistik (Gesamt / Offen / Sicher) */
html.dark .stat,
html.dark .stat span,
html.dark .stat-value{
  color: #ffffff !important;
  font-weight: 700;
}

/* 4Ô∏è‚É£ Chips & Filter */
html.dark .chip{
  background: #223332 !important;
  color: #ffffff !important;
  border: 1px solid #3d5c5a !important;
}

/* 5Ô∏è‚É£ Karteninhalt */
html.dark .card,
html.dark .card-front,
html.dark .card-back{
  background: #162221 !important;
  color: #ffffff !important;
}

/* 6Ô∏è‚É£ Platzhalter / disabled */
html.dark .muted,
html.dark .disabled{
  color: #9fb6b2 !important;
}


/* ‚úÖ Dark Mode Fix #5 ‚Äì "FRAGE" Label (Pseudo-Element & echtes Label) */
html.dark .lf-front::before,
html.dark .lf-frontLabel{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  border-color: rgba(255,255,255,.22) !important;
  text-shadow: none !important;
  font-weight: 900 !important;
}

html.dark .lf-front::before{
  box-shadow: 0 10px 30px rgba(0,0,0,.35) !important;
}

/* Falls irgendwo die Label-Farbe nochmal √ºberschrieben wird */
html.dark .lf-frontLabel *{
  color: #0b1f1a !important;
}


/* ‚úÖ Sicher gelernt IMMER sichtbar */
#cardSafeBtn{
  display:flex !important;
  opacity:1 !important;
  pointer-events:auto !important;
}

</style>
<style id="modeCountAdminOnly">
/* Counts (Karten/Fragen/geteilt) only visible in Admin-Modus */
.modeCount{ display:none !important; }
.admin-unlocked .modeCount{ display:inline-flex !important; }

/* üîß Dark Mode Button Fix (vB10.1) */
html.dark button,
html.dark .btn{
  color: #e8f1ef !important;
}

html.dark .btn.primary{
  color: #eafff6 !important;
}

html.dark .btn.danger{
  color: #ffecec !important;
}

html.dark button:disabled,
html.dark .btn:disabled{
  color: rgba(232,241,239,.45) !important;
}


/* üîß Dark Mode Readability Fix 2 (vB10.2) */
html.dark .lf-overview{
  background: rgba(255,255,255,.06) !important;
  border-color: rgba(255,255,255,.12) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 10px 24px rgba(0,0,0,.35) !important;
}
html.dark .lf-overview small{
  color: rgba(232,241,239,.78) !important;
  opacity: 1 !important;
}
html.dark .lf-overview .pill{
  background: rgba(232,241,239,.10) !important;
  border-color: rgba(232,241,239,.18) !important;
  color: rgba(232,241,239,.92) !important;
}

/* Filter-Chips im Dark Mode */
html.dark .chip{
  background: rgba(255,255,255,.08) !important;
  border-color: rgba(255,255,255,.18) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 6px 16px rgba(0,0,0,.25) !important;
}
html.dark .chip:active{ transform: translateY(1px); }


/* üîß Dark Mode Fix #3 ‚Äì Frage-Button Lesbarkeit */
html.dark .question-label,
html.dark .frage,
html.dark .question,
html.dark .card-front .label,
html.dark .frage-button{
  color: #0b1f1a !important;
  background: #eafff6 !important;
  font-weight: 700 !important;
  text-shadow: none !important;
}

html.dark .card-front{
  background: linear-gradient(180deg, #1e2b2a, #121b1a) !important;
}


/* üî• Dark Mode Kontrast-Overhaul (Final Analyse Fix) */

/* 1Ô∏è‚É£ Alle Texte pauschal heller */
html.dark body,
html.dark p,
html.dark span,
html.dark div,
html.dark h1,
html.dark h2,
html.dark h3,
html.dark h4,
html.dark h5,
html.dark h6,
html.dark label{
  color: #eaf4f2 !important;
}

/* 2Ô∏è‚É£ Frage / Antwort Badge */
html.dark .frage,
html.dark .antwort,
html.dark .question-label{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  font-weight: 800 !important;
  letter-spacing: 1px;
}

/* 3Ô∏è‚É£ Statistik (Gesamt / Offen / Sicher) */
html.dark .stat,
html.dark .stat span,
html.dark .stat-value{
  color: #ffffff !important;
  font-weight: 700;
}

/* 4Ô∏è‚É£ Chips & Filter */
html.dark .chip{
  background: #223332 !important;
  color: #ffffff !important;
  border: 1px solid #3d5c5a !important;
}

/* 5Ô∏è‚É£ Karteninhalt */
html.dark .card,
html.dark .card-front,
html.dark .card-back{
  background: #162221 !important;
  color: #ffffff !important;
}

/* 6Ô∏è‚É£ Platzhalter / disabled */
html.dark .muted,
html.dark .disabled{
  color: #9fb6b2 !important;
}


/* ‚úÖ Dark Mode Fix #5 ‚Äì "FRAGE" Label (Pseudo-Element & echtes Label) */
html.dark .lf-front::before,
html.dark .lf-frontLabel{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  border-color: rgba(255,255,255,.22) !important;
  text-shadow: none !important;
  font-weight: 900 !important;
}

html.dark .lf-front::before{
  box-shadow: 0 10px 30px rgba(0,0,0,.35) !important;
}

/* Falls irgendwo die Label-Farbe nochmal √ºberschrieben wird */
html.dark .lf-frontLabel *{
  color: #0b1f1a !important;
}


/* ‚úÖ Sicher gelernt IMMER sichtbar */
#cardSafeBtn{
  display:flex !important;
  opacity:1 !important;
  pointer-events:auto !important;
}

</style>
<style id="statsCreateGridCss">
  .statsCreateGrid{
    display:flex;
    gap:14px;
    align-items:flex-start;
    margin-top:10px;
    flex-wrap:wrap;
  }
  .statsCreateGrid .statsCol{
    display:flex;
    flex-direction:column;
    gap:8px;
    align-items:flex-start;
  }

/* üîß Dark Mode Button Fix (vB10.1) */
html.dark button,
html.dark .btn{
  color: #e8f1ef !important;
}

html.dark .btn.primary{
  color: #eafff6 !important;
}

html.dark .btn.danger{
  color: #ffecec !important;
}

html.dark button:disabled,
html.dark .btn:disabled{
  color: rgba(232,241,239,.45) !important;
}


/* üîß Dark Mode Readability Fix 2 (vB10.2) */
html.dark .lf-overview{
  background: rgba(255,255,255,.06) !important;
  border-color: rgba(255,255,255,.12) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 10px 24px rgba(0,0,0,.35) !important;
}
html.dark .lf-overview small{
  color: rgba(232,241,239,.78) !important;
  opacity: 1 !important;
}
html.dark .lf-overview .pill{
  background: rgba(232,241,239,.10) !important;
  border-color: rgba(232,241,239,.18) !important;
  color: rgba(232,241,239,.92) !important;
}

/* Filter-Chips im Dark Mode */
html.dark .chip{
  background: rgba(255,255,255,.08) !important;
  border-color: rgba(255,255,255,.18) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 6px 16px rgba(0,0,0,.25) !important;
}
html.dark .chip:active{ transform: translateY(1px); }


/* üîß Dark Mode Fix #3 ‚Äì Frage-Button Lesbarkeit */
html.dark .question-label,
html.dark .frage,
html.dark .question,
html.dark .card-front .label,
html.dark .frage-button{
  color: #0b1f1a !important;
  background: #eafff6 !important;
  font-weight: 700 !important;
  text-shadow: none !important;
}

html.dark .card-front{
  background: linear-gradient(180deg, #1e2b2a, #121b1a) !important;
}


/* üî• Dark Mode Kontrast-Overhaul (Final Analyse Fix) */

/* 1Ô∏è‚É£ Alle Texte pauschal heller */
html.dark body,
html.dark p,
html.dark span,
html.dark div,
html.dark h1,
html.dark h2,
html.dark h3,
html.dark h4,
html.dark h5,
html.dark h6,
html.dark label{
  color: #eaf4f2 !important;
}

/* 2Ô∏è‚É£ Frage / Antwort Badge */
html.dark .frage,
html.dark .antwort,
html.dark .question-label{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  font-weight: 800 !important;
  letter-spacing: 1px;
}

/* 3Ô∏è‚É£ Statistik (Gesamt / Offen / Sicher) */
html.dark .stat,
html.dark .stat span,
html.dark .stat-value{
  color: #ffffff !important;
  font-weight: 700;
}

/* 4Ô∏è‚É£ Chips & Filter */
html.dark .chip{
  background: #223332 !important;
  color: #ffffff !important;
  border: 1px solid #3d5c5a !important;
}

/* 5Ô∏è‚É£ Karteninhalt */
html.dark .card,
html.dark .card-front,
html.dark .card-back{
  background: #162221 !important;
  color: #ffffff !important;
}

/* 6Ô∏è‚É£ Platzhalter / disabled */
html.dark .muted,
html.dark .disabled{
  color: #9fb6b2 !important;
}


/* ‚úÖ Dark Mode Fix #5 ‚Äì "FRAGE" Label (Pseudo-Element & echtes Label) */
html.dark .lf-front::before,
html.dark .lf-frontLabel{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  border-color: rgba(255,255,255,.22) !important;
  text-shadow: none !important;
  font-weight: 900 !important;
}

html.dark .lf-front::before{
  box-shadow: 0 10px 30px rgba(0,0,0,.35) !important;
}

/* Falls irgendwo die Label-Farbe nochmal √ºberschrieben wird */
html.dark .lf-frontLabel *{
  color: #0b1f1a !important;
}


/* ‚úÖ Sicher gelernt IMMER sichtbar */
#cardSafeBtn{
  display:flex !important;
  opacity:1 !important;
  pointer-events:auto !important;
}

</style>
<style id="forceSideBySideStats">
  .statsCreateGrid{
    display:flex !important;
    flex-wrap:nowrap !important;
    gap:20px !important;
  }
  .statsCreateGrid .statsCol{
    min-width:220px;
  }

/* üîß Dark Mode Button Fix (vB10.1) */
html.dark button,
html.dark .btn{
  color: #e8f1ef !important;
}

html.dark .btn.primary{
  color: #eafff6 !important;
}

html.dark .btn.danger{
  color: #ffecec !important;
}

html.dark button:disabled,
html.dark .btn:disabled{
  color: rgba(232,241,239,.45) !important;
}


/* üîß Dark Mode Readability Fix 2 (vB10.2) */
html.dark .lf-overview{
  background: rgba(255,255,255,.06) !important;
  border-color: rgba(255,255,255,.12) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 10px 24px rgba(0,0,0,.35) !important;
}
html.dark .lf-overview small{
  color: rgba(232,241,239,.78) !important;
  opacity: 1 !important;
}
html.dark .lf-overview .pill{
  background: rgba(232,241,239,.10) !important;
  border-color: rgba(232,241,239,.18) !important;
  color: rgba(232,241,239,.92) !important;
}

/* Filter-Chips im Dark Mode */
html.dark .chip{
  background: rgba(255,255,255,.08) !important;
  border-color: rgba(255,255,255,.18) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 6px 16px rgba(0,0,0,.25) !important;
}
html.dark .chip:active{ transform: translateY(1px); }


/* üîß Dark Mode Fix #3 ‚Äì Frage-Button Lesbarkeit */
html.dark .question-label,
html.dark .frage,
html.dark .question,
html.dark .card-front .label,
html.dark .frage-button{
  color: #0b1f1a !important;
  background: #eafff6 !important;
  font-weight: 700 !important;
  text-shadow: none !important;
}

html.dark .card-front{
  background: linear-gradient(180deg, #1e2b2a, #121b1a) !important;
}


/* üî• Dark Mode Kontrast-Overhaul (Final Analyse Fix) */

/* 1Ô∏è‚É£ Alle Texte pauschal heller */
html.dark body,
html.dark p,
html.dark span,
html.dark div,
html.dark h1,
html.dark h2,
html.dark h3,
html.dark h4,
html.dark h5,
html.dark h6,
html.dark label{
  color: #eaf4f2 !important;
}

/* 2Ô∏è‚É£ Frage / Antwort Badge */
html.dark .frage,
html.dark .antwort,
html.dark .question-label{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  font-weight: 800 !important;
  letter-spacing: 1px;
}

/* 3Ô∏è‚É£ Statistik (Gesamt / Offen / Sicher) */
html.dark .stat,
html.dark .stat span,
html.dark .stat-value{
  color: #ffffff !important;
  font-weight: 700;
}

/* 4Ô∏è‚É£ Chips & Filter */
html.dark .chip{
  background: #223332 !important;
  color: #ffffff !important;
  border: 1px solid #3d5c5a !important;
}

/* 5Ô∏è‚É£ Karteninhalt */
html.dark .card,
html.dark .card-front,
html.dark .card-back{
  background: #162221 !important;
  color: #ffffff !important;
}

/* 6Ô∏è‚É£ Platzhalter / disabled */
html.dark .muted,
html.dark .disabled{
  color: #9fb6b2 !important;
}


/* ‚úÖ Dark Mode Fix #5 ‚Äì "FRAGE" Label (Pseudo-Element & echtes Label) */
html.dark .lf-front::before,
html.dark .lf-frontLabel{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  border-color: rgba(255,255,255,.22) !important;
  text-shadow: none !important;
  font-weight: 900 !important;
}

html.dark .lf-front::before{
  box-shadow: 0 10px 30px rgba(0,0,0,.35) !important;
}

/* Falls irgendwo die Label-Farbe nochmal √ºberschrieben wird */
html.dark .lf-frontLabel *{
  color: #0b1f1a !important;
}


/* ‚úÖ Sicher gelernt IMMER sichtbar */
#cardSafeBtn{
  display:flex !important;
  opacity:1 !important;
  pointer-events:auto !important;
}

</style>
<style id="statsTwoColForceGrid">
  /* Force Lernstand/Highscore area into 2 columns */
  .statsCreateGrid{
    display: grid !important;
    grid-template-columns: 1fr 1fr !important;
    column-gap: 18px !important;
    row-gap: 10px !important;
    align-items: start !important;
    width: 100% !important;
    max-width: 980px;
  }
  .statsCreateGrid .statsCol{
    min-width: 0 !important;
  }
  /* Make buttons fit inside columns on tablets */
  .statsCreateGrid .btnLite{
    width: 100% !important;
    max-width: 100% !important;
    white-space: nowrap;
  }
  /* If the container is too narrow, keep 2 cols but shrink text slightly */
  @media (max-width: 780px){
    .statsCreateGrid .btnLite{ font-size: 14px !important; padding: 12px 14px !important; }
  }

/* üîß Dark Mode Button Fix (vB10.1) */
html.dark button,
html.dark .btn{
  color: #e8f1ef !important;
}

html.dark .btn.primary{
  color: #eafff6 !important;
}

html.dark .btn.danger{
  color: #ffecec !important;
}

html.dark button:disabled,
html.dark .btn:disabled{
  color: rgba(232,241,239,.45) !important;
}


/* üîß Dark Mode Readability Fix 2 (vB10.2) */
html.dark .lf-overview{
  background: rgba(255,255,255,.06) !important;
  border-color: rgba(255,255,255,.12) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 10px 24px rgba(0,0,0,.35) !important;
}
html.dark .lf-overview small{
  color: rgba(232,241,239,.78) !important;
  opacity: 1 !important;
}
html.dark .lf-overview .pill{
  background: rgba(232,241,239,.10) !important;
  border-color: rgba(232,241,239,.18) !important;
  color: rgba(232,241,239,.92) !important;
}

/* Filter-Chips im Dark Mode */
html.dark .chip{
  background: rgba(255,255,255,.08) !important;
  border-color: rgba(255,255,255,.18) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 6px 16px rgba(0,0,0,.25) !important;
}
html.dark .chip:active{ transform: translateY(1px); }


/* üîß Dark Mode Fix #3 ‚Äì Frage-Button Lesbarkeit */
html.dark .question-label,
html.dark .frage,
html.dark .question,
html.dark .card-front .label,
html.dark .frage-button{
  color: #0b1f1a !important;
  background: #eafff6 !important;
  font-weight: 700 !important;
  text-shadow: none !important;
}

html.dark .card-front{
  background: linear-gradient(180deg, #1e2b2a, #121b1a) !important;
}


/* üî• Dark Mode Kontrast-Overhaul (Final Analyse Fix) */

/* 1Ô∏è‚É£ Alle Texte pauschal heller */
html.dark body,
html.dark p,
html.dark span,
html.dark div,
html.dark h1,
html.dark h2,
html.dark h3,
html.dark h4,
html.dark h5,
html.dark h6,
html.dark label{
  color: #eaf4f2 !important;
}

/* 2Ô∏è‚É£ Frage / Antwort Badge */
html.dark .frage,
html.dark .antwort,
html.dark .question-label{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  font-weight: 800 !important;
  letter-spacing: 1px;
}

/* 3Ô∏è‚É£ Statistik (Gesamt / Offen / Sicher) */
html.dark .stat,
html.dark .stat span,
html.dark .stat-value{
  color: #ffffff !important;
  font-weight: 700;
}

/* 4Ô∏è‚É£ Chips & Filter */
html.dark .chip{
  background: #223332 !important;
  color: #ffffff !important;
  border: 1px solid #3d5c5a !important;
}

/* 5Ô∏è‚É£ Karteninhalt */
html.dark .card,
html.dark .card-front,
html.dark .card-back{
  background: #162221 !important;
  color: #ffffff !important;
}

/* 6Ô∏è‚É£ Platzhalter / disabled */
html.dark .muted,
html.dark .disabled{
  color: #9fb6b2 !important;
}


/* ‚úÖ Dark Mode Fix #5 ‚Äì "FRAGE" Label (Pseudo-Element & echtes Label) */
html.dark .lf-front::before,
html.dark .lf-frontLabel{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  border-color: rgba(255,255,255,.22) !important;
  text-shadow: none !important;
  font-weight: 900 !important;
}

html.dark .lf-front::before{
  box-shadow: 0 10px 30px rgba(0,0,0,.35) !important;
}

/* Falls irgendwo die Label-Farbe nochmal √ºberschrieben wird */
html.dark .lf-frontLabel *{
  color: #0b1f1a !important;
}


/* ‚úÖ Sicher gelernt IMMER sichtbar */
#cardSafeBtn{
  display:flex !important;
  opacity:1 !important;
  pointer-events:auto !important;
}

</style>
<style id="startToggleGridCss">
  #startToggles{ width:100%; }
  .startToggleGrid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:16px;
    align-items:start;
    width:100%;
    max-width: 980px;
  }
  .startCol{
    display:flex;
    flex-direction:column;
    gap:10px;
    align-items:stretch;
  }
  .startCol .btnLite{
    width:100%;
    white-space:nowrap;
  }
  @media (max-width: 560px){
    .startToggleGrid{ grid-template-columns: 1fr; }
  }

/* üîß Dark Mode Button Fix (vB10.1) */
html.dark button,
html.dark .btn{
  color: #e8f1ef !important;
}

html.dark .btn.primary{
  color: #eafff6 !important;
}

html.dark .btn.danger{
  color: #ffecec !important;
}

html.dark button:disabled,
html.dark .btn:disabled{
  color: rgba(232,241,239,.45) !important;
}


/* üîß Dark Mode Readability Fix 2 (vB10.2) */
html.dark .lf-overview{
  background: rgba(255,255,255,.06) !important;
  border-color: rgba(255,255,255,.12) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 10px 24px rgba(0,0,0,.35) !important;
}
html.dark .lf-overview small{
  color: rgba(232,241,239,.78) !important;
  opacity: 1 !important;
}
html.dark .lf-overview .pill{
  background: rgba(232,241,239,.10) !important;
  border-color: rgba(232,241,239,.18) !important;
  color: rgba(232,241,239,.92) !important;
}

/* Filter-Chips im Dark Mode */
html.dark .chip{
  background: rgba(255,255,255,.08) !important;
  border-color: rgba(255,255,255,.18) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 6px 16px rgba(0,0,0,.25) !important;
}
html.dark .chip:active{ transform: translateY(1px); }


/* üîß Dark Mode Fix #3 ‚Äì Frage-Button Lesbarkeit */
html.dark .question-label,
html.dark .frage,
html.dark .question,
html.dark .card-front .label,
html.dark .frage-button{
  color: #0b1f1a !important;
  background: #eafff6 !important;
  font-weight: 700 !important;
  text-shadow: none !important;
}

html.dark .card-front{
  background: linear-gradient(180deg, #1e2b2a, #121b1a) !important;
}


/* üî• Dark Mode Kontrast-Overhaul (Final Analyse Fix) */

/* 1Ô∏è‚É£ Alle Texte pauschal heller */
html.dark body,
html.dark p,
html.dark span,
html.dark div,
html.dark h1,
html.dark h2,
html.dark h3,
html.dark h4,
html.dark h5,
html.dark h6,
html.dark label{
  color: #eaf4f2 !important;
}

/* 2Ô∏è‚É£ Frage / Antwort Badge */
html.dark .frage,
html.dark .antwort,
html.dark .question-label{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  font-weight: 800 !important;
  letter-spacing: 1px;
}

/* 3Ô∏è‚É£ Statistik (Gesamt / Offen / Sicher) */
html.dark .stat,
html.dark .stat span,
html.dark .stat-value{
  color: #ffffff !important;
  font-weight: 700;
}

/* 4Ô∏è‚É£ Chips & Filter */
html.dark .chip{
  background: #223332 !important;
  color: #ffffff !important;
  border: 1px solid #3d5c5a !important;
}

/* 5Ô∏è‚É£ Karteninhalt */
html.dark .card,
html.dark .card-front,
html.dark .card-back{
  background: #162221 !important;
  color: #ffffff !important;
}

/* 6Ô∏è‚É£ Platzhalter / disabled */
html.dark .muted,
html.dark .disabled{
  color: #9fb6b2 !important;
}


/* ‚úÖ Dark Mode Fix #5 ‚Äì "FRAGE" Label (Pseudo-Element & echtes Label) */
html.dark .lf-front::before,
html.dark .lf-frontLabel{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  border-color: rgba(255,255,255,.22) !important;
  text-shadow: none !important;
  font-weight: 900 !important;
}

html.dark .lf-front::before{
  box-shadow: 0 10px 30px rgba(0,0,0,.35) !important;
}

/* Falls irgendwo die Label-Farbe nochmal √ºberschrieben wird */
html.dark .lf-frontLabel *{
  color: #0b1f1a !important;
}


/* ‚úÖ Sicher gelernt IMMER sichtbar */
#cardSafeBtn{
  display:flex !important;
  opacity:1 !important;
  pointer-events:auto !important;
}

</style>
<style>
.quiz-votes{display:flex;gap:8px;align-items:center;margin-top:8px}
.quiz-vote-btn{cursor:pointer;padding:6px 10px;border-radius:10px;border:1px solid #ddd;background:#fff}
.quiz-vote-btn.up.active{background:#e6ffef;border-color:#4caf50}
.quiz-vote-btn.down.active{background:#ffecec;border-color:#f44336}
.quiz-hidden{display:none!important}

/* üîß Dark Mode Button Fix (vB10.1) */
html.dark button,
html.dark .btn{
  color: #e8f1ef !important;
}

html.dark .btn.primary{
  color: #eafff6 !important;
}

html.dark .btn.danger{
  color: #ffecec !important;
}

html.dark button:disabled,
html.dark .btn:disabled{
  color: rgba(232,241,239,.45) !important;
}


/* üîß Dark Mode Readability Fix 2 (vB10.2) */
html.dark .lf-overview{
  background: rgba(255,255,255,.06) !important;
  border-color: rgba(255,255,255,.12) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 10px 24px rgba(0,0,0,.35) !important;
}
html.dark .lf-overview small{
  color: rgba(232,241,239,.78) !important;
  opacity: 1 !important;
}
html.dark .lf-overview .pill{
  background: rgba(232,241,239,.10) !important;
  border-color: rgba(232,241,239,.18) !important;
  color: rgba(232,241,239,.92) !important;
}

/* Filter-Chips im Dark Mode */
html.dark .chip{
  background: rgba(255,255,255,.08) !important;
  border-color: rgba(255,255,255,.18) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 6px 16px rgba(0,0,0,.25) !important;
}
html.dark .chip:active{ transform: translateY(1px); }


/* üîß Dark Mode Fix #3 ‚Äì Frage-Button Lesbarkeit */
html.dark .question-label,
html.dark .frage,
html.dark .question,
html.dark .card-front .label,
html.dark .frage-button{
  color: #0b1f1a !important;
  background: #eafff6 !important;
  font-weight: 700 !important;
  text-shadow: none !important;
}

html.dark .card-front{
  background: linear-gradient(180deg, #1e2b2a, #121b1a) !important;
}


/* üî• Dark Mode Kontrast-Overhaul (Final Analyse Fix) */

/* 1Ô∏è‚É£ Alle Texte pauschal heller */
html.dark body,
html.dark p,
html.dark span,
html.dark div,
html.dark h1,
html.dark h2,
html.dark h3,
html.dark h4,
html.dark h5,
html.dark h6,
html.dark label{
  color: #eaf4f2 !important;
}

/* 2Ô∏è‚É£ Frage / Antwort Badge */
html.dark .frage,
html.dark .antwort,
html.dark .question-label{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  font-weight: 800 !important;
  letter-spacing: 1px;
}

/* 3Ô∏è‚É£ Statistik (Gesamt / Offen / Sicher) */
html.dark .stat,
html.dark .stat span,
html.dark .stat-value{
  color: #ffffff !important;
  font-weight: 700;
}

/* 4Ô∏è‚É£ Chips & Filter */
html.dark .chip{
  background: #223332 !important;
  color: #ffffff !important;
  border: 1px solid #3d5c5a !important;
}

/* 5Ô∏è‚É£ Karteninhalt */
html.dark .card,
html.dark .card-front,
html.dark .card-back{
  background: #162221 !important;
  color: #ffffff !important;
}

/* 6Ô∏è‚É£ Platzhalter / disabled */
html.dark .muted,
html.dark .disabled{
  color: #9fb6b2 !important;
}


/* ‚úÖ Dark Mode Fix #5 ‚Äì "FRAGE" Label (Pseudo-Element & echtes Label) */
html.dark .lf-front::before,
html.dark .lf-frontLabel{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  border-color: rgba(255,255,255,.22) !important;
  text-shadow: none !important;
  font-weight: 900 !important;
}

html.dark .lf-front::before{
  box-shadow: 0 10px 30px rgba(0,0,0,.35) !important;
}

/* Falls irgendwo die Label-Farbe nochmal √ºberschrieben wird */
html.dark .lf-frontLabel *{
  color: #0b1f1a !important;
}


/* ‚úÖ Sicher gelernt IMMER sichtbar */
#cardSafeBtn{
  display:flex !important;
  opacity:1 !important;
  pointer-events:auto !important;
}

</style>
<style id="ltDashCss">
.ltDash{margin-top:10px;display:flex;flex-direction:column;gap:12px}
.ltDash .sec{background:#fff;border:1px solid rgba(0,0,0,.06);border-radius:18px;padding:14px;box-shadow:0 2px 10px rgba(0,0,0,.05)}
.ltDash .sec h3{margin:0 0 10px 0;font-size:16px}
.ltDash .grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:12px}
@media (max-width:560px){ .ltDash .grid{grid-template-columns:1fr;} }
.ltDash .mini{display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;gap:6px}
.ltDash .label{font-weight:800}
.ltDash .small{font-size:12px;color:#666}
.ltDash .ring{width:112px;height:112px;border-radius:50%;display:flex;align-items:center;justify-content:center;
  background:conic-gradient(#49b7a5 0deg,var(--deg), #e9edf3 var(--deg));
  font-weight:900
}
.ltDash .bar{height:14px;border-radius:999px;background:#eef0f6;overflow:hidden}
.ltDash .bar > i{display:block;height:100%;width:var(--w);border-radius:999px;background:linear-gradient(90deg,#7fdcc6,#49b7a5)}
.ltDash .row2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
.ltDash .big{font-size:28px;font-weight:950}
.ltDash .streak{font-size:22px}
.ltDash .tachoWrap{display:flex;flex-direction:column;align-items:center;gap:6px}
.ltDash .tacho{width:190px;height:95px;border-radius:190px 190px 0 0;
  background:conic-gradient(from 180deg,#c62828 0deg,#f2c94c 90deg,#2e7d32 180deg);
  position:relative;overflow:hidden}
.ltDash .tacho:after{content:"";position:absolute;left:12px;right:12px;bottom:0;height:82px;background:#fff;border-radius:190px 190px 0 0}
.ltDash .needle{position:absolute;width:3px;height:82px;background:#111;bottom:0;left:50%;transform-origin:bottom;transform:rotate(var(--a))}
.ltDash .pill{display:inline-flex;gap:8px;align-items:center;justify-content:center;padding:8px 10px;border-radius:999px;background:#f3f4f6;font-weight:800}
.ltDash .muted{color:#555;font-size:12px}

/* üîß Dark Mode Button Fix (vB10.1) */
html.dark button,
html.dark .btn{
  color: #e8f1ef !important;
}

html.dark .btn.primary{
  color: #eafff6 !important;
}

html.dark .btn.danger{
  color: #ffecec !important;
}

html.dark button:disabled,
html.dark .btn:disabled{
  color: rgba(232,241,239,.45) !important;
}


/* üîß Dark Mode Readability Fix 2 (vB10.2) */
html.dark .lf-overview{
  background: rgba(255,255,255,.06) !important;
  border-color: rgba(255,255,255,.12) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 10px 24px rgba(0,0,0,.35) !important;
}
html.dark .lf-overview small{
  color: rgba(232,241,239,.78) !important;
  opacity: 1 !important;
}
html.dark .lf-overview .pill{
  background: rgba(232,241,239,.10) !important;
  border-color: rgba(232,241,239,.18) !important;
  color: rgba(232,241,239,.92) !important;
}

/* Filter-Chips im Dark Mode */
html.dark .chip{
  background: rgba(255,255,255,.08) !important;
  border-color: rgba(255,255,255,.18) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 6px 16px rgba(0,0,0,.25) !important;
}
html.dark .chip:active{ transform: translateY(1px); }


/* üîß Dark Mode Fix #3 ‚Äì Frage-Button Lesbarkeit */
html.dark .question-label,
html.dark .frage,
html.dark .question,
html.dark .card-front .label,
html.dark .frage-button{
  color: #0b1f1a !important;
  background: #eafff6 !important;
  font-weight: 700 !important;
  text-shadow: none !important;
}

html.dark .card-front{
  background: linear-gradient(180deg, #1e2b2a, #121b1a) !important;
}


/* üî• Dark Mode Kontrast-Overhaul (Final Analyse Fix) */

/* 1Ô∏è‚É£ Alle Texte pauschal heller */
html.dark body,
html.dark p,
html.dark span,
html.dark div,
html.dark h1,
html.dark h2,
html.dark h3,
html.dark h4,
html.dark h5,
html.dark h6,
html.dark label{
  color: #eaf4f2 !important;
}

/* 2Ô∏è‚É£ Frage / Antwort Badge */
html.dark .frage,
html.dark .antwort,
html.dark .question-label{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  font-weight: 800 !important;
  letter-spacing: 1px;
}

/* 3Ô∏è‚É£ Statistik (Gesamt / Offen / Sicher) */
html.dark .stat,
html.dark .stat span,
html.dark .stat-value{
  color: #ffffff !important;
  font-weight: 700;
}

/* 4Ô∏è‚É£ Chips & Filter */
html.dark .chip{
  background: #223332 !important;
  color: #ffffff !important;
  border: 1px solid #3d5c5a !important;
}

/* 5Ô∏è‚É£ Karteninhalt */
html.dark .card,
html.dark .card-front,
html.dark .card-back{
  background: #162221 !important;
  color: #ffffff !important;
}

/* 6Ô∏è‚É£ Platzhalter / disabled */
html.dark .muted,
html.dark .disabled{
  color: #9fb6b2 !important;
}


/* ‚úÖ Dark Mode Fix #5 ‚Äì "FRAGE" Label (Pseudo-Element & echtes Label) */
html.dark .lf-front::before,
html.dark .lf-frontLabel{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  border-color: rgba(255,255,255,.22) !important;
  text-shadow: none !important;
  font-weight: 900 !important;
}

html.dark .lf-front::before{
  box-shadow: 0 10px 30px rgba(0,0,0,.35) !important;
}

/* Falls irgendwo die Label-Farbe nochmal √ºberschrieben wird */
html.dark .lf-frontLabel *{
  color: #0b1f1a !important;
}


/* ‚úÖ Sicher gelernt IMMER sichtbar */
#cardSafeBtn{
  display:flex !important;
  opacity:1 !important;
  pointer-events:auto !important;
}

</style>
</head>
<body>
<button id="themeToggle" class="themeToggleBtn" type="button" aria-label="Dark Mode umschalten" title="Dark Mode">üåô</button>
<!-- Screen 1: Name -->
<section class="screen active" id="sName">
<div class="wrap">
<div class="card modeCard">
<h1>üåø Lerntool</h1>
<p>Bitte gib deinen Namen ein.</p>
<input autocomplete="name" class="input" id="nameInput" placeholder="Dein Name"/>
<div class="row" style="margin-top:12px">
<button class="btn" id="nameNextBtn" onclick="goFromName()" type="button">Weiter</button>
</div>
<div class="notice" id="nameNotice"></div>
</div>
</div>
</section>
<!-- Screen 2: Klausuren -->
<section class="screen" id="sExam">
<div class="wrap">
<div class="topbar">
<button aria-label="Zur√ºck" class="btn ghost" onclick="show('sName')" title="Zur√ºck" type="button">‚Üê Zur√ºck</button>
<div style="text-align:right">
<div style="font-weight:950">Klausuren</div>
<div class="small">Nutzer: <b id="hdrName1">‚Äì</b></div>
</div>
</div>
<div class="hr"></div>
<!-- ‚òÅÔ∏è Cloud Sync (Firebase) -->
<div class="ltModal" id="cloudModal" style="display:none">
  <div aria-labelledby="cloudTitle" aria-modal="true" class="ltModalBox" role="dialog">
    <div class="row" style="justify-content:space-between;align-items:center;gap:10px">
      <div id="cloudTitle" style="font-weight:950">‚òÅÔ∏è Cloud Sync (Firebase)</div>
      <button aria-label="Schlie√üen" class="btn secondary" onclick="closeCloudModal()" type="button">‚úï</button>
    </div>
    <div class="hr" style="margin:12px 0"></div>

    <div class="small" style="margin-bottom:10px">
      Hinweis: Du willst ‚Äûnur Name‚Äú. Das geht ‚Äì aber jeder k√∂nnte theoretisch denselben Namen eingeben. 
      F√ºr Sicherheit kann man sp√§ter jederzeit auf Login/PIN umstellen.
    </div>

    <div class="row" style="gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:10px">
      <label style="display:flex; align-items:center; gap:8px">
        <input id="cloudEnableToggle" type="checkbox" onchange="cloudToggleChanged()"/>
        <span>Cloud aktivieren</span>
      </label>
      <span class="pill" id="cloudInlineStatus" style="display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.22); background:rgba(255,255,255,.08); font-size:12px;">
        <span id="cloudInlineDot" style="width:8px;height:8px;border-radius:50%;background:#999;display:inline-block"></span>
        <span id="cloudInlineText">nicht verbunden</span>
      </span>
    </div>

    <div class="small" style="margin:10px 0 6px">Firebase Config (aus Firebase Console ‚Üí Project settings ‚Üí Your apps). JSON hier einf√ºgen:</div>
    <textarea class="input" id="cloudConfigInput" rows="6" style="width:100%; resize:vertical" placeholder='{"apiKey":"...","authDomain":"...","projectId":"...","appId":"..."}'></textarea>

    <div class="row" style="gap:10px; align-items:center; flex-wrap:wrap; margin-top:10px">
      <label style="display:flex; align-items:center; gap:8px">
        <input id="cloudAutoSyncToggle" type="checkbox"/>
        <span>Auto‚ÄëSync bei √Ñnderungen</span>
      </label>
    </div>

    <div class="row" style="justify-content:flex-end;gap:10px;margin-top:12px;flex-wrap:wrap">
      <button class="btn secondary" onclick="cloudDownloadNow()" type="button">‚¨áÔ∏è Cloud ‚Üí Ger√§t</button>
      <button class="btn secondary" onclick="cloudUploadNow()" type="button">‚¨ÜÔ∏è Ger√§t ‚Üí Cloud</button>
      <button class="btn" onclick="cloudSaveSettings()" type="button">Speichern</button>
    </div>

    <div class="small" style="margin-top:10px; opacity:.9">
      Tipp: Wenn du sp√§ter echte Sicherheit willst, stellen wir auf ‚Äûanonymes Login + Anzeigename‚Äú oder E‚ÄëMail um ‚Äì ohne Datenverlust.
    </div>
  </div>
</div>
<div class="hr"></div>

<div class="card modeCard">
<div class="row" style="justify-content:space-between">
<div>
<div style="font-weight:950">Klausur ausw√§hlen</div>
<div class="small">Import/Export findet nur hier statt.</div>
</div>
<div class="row" style="gap:10px; align-items:center">
<button class="btn secondary" id="adminBtn" onclick="openAdminGate()" type="button">Admin</button>
</div>
<div class="admin-only" id="adminControls">
<div class="row" style="justify-content:flex-end; gap:10px; flex-wrap:wrap">
<span style="display:inline-flex; gap:8px; align-items:center; margin-left:10px; flex-wrap:wrap">
<input id="resetPinInput" placeholder="PIN" style="width:110px; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.22); background: rgba(255,255,255,.10); color: inherit; outline:none;" type="password"/>
<button class="btn" onclick="resetExamCardsWithPin\(\)" style="background:#c62828; color:#fff" type="button">Alle Karten l√∂schen</button>
<span style="width:14px; display:inline-block"></span>
<input id="deleteExamPinInput" placeholder="PIN Klausur" style="width:130px; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.22); background: rgba(255,255,255,.10); color: inherit; outline:none;" type="password"/>
<button class="btn secondary" onclick="deleteExamWithPin()" style="border-color:#c62828; color:#c62828" type="button">Klausur entfernen</button>
<span style="width:14px; display:inline-block"></span>
<input id="resetHsPinInput" placeholder="PIN" style="width:92px; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.25); background: rgba(255,255,255,.10); color: inherit; outline:none;" type="password"/>
<button class="btn secondary" onclick="resetHighscoreWithPin()" style="border-color:#ffb300; color:#ffecb3" type="button">üèÜ Highscore reset</button>
</span>
<button class="btn secondary" onclick="exportCards()" type="button">Karten exportieren</button>
<button class="btn secondary" onclick="exportQuiz()" type="button">Quiz exportieren</button>
<button class="btn secondary" onclick="lt_exportFullBackup()" type="button">üíæ Backup (alles)</button>
<button class="btn secondary" onclick="document.getElementById('importFileFullBackup').click()" type="button">‚ôªÔ∏è Backup import</button>
<button class="btn secondary" onclick="lt_restoreAutoBackup()" type="button">‚è™ Auto‚ÄëBackup</button>
<button class="btn secondary" onclick="openCloudModal()" type="button">‚òÅÔ∏è Cloud Sync</button>
<span class="pill" id="cloudStatusPill" style="margin-left:6px; display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.22); background:rgba(255,255,255,.08); font-size:12px;">
  <span id="cloudDot" style="width:8px;height:8px;border-radius:50%;background:#999;display:inline-block"></span>
  <span id="cloudStatusText">Cloud: aus</span>
</span>

<input accept="application/json" id="importFileFullBackup" onchange="lt_handleFullBackupImport(event)" style="display:none" type="file"/>

<button class="btn" onclick="openAddExamModal()" type="button">‚ûï Neue Klausur</button>
<button class="btn secondary" onclick="toggleHiddenShared()" type="button">üõ°Ô∏è Ausgeblendete Inhalte</button>
<button class="btn secondary" onclick="triggerImport('cards-append')" type="button">Karten hinzuf√ºgen</button>
<button class="btn secondary" onclick="triggerImport('quiz-append')" type="button">Quiz hinzuf√ºgen</button>
<button class="btn secondary" onclick="triggerImport('cards-replace')" type="button">Karten austauschen</button>
<button class="btn secondary" onclick="triggerImport('quiz-replace')" type="button">Quiz austauschen</button>
<input accept="application/json" id="importFileCardsAppend" onchange="handleImport(event,'cards-append')" style="display:none" type="file"/>
<input accept="application/json" id="importFileQuizAppend" onchange="handleImport(event,'quiz-append')" style="display:none" type="file"/>
<input accept="application/json" id="importFileCardsReplace" onchange="handleImport(event,'cards-replace')" style="display:none" type="file"/>
<input accept="application/json" id="importFileQuizReplace" onchange="handleImport(event,'quiz-replace')" style="display:none" type="file"/>
<div class="notice" id="hiddenSharedPanel" style="display:none; margin-top:12px">
<div style="font-weight:900; margin-bottom:8px">üõ°Ô∏è Ausgeblendete Inhalte (5√ó üëé)</div>
<div class="small" style="margin-bottom:10px">Diese Karten/Quizfragen sind automatisch ausgeblendet worden. Hier kannst du sie als Admin wiederherstellen.</div>
<div id="hiddenSharedList"></div>
</div>
</div>
</div>
</div>
<div class="hr"></div>
<div class="grid" id="examList"></div>
<!-- Klausur hinzuf√ºgen Modal -->
<div class="ltModal" id="addExamModal" style="display:none">
<div aria-labelledby="addExamTitle" aria-modal="true" class="ltModalBox" role="dialog">
<div class="row" style="justify-content:space-between;align-items:center;gap:10px">
<div id="addExamTitle" style="font-weight:950">Neue Klausur</div>
<button aria-label="Schlie√üen" class="btn secondary" onclick="closeAddExamModal()" type="button">‚úï</button>
</div>
<div class="hr" style="margin:12px 0"></div>
<div class="small" style="margin-bottom:10px">Klausur wird lokal gespeichert (Offline). Danach kannst du Karten/Quiz importieren.</div>
<input class="input" id="addExamTitleInput" placeholder="Klausurname / Fach (z.B. Affektive St√∂rungen)" type="text"/>
<input class="input" id="addExamDateInput" placeholder="Datum (optional, z.B. 05.03.2026)" type="text"/>
<div class="row" style="justify-content:flex-end;gap:10px;margin-top:12px;flex-wrap:wrap">
<button class="btn secondary" onclick="closeAddExamModal()" type="button">Abbrechen</button>
<button class="btn" onclick="addExamManual()" type="button">Speichern</button>
</div>
</div>
</div>
<div class="hr"></div>
<div class="row">
<button class="btn" id="examNextBtn" onclick="goToMode()" type="button">Weiter</button>
</div>
<div class="notice" id="examNotice"></div>
</div>
</div>
</section>
<!-- Screen 3: Modus -->
<section class="screen" id="sMode">
<div class="wrap">
<div class="topbar">
<button aria-label="Zur√ºck" class="btn ghost" onclick="show('sExam')" title="Zur√ºck" type="button">‚Üê Zur√ºck</button>
<div style="text-align:right">
<div style="font-weight:950">Modi




</div>
<div class="small modeHdrLine">Klausur: <b id="hdrExam2">‚Äì</b> ‚Ä¢ Nutzer: <b id="hdrName2">‚Äì</b> ‚Ä¢         </div>
<div class="modeLvlRow">
<div class="modeProgressWrap">
<div class="progressCard" title="Level-Fortschritt (jede richtige Antwort = 1 XP, 50 XP = Level)">
<div class="progressContent">
<div class="progressKicker">‚≠ê Fortschritt</div>
<div class="progressLine">
<div class="progressLevelBlock">
<span class="progressLevelLabel">LEVEL</span>
<span class="progressLevelNum" id="hdrLvlM">1</span>
</div>
<div class="progressXpText"><span id="hdrXpM">0/50</span> XP</div>
</div>
<div class="progressBar">
<div class="progressFill" id="hdrXpFillM" style="width:0%"></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="hr"></div>
<div class="grid">
<div class="tile tileCreate" onclick="openMode(2)">
<div class="tIcon">‚úçÔ∏è</div>
<div class="tTop">
<div class="t1">Karteikarten erstellen</div>
<div class="tBadge">Admin</div>
</div>
<div class="tSub">Neue Karten &amp; Quiz erstellen</div>
</div>
<div class="tile" onclick="openMode(1)">
<div class="ico">üìö</div>
<div class="tTop"><div class="t1">Karteikarten</div><div class="modeCount" id="countCards">0 Karten</div></div>
<div class="t2">Lernen mit Richtig/Falsch + Favorit ‚≠ê</div>
</div>
<div class="tile" onclick="openMode(2)">
<div class="ico">‚úçÔ∏è</div>
<div class="tTop"><div class="t1">Karteikarten erstellen</div><div class="modeCount" id="m2Count">0</div></div>
<div class="t2">Neue Karteikarten/Quiz erstellen ‚Ä¢ Import/Export nur im Admin</div>
</div>
<div class="tile" onclick="openMode(3)">
<div class="ico">üß†</div>
<div class="tTop"><div class="t1">Quiz</div><div class="modeCount" id="countQuiz">0 Fragen</div></div>
<div class="t2">1 Frage ‚Ä¢ 4 Antworten</div>
</div>
<div class="tile" onclick="comingSoon(4)">
<div class="ico">üõ†Ô∏è</div>
<div class="t1">Tools</div>
<div class="t2">kommt sp√§ter</div>
</div>
<div class="tile" onclick="openMode(5)">
<div class="ico">üë•</div>
<div class="tTop"><div class="t1">Klasse teilen</div><div class="modeCount" id="countShare">0 geteilt</div></div>
<div class="t2">Markierte Karten sammeln</div>
</div>
<div class="tile" onclick="openMode(6)">
<div class="ico">‚≠ê</div>
<div class="t1"><div class="tTop"><div class="t1">Favoriten</div><div class="modeCount" id="countFav">0 ‚≠ê</div></div></div>
<div class="t2">Alle markierten Karten (klausur√ºbergreifend)</div>
</div>
</div>
<div class="startToggles" id="startToggles">
<div class="startToggleGrid">
<div class="startCol">
<button class="btnLite" onclick="toggleStartPanel('masteryBox')" type="button">üìä Lernstand anzeigen</button>
<button class="btnLite" onclick="openMode(2)" type="button">‚úçÔ∏è Karteikarten erstellen</button>
</div>
<div class="startCol">
<button class="btnLite" onclick="toggleStartPanel('highscorePanel')" type="button">üèÜ Highscore anzeigen</button>
<button class="btnLite" onclick="openCreateQuiz()" type="button">üß† Quizkarten erstellen</button>
</div>
</div>
</div>
<div id="modeNotice"></div>
</div>
<div class="modeExtras">
<div id="masteryBox" style="margin-top:14px;padding:14px;border-radius:14px;background:#ffffff;box-shadow:0 2px 8px rgba(0,0,0,0.08)">
<div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap">
<div style="font-weight:900">üìä Lernstand (Diagramme)</div>
<div id="masteryText" style="font-size:13px;color:#555">‚Äî</div>
</div>
<div style="margin-top:10px;height:14px;border-radius:999px;background:#eef0f6;overflow:hidden">
<div id="masteryBar" style="height:100%;width:0%;border-radius:999px;background:linear-gradient(90deg,#7fdcc6,#49b7a5)"></div>
</div>
<div id="masterySub" style="margin-top:6px;font-size:12px;color:#666">Mastery geht nicht zur√ºck beim Reset ‚Äì z√§hlt ‚Äûmind. 1√ó sicher‚Äú pro Karte/Frage.</div>
<div class="ltDash" id="ltDash">
<div class="sec">
<h3>üß† Lernfortschritt (Klausur)</h3>
<div class="grid">
<div class="mini">
<div class="ring" id="ringCards" style="--deg:0deg">0%</div>
<div class="label">Karteikarten</div>
<div class="small" id="txtCards">‚Äî</div>
</div>
<div class="mini">
<div class="ring" id="ringQuiz" style="--deg:0deg">0%</div>
<div class="label">Quiz</div>
<div class="small" id="txtQuiz">‚Äî</div>
</div>
</div>
</div>
<div class="sec">
<h3>üéØ Lernqualit√§t</h3>
<div class="row2">
<div>
<div class="label">√ò richtige Antworten</div>
<div class="bar" style="margin-top:8px"><i id="barCorrect" style="--w:0%"></i></div>
<div class="small" id="txtCorrect">‚Äî</div>
</div>
<div>
<div class="label">√ò Versuche pro Inhalt</div>
<div class="pill" id="txtAttempts" style="margin-top:8px">‚Äî</div>
<div class="muted">Aus Seen/Antworten berechnet (Quiz + Karten).</div>
</div>
</div>
</div>
<div class="sec">
<h3>‚è±Ô∏è Aktivit√§t</h3>
<div class="row2">
<div>
<div class="label">Lernzeit gesamt</div>
<div class="pill" id="txtLearnTime" style="margin-top:8px">‚Äî</div>
<div class="muted">Hinweis: Zeit-Tracking wird ab jetzt mitgeloggt (ohne Einfluss auf Funktionen).</div>
</div>
<div>
<div class="label">Zuletzt gelernt</div>
<div class="pill" id="txtLast" style="margin-top:8px">‚Äî</div>
</div>
</div>
</div>
<div class="sec">
<h3>üî• Lernrhythmus</h3>
<div style="display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap">
<div class="streak" id="txtStreak">üî• 0 Tage</div>
<div class="muted">Streak basiert auf Lerntagen (letzte Aktivit√§t pro Tag).</div>
</div>
</div>
<div class="sec">
<h3 style=" font-size: 200%">üéÆ Level &amp; XP</h3>
<div style="display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap">
<div>
<div class="big" id="txtLevel">Level 1</div>
<div class="small" id="txtXP" style=" font-size: 200%">0 / 50 XP</div>
<div class="bar" style="margin-top:8px"><i id="barXP" style="--w:0%"></i></div>
</div>
<div class="muted" style=" font-size: 200%">XP = Aktivit√§t/Erfolgspunkte (wie bisher). Keine Muster, keine √Ñnderung am Lernen.</div>
</div>
</div>
<div class="sec">
<h3>üèÅ Pr√ºfungs-Readiness</h3>
<div class="tachoWrap">
<div class="tacho">
<div class="needle" id="needleReady" style="--a:0deg"></div>
</div>
<div class="big" id="txtReady">0% bereit</div>
<div class="small">Basierend auf den letzten 50 beantworteten Inhalten</div>
</div>
</div>
</div>
</div>
<script>
(function(){
  function renderMastery(){
    try{
      const { mastered, total, totalCards, totalQuiz } = lt_getMasteryCounts();
      const pct = total>0 ? Math.round((mastered/total)*100) : 0;
      const t = document.getElementById("masteryText");
      const b = document.getElementById("masteryBar");
      if(t) t.textContent = `${mastered}/${total} gemeistert (${pct}%) ¬∑ Karten ${totalCards} ¬∑ Quiz ${totalQuiz}`;
      if(b) b.style.width = pct + "%";
    }catch(_e){}
  }
  renderMastery();
  setInterval(renderMastery, 1200);
})();

// === Phase 1: examKey & Sync-Vorbereitung ===
function normalizeExamKey(title, dateStr){
  if(!title || !dateStr) return "";
  const map = { "√§":"ae","√∂":"oe","√º":"ue","√ü":"ss" };
  let t = title.toLowerCase();
  t = t.replace(/[√§√∂√º√ü]/g, m => map[m]);
  t = t.replace(/[^a-z0-9]+/g, "_");
  t = t.replace(/_+/g, "_").replace(/^_|_$/g, "");
  return t + "__" + dateStr;
}


function getVoteUser(){
  try{
    const u = (typeof getUserName === "function") ? (getUserName()||"") : "";
    return u || "anon";
  }catch(_e){ return "anon"; }
}

function getItemById(type, id, db){
  if(!db) db = loadDB();
  if(type==="card") return (db.cards||[]).find(x=>x.id===id) || null;
  return (db.quiz||[]).find(x=>x.id===id) || null;
}

function renderVoteBar(type, id){
  const bar = document.getElementById(type==="card" ? "voteBarCards" : "voteBarQuiz");
  if(!bar) return;

  // nur wenn aus Klasse-teilen-Lernen
  if(!(state && state.fromShare)){ bar.style.display="none"; return; }

  const db = loadDB();
  const obj = getItemById(type, id, db);
  if(!obj || !obj.sharedClass || obj.sharedHidden){ bar.style.display="none"; return; }

  // init counters
  if(typeof obj.likesCount !== "number") obj.likesCount = obj.likesCount||0;
  if(typeof obj.dislikesCount !== "number") obj.dislikesCount = obj.dislikesCount||0;
  if(!obj.votes) obj.votes = {};

  const user = getVoteUser();
  const vote = Number(obj.votes[user] || 0);

  bar.style.display="flex";
  bar.innerHTML = "";

  const up = document.createElement("button");
  up.className = "votePill " + (vote===1 ? "ok" : "ghost");
  up.type = "button";
  up.textContent = "üëç " + (obj.likesCount||0);
  up.onclick = ()=>{
    voteShared(type, id, 1);
    const db2 = loadDB();
    const obj2 = getItemById(type, id, db2);
    if(obj2 && obj2.sharedHidden){
      // wurde ausgeblendet -> direkt weiter
      if(type==="card") nextCard();
      else nextQuiz();
    }else{
      renderVoteBar(type, id);
    }
  };

  const down = document.createElement("button");
  down.className = "votePill " + (vote===-1 ? "danger" : "ghost");
  down.type = "button";
  down.textContent = "üëé " + (obj.dislikesCount||0);
  down.onclick = ()=>{
    voteShared(type, id, -1);
    const db2 = loadDB();
    const obj2 = getItemById(type, id, db2);
    if(obj2 && obj2.sharedHidden){
      if(type==="card") nextCard();
      else nextQuiz();
    }else{
      renderVoteBar(type, id);
    }
  };

  bar.appendChild(up);
  bar.appendChild(down);
}

// Hook: Nach jeder Karte/Quiz neu zeichnen
function updateVoteBars(){
  try{
    if(!(state && state.fromShare)) return;
    try{
      const c = (typeof currentCard==='function') ? currentCard() : null;
    if(c && c.id) renderVoteBar("card", c.id);
    }catch(_e){}
    try{
      const q = currentQuiz();
      if(q && q.id) renderVoteBar("quiz", q.id);
    }catch(_e){}
  }catch(_e){}
}


// üîß Feinfix: Quiz-Frage UNTER "W√§hle 1 Antwort." platzieren
function _placeQuizQuestionUnderInstruction(){
  try{
    const q = document.getElementById('quizQ');
    if(!q) return;

    // Suche exakt den Hinweistext
    const instruction = Array.from(document.querySelectorAll('#quiz *'))
      .find(el => (el.textContent||'').trim() === 'W√§hle 1 Antwort.');

    if(!instruction || !instruction.parentElement) return;

    const parent = instruction.parentElement;
    if(q.parentElement === parent && q.previousElementSibling === instruction) return;

    parent.insertBefore(q, instruction.nextSibling);
  }catch(e){}
}

// bestehende Platzierung √ºberschreiben
(function(){
  const target = document.getElementById('quiz') || document.querySelector('#quiz');
  if(!target) return;
  const obs = new MutationObserver(()=>{
    _placeQuizQuestionUnderInstruction();
  });
  obs.observe(target, {childList:true, subtree:true});
  setTimeout(_placeQuizQuestionUnderInstruction, 50);
  setTimeout(_placeQuizQuestionUnderInstruction, 250);
})();


// ‚úÖ Sicher gelernt immer klickbar (auch beim Anzeigen der Frage)
(function(){
  function enableSecureBtn(){
    const btn = document.querySelector('#btnSecure, .btnSecure, button[data-secure]');
    if(btn){
      btn.disabled = false;
      btn.classList.remove('disabled');
    }
  }
  setInterval(enableSecureBtn, 300);
})();


// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<!-- === HIGHSCORE PANEL (IM MODUS ‚Äì SYNC MIT APP) === -->
<div id="highscorePanel" style="margin-top:14px;padding:16px;border-radius:12px;background:#ffffff;box-shadow:0 2px 8px rgba(0,0,0,0.1)">
<h2 style="margin:0 0 10px 0">üèÜ Highscore</h2>
<div style="display:flex;flex-wrap:wrap;gap:12px">
<div style="flex:1;min-width:220px;padding:12px;border-radius:10px;background:#f7f8fc">
<div style="font-weight:700;margin-bottom:6px; font-size: 200%">Gesamt (XP)</div>
<div id="hsTotal" style="font-size:18px">Level 1 ¬∑ 0 XP</div>
<div style="font-size:12px;color:#666;margin-top:4px">synchronisiert mit deinem Level-System</div>
</div>
<div style="flex:1;min-width:220px;padding:12px;border-radius:10px;background:#f7f8fc">
<div style="font-weight:700;margin-bottom:6px">Gesamt (Sicher)</div>
<div id="hsSecureTotal" style="font-size:16px">‚úÖ 0 sicher</div>
<div style="font-size:12px;color:#666;margin-top:4px">nur diese Klausur</div>
</div>
<div style="flex:1;min-width:220px;padding:12px;border-radius:10px;background:#f7f8fc">
<div style="font-weight:700;margin-bottom:6px">Heute (Sicher)</div>
<div id="hsDaily" style="font-size:16px">üî• 0 sichere Antworten</div>
<div id="hsDailyMeta" style="font-size:12px;color:#666;margin-top:4px"></div>
</div>
<div style="flex:1;min-width:220px;padding:12px;border-radius:10px;background:#f7f8fc">
<div style="font-weight:700;margin-bottom:6px">Streak</div>
<div id="hsStreak" style="font-size:16px">üìÖ 0 Tage</div>
<div style="font-size:12px;color:#666;margin-top:4px">Lerntage hintereinander</div>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(auto-fit, minmax(220px, 1fr));gap:12px;margin-top:14px">
<div style="padding:12px;border-radius:10px;border:1px solid #e7e8f0">
<div style="font-weight:700;margin-bottom:6px; font-size: 200%">Top 10 ‚Äì XP</div>
<ol id="hsTop10XP" style="margin:6px 0 0 18px;padding:0"></ol>
</div>
<div style="padding:12px;border-radius:10px;border:1px solid #e7e8f0">
<div style="font-weight:700;margin-bottom:6px">Top 10 ‚Äì Sicher beantwortet</div>
<ol id="hsTop10Secure" style="margin:6px 0 0 18px;padding:0"></ol>
</div>
<div style="padding:12px;border-radius:10px;border:1px solid #e7e8f0">
<div style="font-weight:700;margin-bottom:6px">Top 10 ‚Äì Streak</div>
<ol id="hsTop10Streak" style="margin:6px 0 0 18px;padding:0"></ol>
</div>
</div>
<div id="hsStatus" style="font-size:12px;color:#666;margin-top:8px">Offline-Modus</div>
</div>
<script style=" font-size: 200%">
(function(){
  function safeJSON(key, fallback){
    try{ const v = localStorage.getItem(key); return v ? JSON.parse(v) : (fallback||null); }catch(_e){ return fallback||null; }
  }
  function getExamId(){
    try{ if(window.state && window.state.activeExamId) return window.state.activeExamId; }catch(_e){}
    return localStorage.getItem("currentExamId") || "default";
  }

  function restoreActiveExam(){
    try{
      const db = loadDB();
      const saved = localStorage.getItem("currentExamId");
      if(saved && db && Array.isArray(db.exams) && db.exams.some(e=>e.id===saved)){
        state.activeExamId = saved;
        return;
      }
      if(!state.activeExamId && db && Array.isArray(db.exams) && db.exams[0] && db.exams[0].id){
        state.activeExamId = db.exams[0].id;
        try{ localStorage.setItem("currentExamId", state.activeExamId); }catch(_e){}
      }
    }catch(_e){}
  }
  function getUserName(){
    try{
      if(typeof window.loadProfile === "function"){
        const p = window.loadProfile();
        if(p && (p.name || p.userName || p.username)) return (p.name || p.userName || p.username);
      }
    }catch(_e){}
    try{ if(window.state && (state.userName || state.username)) return (state.userName || state.username); }catch(_e){}
    try{
      const txt = document.body.innerText || "";
      const m = txt.match(/Nutzer:\s*([^\n‚Ä¢]+)/i);
      if(m && m[1]) return m[1].trim();
    }catch(_e){}
    return localStorage.getItem("lt_lastUserName") || "Gast";
  }
  function getXPLevel(){
    let totalPoints = 0, lvl = 1;
    try{
      if(typeof window.loadProfile === "function"){
        const p = window.loadProfile();
        totalPoints = (p && typeof p.totalPoints === "number") ? p.totalPoints : Number((p && p.totalPoints) || 0);
        if(typeof window.calcLevel === "function"){
          lvl = window.calcLevel(totalPoints, p && p.maxLevel);
        }else{
          const step = (typeof window.LEVEL_STEP === "number") ? window.LEVEL_STEP : 50;
          lvl = Math.max(1, Math.floor(totalPoints/step)+1);
        }
      }else{
        const step = (typeof window.LEVEL_STEP === "number") ? window.LEVEL_STEP : 50;
        totalPoints = Number(localStorage.getItem("points") || 0);
        lvl = Number(localStorage.getItem("level") || (Math.floor(totalPoints/step)+1));
      }
    }catch(_e){
      const step = 50;
      totalPoints = Number(localStorage.getItem("points") || 0);
      lvl = Number(localStorage.getItem("level") || (Math.floor(totalPoints/step)+1));
    }
    return { totalPoints, lvl };
  }
  function getSafeTotalsForExam(examId){
    try{
      if(typeof window.computeCounts === "function"){
        const c = window.computeCounts();
        const totalSafe = Number(c.cardsSafe||0) + Number(c.quizSafe||0);
        return { totalSafe: totalSafe, cardsSafe:Number(c.cardsSafe||0), quizSafe:Number(c.quizSafe||0) };
      }
    }catch(_e){}
    return { totalSafe: Number(localStorage.getItem("dailySecure")||0), cardsSafe:0, quizSafe:0 };
  }

  const today = new Date().toISOString().slice(0,10);
  const last = localStorage.getItem("dailyScoreDate");
  if(last !== today){
    localStorage.setItem("dailyScoreDate", today);
    localStorage.setItem("dailySecure", "0");
  }

  function keyXP(examId){ return "top10_xp_" + examId; }
  function keySecure(examId){ return "top10_secure_" + examId; }
  function keyStreak(examId){ return "top10_streak_" + examId; }

  function upsertTop10(key, user, value){
    const list = safeJSON(key, []) || [];
    const v = Number(value||0);
    const canonical = String(user||"").trim() || "Gast";
    const aliases = new Set([canonical, "Ich", "Gast"]);
    // Merge any alias entries into canonical (max)
    let best = v;
    for(let i=list.length-1;i>=0;i--){
      const nm = String(list[i].user||list[i].name||"").trim();
      if(aliases.has(nm)){
        const cur = Number(list[i].value ?? list[i].xp ?? list[i].secure ?? list[i].score ?? 0);
        if(cur > best) best = cur;
        list.splice(i,1);
      }
    }
    list.push({ user: canonical, value: best, updatedAt: Date.now() });
    list.sort((a,b)=> (Number(b.value||0) - Number(a.value||0)) || (Number(b.updatedAt||0)-Number(a.updatedAt||0)));
    const top = list.slice(0,10);
    localStorage.setItem(key, JSON.stringify(top));
    return top;
  }

  function render(listEl, items, suffix){
    if(!listEl) return;
    listEl.innerHTML = "";
    if(!items || !items.length){
      const li = document.createElement("li");
      li.textContent = "Noch keine Eintr√§ge";
      listEl.appendChild(li);
      return;
    }
    items.slice(0,10).forEach((it, i) => {
      const li = document.createElement("li");
      const name = it.user || it.name || ("Spieler " + (i+1));
      const val = Number(it.value ?? it.score ?? it.xp ?? it.secure ?? 0);
      li.textContent = name + " ‚Äì " + val + " " + suffix;
      listEl.appendChild(li);
    });
  }

  const hsTotalEl = document.getElementById("hsTotal");
  const hsSecureTotalEl = document.getElementById("hsSecureTotal");
  const hsDailyEl = document.getElementById("hsDaily");
  const hsDailyMetaEl = document.getElementById("hsDailyMeta");
  const hsStreakEl = document.getElementById("hsStreak");
  const hsStatusEl = document.getElementById("hsStatus");
  const hsTopXP = document.getElementById("hsTop10XP");
  const hsTopSecure = document.getElementById("hsTop10Secure");
  const hsTopStreak = document.getElementById("hsTop10Streak");

  function refresh(){
    const examId = getExamId();
    let user = getUserName();
    // Canonicalize username (verhindert Doppel-Eintr√§ge wie "Ich")
    user = String(user||"").trim() || "Gast";
    localStorage.setItem("lt_lastUserName", user);

    const xpInfo = getXPLevel();
    const daily = Number(localStorage.getItem("dailySecure") || 0);
    const safeTotals = getSafeTotalsForExam(examId);

    // Streak (Lerntage hintereinander)
    let streak = 0;
    try{
      const days = safeJSON(KEY_DAYS(), []);
      streak = streakFromDays(days);
    }catch(_e){}

    if(hsTotalEl) hsTotalEl.textContent = "Level " + xpInfo.lvl + " ¬∑ " + xpInfo.totalPoints + " XP";
    if(hsSecureTotalEl) hsSecureTotalEl.textContent = "‚úÖ " + (safeTotals.totalSafe||0) + " sicher";
    if(hsDailyEl) hsDailyEl.textContent = "üî• " + daily + " sichere Antworten";
    if(hsDailyMetaEl) hsDailyMetaEl.textContent = "Klausur: " + examId + " ¬∑ " + today;
    if(hsStreakEl) hsStreakEl.textContent = "üìÖ " + streak + " Tage";

    const topXP = upsertTop10(keyXP(examId), user, xpInfo.totalPoints);
    const topSec = upsertTop10(keySecure(examId), user, safeTotals.totalSafe);
    const topStreak = upsertTop10(keyStreak(examId), user, streak);

    render(hsTopXP, topXP, "XP");
    render(hsTopSecure, topSec, "sicher");
    render(hsTopStreak, topStreak, "Tage");

    if(hsStatusEl) hsStatusEl.textContent = "Offline-Liste (lokal) ‚Äì automatisch aktualisiert";

    try{
      localStorage.setItem("top10_xp", JSON.stringify(topXP));
      localStorage.setItem("top10_secure", JSON.stringify(topSec));
      localStorage.setItem("top10_streak", JSON.stringify(topStreak));
    }catch(_e){}
  }

  refresh();
  setInterval(refresh, 1200);

  const API = localStorage.getItem("highscoreApiBase") || "";
  async function loadOnline(){
    if(!API) return;
    const examId = getExamId();
    try{
      if(hsStatusEl) hsStatusEl.textContent = "Lade Online-Listen";
      const base = API.replace(/\/$/,"");
      const r1 = await fetch(base + "/highscores/xp?examId=" + encodeURIComponent(examId) + "&limit=10");
      const r2 = await fetch(base + "/highscores/secure?examId=" + encodeURIComponent(examId) + "&limit=10");
      if(r1.ok){
        const d1 = await r1.json();
        const items1 = Array.isArray(d1)?d1:(d1.items||[]);
        localStorage.setItem(keyXP(examId), JSON.stringify(items1.map(o=>({user:o.user||o.name, value:o.xp||o.score||o.value||0}))));
      }
      if(r2.ok){
        const d2 = await r2.json();
        const items2 = Array.isArray(d2)?d2:(d2.items||[]);
        localStorage.setItem(keySecure(examId), JSON.stringify(items2.map(o=>({user:o.user||o.name, value:o.secure||o.score||o.value||0}))));
      }
      refresh();
      if(hsStatusEl) hsStatusEl.textContent = "Online-Top10 geladen (cached)";
    }catch(_e){
      if(hsStatusEl) hsStatusEl.textContent = "Offline-Modus (Online nicht erreichbar)";
    }
  }
  loadOnline();
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<!-- === /HIGHSCORE PANEL === -->
</div>
</section>
<!-- Screen 4: Karteikarten (Modus 1) -->
<section class="screen" id="sCards">
<div class="wrap">
<div class="topbar">
<button aria-label="Zur√ºck zur Modus√ºbersicht" class="btn ghost" onclick="lt_backToModes()" title="Zur√ºck zur Modus√ºbersicht" type="button">‚Üê Zur√ºck</button>
<div style="text-align:right">
<div style="font-weight:950">üß† Karteikarten</div>
<div class="small">Klausur: <b id="hdrExam3">‚Äì</b> ‚Ä¢ Nutzer: <b id="hdrName3">‚Äì</b> ‚Ä¢ </div>
</div>
</div>
<div class="stage">
<div class="voteBar" id="voteBarCards"></div>
<div class="flash" id="flash1">
<div class="lf-meta">
<div class="lf-overview" id="cardsOverview">Lade √úbersicht</div>
<div class="lf-source" id="cardSource"></div>
</div>
<div aria-label="Filter Karteikarten" class="filterWrap">
<div class="filterBar">
<div style="font-size:12px;color:var(--muted);font-weight:800">Filter</div>
<button class="btn ghost filterBtn" id="cardsFilterBtn" onclick="toggleFilterRow('cards')" type="button">Filter</button>
</div>
<div class="chipRow" id="cardsFilterRow" style="display:none">
<div class="chipSearchWrap">
  <input id="cardsFilterRow_search" class="chipSearch" type="search" placeholder="Suchen‚Ä¶" value="" 
    oninput="setSearch('cards', this.value)" />
</div>

<button class="chip" data-filter="open" data-kind="cards" onclick="setFilter('cards','open')" type="button">Offen</button>
<button class="chip" data-filter="all" data-kind="cards" onclick="setFilter('cards','all')" type="button">Alle</button>
<button class="chip" data-filter="hard" data-kind="cards" onclick="setFilter('cards','hard')" type="button">üî• Am meisten falsch</button>
<button class="chip" data-filter="safe" data-kind="cards" onclick="setFilter('cards','safe')" type="button">Sicher</button>
<button class="chip" data-filter="fav" data-kind="cards" onclick="setFilter('cards','fav')" type="button">‚≠ê Favoriten</button>
</div>
</div>
<div aria-label="Lernkarte" class="lf-card3d" role="group">
<div class="lf-cardInner">
<div class="lf-face lf-front">
<div class="q" id="q1">‚Äì</div>
<div class="lf-hint">Tippe auf die Karte, um sie umzudrehen.</div>
</div>
<div class="lf-face lf-back">
<div class="lf-backLabel">Antwort</div>
<div class="a" id="a1">‚Äì</div>
</div>
</div>
</div>
<div class="row" style="margin-top:18px">
<button class="btn secondary w100 lf-show" onclick="toggleAnswer('flash1')" type="button">Antwort zeigen</button>
</div>
<div class="row" style="margin-top:12px">
<button class="btn danger w100 lf-wrong" onclick="rateCurrent(false); autoNext('card')" type="button">‚ùå Wei√ü ich noch nicht</button>
<button class="btn w100 lf-right" onclick="rateCurrent(true); autoNext('card')" type="button">‚úÖ Wei√ü ich</button>
</div>
<div class="row" style="margin-top:12px">
<button class="btn ghost w100 lf-mini" id="favBtn1" onclick="toggleFavCurrent()" type="button">‚≠ê Merken</button>
<button class="btn ghost w100 lf-mini" id="shareBtn1" onclick="toggleShareCurrent()" type="button">üë• Teilen</button>
<button class="btn w100 lf-safe" id="cardSafeBtn" onclick="markCardSafe()" type="button">üü¢ Sicher gelernt</button>
<button class="btn ghost w100 lf-next" disabled="" onclick="nextCard()" type="button">N√§chste</button>
</div>
</div>
</div>
<div class="notice" id="cardsNotice"></div>
</div>
</section>
<!-- Screen 5: Favoriten (Modus 6) -->
<section class="screen" id="sFav">
<div class="wrap">
<div class="topbar">
<button aria-label="Zur√ºck zur Modus√ºbersicht" class="btn ghost" onclick="lt_backToModes()" title="Zur√ºck zur Modus√ºbersicht" type="button">‚Üê Zur√ºck</button>
<div style="text-align:right">
<div style="font-weight:950">‚≠ê Favoriten</div>
<div class="small">Alle Klausuren ‚Ä¢ Nutzer: <b id="hdrName4">‚Äì</b></div>
</div>
</div>
<div class="stage">
<div class="flash" id="flash6">
<div class="q" id="q6">Keine Favoriten gefunden.</div>
<div class="a" id="a6">Tipp: Markiere Karten in Modus 1 mit ‚òÜ/‚≠ê.</div>
<div class="row" style="margin-top:18px">
<button class="btn secondary w100 lf-show" onclick="toggleAnswer('flash6')" type="button">Antwort zeigen</button>
</div>
<div class="row" style="margin-top:12px">
<button class="btn danger w100 lf-wrong" onclick="rateFav(false); autoNext('fav')" type="button">‚ùå Wei√ü ich noch nicht</button>
<button class="btn w100 lf-right" onclick="rateFav(true); autoNext('fav')" type="button">‚úÖ Wei√ü ich</button>
</div>
<div class="row" style="margin-top:12px">
<button class="btn ghost w100" id="favBtn6" onclick="toggleFavInFav()" type="button">‚≠ê Favorit</button>
<button class="btn ghost w100 lf-next" disabled="" onclick="nextFav()" type="button">N√§chste</button>
</div>
</div>
</div>
<div class="notice" id="favNotice"></div>
</div>
</section>
<!-- Screen 7: Quiz (Modus 3) -->
<section class="screen" id="sQuiz">
<div class="wrap">
<div class="topbar">
<button aria-label="Zur√ºck zur Modus√ºbersicht" class="btn ghost" onclick="lt_backToModes()" title="Zur√ºck zur Modus√ºbersicht" type="button">‚Üê Zur√ºck</button>
<div style="text-align:right">
<div style="font-weight:950">üß© Quiz</div>
<div class="small">Klausur: <b id="hdrExamQ">‚Äì</b> ‚Ä¢ Nutzer: <b id="hdrNameQ">‚Äì</b> ‚Ä¢ </div>
</div>
</div>
<div class="stage">
<div class="flash" id="quizBox">
<div class="voteBar" id="voteBarQuizLocal" style="margin-bottom:10px"></div>
<div class="q" id="quizQ">‚Äì</div>
<div class="lf-source" id="quizSource"></div>
<div class="lf-overview" id="quizOverview">Lade √úbersicht</div>
<div aria-label="Filter Quiz" class="filterWrap">
<div class="filterBar">
<div style="font-size:12px;color:var(--muted);font-weight:800">Filter</div>
<button class="btn ghost filterBtn" id="quizFilterBtn" onclick="toggleFilterRow('quiz')" type="button">Filter</button>
</div>
<div class="chipRow" id="quizFilterRow" style="display:none">
<div class="chipSearchWrap">
  <input id="quizFilterRow_search" class="chipSearch" type="search" placeholder="Suchen‚Ä¶" value="" 
    oninput="setSearch('quiz', this.value)" />
</div>

<button class="chip" data-filter="open" data-kind="quiz" onclick="setFilter('quiz','open')" type="button">Offen</button>
<button class="chip" data-filter="all" data-kind="quiz" onclick="setFilter('quiz','all')" type="button">Alle</button>
<button class="chip" data-filter="hard" data-kind="quiz" onclick="setFilter('quiz','hard')" type="button">üî• Am meisten falsch</button>
<button class="chip" data-filter="safe" data-kind="quiz" onclick="setFilter('quiz','safe')" type="button">Sicher</button>
<button class="chip" data-filter="fav" data-kind="quiz" onclick="setFilter('quiz','fav')" type="button">‚≠ê Favoriten</button>
</div>
</div>
<div class="small" style="margin-top:10px">W√§hle 1 Antwort.</div>
<div class="row" style="margin-top:14px; gap:10px">
<button class="btn secondary w100" id="ans0" onclick="pickAnswer(0)" type="button">A</button>
<button class="btn secondary w100" id="ans1" onclick="pickAnswer(1)" type="button">B</button>
</div>
<div class="row" style="margin-top:10px; gap:10px">
<button class="btn secondary w100" id="ans2" onclick="pickAnswer(2)" type="button">C</button>
<button class="btn secondary w100" id="ans3" onclick="pickAnswer(3)" type="button">D</button>
</div>
<div class="quiz-status neutral" id="quizStatusBar" style="margin-top:10px;">Antwort ausw√§hlen</div>
<div class="row" style="margin-top:12px; gap:12px">
<button class="btn danger w100 lf-qbtn isDisabled" id="quizWrongBtn" onclick="quizMarkWrong()" type="button">‚ùå Wei√ü ich noch nicht</button>
<button class="btn w100 lf-qbtn isDisabled" id="quizRightBtn" onclick="quizMarkRight()" type="button">‚úÖ Wei√ü ich</button>
</div>
<div class="row" style="margin-top:12px; gap:12px">
<button class="btn ghost w100 lf-qbtn isDisabled" id="quizUnsureBtn2" onclick="quizMarkWrong()" type="button">üü° N√§chste Karte</button>
<button class="btn w100 lf-qbtn lf-safe2 isDisabled" id="quizSafeBtn2" onclick="quizMarkSafe()" type="button">üü¢ Sicher gelernt</button>
</div>
<div class="row" style="margin-top:10px">
<button class="btn ghost w100" id="shareBtnQ" onclick="toggleShareQuizCurrent()" type="button">üë• An Klasse teilen</button>
</div>
</div>
</div>
<div class="notice" id="quizNotice"></div>
</div>
</section>
<!-- Screen 6: An Klasse teilen (Modus 5) -->
<section class="screen" id="sShare">
<div class="wrap">
<div class="topbar">
<button aria-label="Zur√ºck zur Modus√ºbersicht" class="btn ghost" onclick="lt_backToModes()" title="Zur√ºck zur Modus√ºbersicht" type="button">‚Üê Zur√ºck</button>
<div style="text-align:right">
<div style="font-weight:950">üë• An Klasse teilen</div>
<div class="small">Klausur: <b id="hdrExam5">‚Äì</b> ‚Ä¢ Nutzer: <b id="hdrName5">‚Äì</b></div>
</div>
</div>
<div class="hr"></div>
<div class="card modeCard">
<div style="font-weight:950">Geteilte Karten (lokal markiert)</div>
<div class="small">Jetzt: nur auf deinem Ger√§t sichtbar. Sp√§ter k√∂nnen wir das online f√ºr alle sichtbar machen.</div>
<div class="hr"></div>
<div class="row" style="gap:10px; flex-wrap:wrap; margin:10px 0 8px 0">
<button class="btn" id="shareHubBtnCards" onclick="shareShow('cards')" type="button">üìö Karteikarten lernen</button>
<button class="btn" id="shareHubBtnQuiz" onclick="shareShow('quiz')" type="button">üìù Quiz lernen</button>
<button class="btn ghost" id="shareHubBtnView" onclick="shareShow('view')" type="button">üëÄ Ansehen</button>
</div>
<div class="notice" id="sharePanelCards" style="display:none">
<div style="font-weight:900; margin-bottom:6px">üìö Geteilte Karteikarten lernen</div>
<div class="small" style="margin-bottom:10px">Du √ºbst hier nur Karten, die (lokal) als ‚Äûgeteilt‚Äú markiert sind. Sp√§ter sind das die Karten von Mitsch√ºlern.</div>
<button class="btn ok" onclick="startSharedCards()" type="button">Start</button>
</div>
<div class="notice" id="sharePanelQuiz" style="display:none">
<div style="font-weight:900; margin-bottom:6px">üìù Geteilte Quizfragen lernen</div>
<div class="small" style="margin-bottom:10px">Du √ºbst hier nur Quizfragen, die (lokal) als ‚Äûgeteilt‚Äú markiert sind. Sp√§ter sind das die Fragen von Mitsch√ºlern.</div>
<button class="btn ok" onclick="startSharedQuiz()" type="button">Start</button>
</div>
<div id="sharePanelView" style="display:block">
<div id="shareList"></div>
<div class="notice" id="shareNotice"></div>
</div>
</div>
</div>
</section>
<script style=" font-size: 200%">
/* ====== Stabiler Kern (ohne fragile addEventListener-Patches) ====== */
const DB_KEY = "lerntool_db_v1";
const NAME_KEY = "lerntool_name_v1";

// ===== Update- & Karten-Safety (vB11) =====
// Ziel: Updates d√ºrfen NIE Daten l√∂schen. Daher: Legacy-Migration + Auto-Backup + Restore.
const LT_SCHEMA_VERSION = 1;
const LT_MIGRATION_MARK = "lt_migrated_to_db_v1";
const LT_AUTO_BACKUP_KEY = "lt_autobackup_v1";

// Falls fr√ºhere Versionen andere Keys genutzt haben: hier sammeln.
// (Wenn DB_KEY schon existiert, passiert nichts.)
const LT_LEGACY_DB_KEYS = [
  "lerntool_db",
  "lerntool_db_v0",
  "lt_db_v1",
  "lt_db",
  "lern_db",
  "flash_db",
  "db"
];

function lt_tryMigrateLegacyDB(){
  try{
    if(localStorage.getItem(DB_KEY)) return; // alles gut
    if(localStorage.getItem(LT_MIGRATION_MARK)==="done") return;

    for(const k of LT_LEGACY_DB_KEYS){
      try{
        const raw = localStorage.getItem(k);
        if(!raw) continue;
        // Quick-Check: muss JSON sein und exams/cards enthalten
        const obj = JSON.parse(raw);
        if(obj && Array.isArray(obj.exams) && Array.isArray(obj.cards)){
          localStorage.setItem(DB_KEY, raw);
          localStorage.setItem(LT_MIGRATION_MARK, "done");
          try{ console.log("[LT] Migrated legacy DB key:", k, "->", DB_KEY); }catch(_e){}
          return;
        }
      }catch(_e){}
    }

    // Keine Legacy gefunden ‚Üí trotzdem markieren, damit wir nicht dauernd suchen
    localStorage.setItem(LT_MIGRATION_MARK, "done");
  }catch(_e){}
}

// Auto-Backup: immer vor riskanten Aktionen (Reset/L√∂schen) sichern
function lt_makeAutoBackup(reason){
  try{
    const payload = lt_collectBackupPayload();
    payload.meta = payload.meta || {};
    payload.meta.reason = String(reason||"");
    payload.meta.createdAt = Date.now();
    localStorage.setItem(LT_AUTO_BACKUP_KEY, JSON.stringify(payload));
  }catch(_e){}
}

function lt_restoreAutoBackup(){
  try{
    const raw = localStorage.getItem(LT_AUTO_BACKUP_KEY);
    if(!raw){
      try{ toast("examNotice","Kein Auto-Backup gefunden."); }catch(_e){ alert("Kein Auto-Backup gefunden."); }
      return;
    }
    const obj = JSON.parse(raw);
    if(!confirm("Letztes Auto-Backup wiederherstellen?\n\n‚ö†Ô∏è √úberschreibt die Lerntool-Daten (deine Klausuren/Karten/Quiz/Stats).")){
      return;
    }
    lt_applyBackupPayload(obj, /*replace*/ true);
    try{ toast("examNotice","Auto-Backup wiederhergestellt."); }catch(_e){}
    location.reload();
  }catch(_e){
    try{ toast("examNotice","Auto-Backup konnte nicht geladen werden."); }catch(_e2){ alert("Auto-Backup konnte nicht geladen werden."); }
  }
}

// Backup-Payload: DB + relevante localStorage Keys (klausurbezogen)
function lt_isManagedKey(k){
  if(!k) return false;
  const prefixes = [
    "lerntool_",
    "lt_",
    "top10_",
    "highscoreResetAt_",
    "dailyScore",
    "dailySecure",
    "currentExamId",
    "lern_user_name",
    "NAME",
    "lt_mastered_"
  ];
  return prefixes.some(p=>k.startsWith(p));
}

function lt_collectBackupPayload(){
  const out = { type:"lerntool-backup", version: LT_SCHEMA_VERSION, keys:{}, meta:{} };
  try{
    for(let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      if(!lt_isManagedKey(k)) continue;
      out.keys[k] = localStorage.getItem(k);
    }
  }catch(_e){}
  // DB explizit aufnehmen (falls Filter mal ge√§ndert wird)
  try{ out.keys[DB_KEY] = localStorage.getItem(DB_KEY); }catch(_e){}
  return out;
}

function lt_applyBackupPayload(payload, replace){
  if(!payload || typeof payload!=="object") throw new Error("bad payload");
  const keys = payload.keys || {};
  // optional: alte managed keys entfernen (damit keine Leichen bleiben)
  if(replace){
    try{
      const del = [];
      for(let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        if(lt_isManagedKey(k) || k===DB_KEY) del.push(k);
      }
      del.forEach(k=>{ try{ localStorage.removeItem(k); }catch(_e){} });
    }catch(_e){}
  }
  Object.keys(keys).forEach(k=>{
    try{
      const v = keys[k];
      if(v===null || typeof v==="undefined") return;
      localStorage.setItem(k, String(v));
    }catch(_e){}
  });
}

function lt_exportFullBackup(){
  try{
    const payload = lt_collectBackupPayload();
    payload.meta = {
      exportedAt: Date.now(),
      app: "Lerntool",
      note: "Full backup (DB + Settings + Progress)"
    };
    const d = new Date();
    const stamp = d.toISOString().slice(0,10);
    downloadJson(payload, "lerntool_backup_" + stamp + ".json");
    toast("examNotice","Backup exportiert.");
  }catch(_e){
    try{ toast("examNotice","Backup Export fehlgeschlagen."); }catch(_e2){ alert("Backup Export fehlgeschlagen."); }
  }
}

function lt_handleFullBackupImport(ev){
  const file = ev.target.files && ev.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    let obj=null;
    try{ obj = JSON.parse(String(reader.result||"")); }catch(_e){
      toast("examNotice","Backup-Import: kein g√ºltiges JSON.");
      ev.target.value = "";
      return;
    }
    if(!obj || (obj.type!=="lerntool-backup")){
      toast("examNotice","Backup-Import: falscher Dateityp.");
      ev.target.value = "";
      return;
    }
    try{
      if(!confirm("Backup importieren?\n\n‚ö†Ô∏è √úberschreibt die Lerntool-Daten (Klausuren/Karten/Quiz/Stats).")){ ev.target.value=""; return; }
      lt_applyBackupPayload(obj, /*replace*/ true);
      toast("examNotice","Backup importiert.");
      setTimeout(()=>location.reload(), 350);
    }catch(_e){
      toast("examNotice","Backup-Import fehlgeschlagen.");
    }
    ev.target.value = "";
  };
  reader.readAsText(file);
}

// Migration direkt beim Start durchf√ºhren
lt_tryMigrateLegacyDB();

const state = {
  name: "",
  activeExamId: "",
  mode: 0,
  session: { ids: [], i: 0 },
  fav: { ids: [], i: 0 },
  quiz: { ids: [], i: 0, locked: false }
};

// expose state globally for injected helpers / future online features
try{ window.state = state; }catch(_e){}




function lf_setNextEnabled(screenId, enabled){
  try{
    const screen = document.getElementById(screenId);
    if(!screen) return;
    const btn = screen.querySelector(".lf-next");
    if(btn){
      btn.disabled = !enabled;
    }
  }catch(_e){}
}

function show(id){
  document.querySelectorAll(".screen").forEach(s=>s.classList.remove("active"));
  const el = document.getElementById(id);
  if(el) el.classList.add("active");
  // Hook: beim √ñffnen des Quiz immer neu aufbauen + rendern (fix: Buttons bleiben sonst A/B/C/D)
  if(id==="sQuiz"){
    try{ buildQuiz(); }catch(_e){}
    try{ renderQuiz(); }catch(_e){}
  }
  try{ updateVoteBars(); }catch(_e){}
}


function toast(id, msg){
  const el = document.getElementById(id);
  if(!el) return;
  el.textContent = msg;
  el.classList.add("show");
  clearTimeout(el._t);
  el._t = setTimeout(()=>el.classList.remove("show"), 2200);
}

/* ====== DB ====== */
function defaultDB(){
  const psychId = "psy_2026_01_01";
  return {
    exams: [
      { id: psychId, title: "Psychiatrie", date: "01.01.2026" }
    ],
    cards: [
      { id:"c1", examId: psychId, front:"Was ist eine affektive St√∂rung?", back:"St√∂rung, bei der die Stimmung krankhaft ver√§ndert ist, z.B. Depression oder Manie.", fav:false, sharedClass:false, stats:{} },
      { id:"c2", examId: psychId, front:"Nenne 2 Kernsymptome einer Depression.", back:"Gedr√ºckte Stimmung, Interessen-/Freudverlust; zus√§tzlich z.B. Antriebsmangel, Schlafst√∂rung.", fav:false, sharedClass:false, stats:{} },
      { id:"c3", examId: psychId, front:"Was bedeutet F32.2?", back:"Schwere depressive Episode ohne psychotische Symptome (ICD-10).", fav:false, sharedClass:false, stats:{} }
    ],
    // Quiz-Fragen (Modus 3). Sp√§ter automatisch aus Karteikarten generierbar.
    quiz: [
      {
        id: "q1",
        examId: psychId,
        question: "Was bedeutet F32.2?",
        answers: [
          "Leichte depressive Episode",
          "Schwere depressive Episode ohne psychotische Symptome",
          "Bipolare St√∂rung",
          "Schizophrenie"
        ],
        correctIndex: 1,
        sharedClass: false,
        sharedAt: null
      }
    ]
  };
}

function loadDB(){
  try{
    const raw = localStorage.getItem(DB_KEY);
    if(!raw) return defaultDB();
    const db = JSON.parse(raw);
    if(!db || !Array.isArray(db.exams) || !Array.isArray(db.cards)) return defaultDB();
    if(!Array.isArray(db.quiz)) db.quiz = [];
    db.quiz.forEach(q=>{ if(typeof q.sharedClass!=='boolean') q.sharedClass=false; if(!('sharedAt' in q)) q.sharedAt=null; });
    return db;
  }catch(_e){
    return defaultDB();
  }
}

function saveDB(db){
  try{ localStorage.setItem(DB_KEY, JSON.stringify(db)); }catch(_e){}
}

function getExamTitle(id){
  const db = loadDB();
  const e = db.exams.find(x=>x.id===id);
  return e ? (e.title + " " + (e.date||"")) : "‚Äì";
}

/* ====== Flow ====== */
function goFromName(){
  const inp = document.getElementById("nameInput");
  const name = (inp?.value||"").trim();
  if(!name){ toast("nameNotice","Bitte Namen eingeben."); return; }
  state.name = name;
  try{ localStorage.setItem(NAME_KEY, name); }catch(_e){}
  document.getElementById("hdrName1").textContent = name;
  renderExams();
  show("sExam");
}

function renderExams(){
  const db = loadDB();
  const list = document.getElementById("examList");
  list.innerHTML = "";
  db.exams.forEach(ex=>{
    const div = document.createElement("div");
    div.className = "tile examTile";
    const d = (ex.date||"").trim();
    div.innerHTML = '<div class="examRow"><div class="examTitle">' + escapeHtml(ex.title) + '</div><div class="examDate">' + escapeHtml(d) + '</div></div>';
    if(!d){ try{ div.querySelector(".examDate").style.display="none"; }catch(_e){} }
    div.onclick = ()=>{ selectExam(ex.id); };
    list.appendChild(div);
  });
  // auto-select first if none
  if(!state.activeExamId && db.exams[0]) { state.activeExamId = db.exams[0].id; try{ localStorage.setItem("currentExamId", state.activeExamId); }catch(_e){} }
  highlightSelectedExam();
}

// ===== Klausur manuell hinzuf√ºgen =====
function openAddExamModal(){
  const m = document.getElementById("addExamModal");
  if(!m) return;
  m.style.display = "flex";
  // Prefill: wenn eine Klausur ausgew√§hlt ist, nutze deren Titel als Hinweis
  try{
    const t = document.getElementById("addExamTitleInput");
    if(t) setTimeout(()=>t.focus(), 50);
  }catch(_e){}
}
function closeAddExamModal(){
  const m = document.getElementById("addExamModal");
  if(!m) return;
  m.style.display = "none";
  try{
    document.getElementById("addExamTitleInput").value = "";
    document.getElementById("addExamDateInput").value = "";
  }catch(_e){}
}

// v53fix: Modal UX (ESC / Klick au√üerhalb)
(function(){
  const m = document.getElementById("addExamModal");
  if(m){
    m.addEventListener("click", (e)=>{ if(e.target===m) closeAddExamModal(); });
  }
  window.addEventListener("keydown", (e)=>{ if(e.key==="Escape") closeAddExamModal(); });
})();

function addExamManual(){
  const title = (document.getElementById("addExamTitleInput")?.value || "").trim();
  const date  = (document.getElementById("addExamDateInput")?.value || "").trim();
  if(!title){
    try{ toast("examNotice","Bitte Klausurname eingeben."); }catch(_e){ alert("Bitte Klausurname eingeben."); }
    return;
  }
  const db = loadDB();
  const id = "ex_" + Date.now();
  // Wichtig: wir setzen title/date (vom System genutzt) UND name (f√ºr einzelne Delete-Funktion)
  db.exams.push({ id, title, date, name: title });
  saveDB(db);
  renderExams();
  selectExam(id);
  closeAddExamModal();
  try{ toast("examNotice","Klausur hinzugef√ºgt: " + title); }catch(_e){}
}

// Modal schlie√üen per Klick auf Hintergrund
document.addEventListener("click", (e)=>{
  const m = document.getElementById("addExamModal");
  if(!m || m.style.display==="none") return;
  if(e.target === m) closeAddExamModal();
});
document.addEventListener("keydown", (e)=>{
  if(e.key === "Escape"){
    const m = document.getElementById("addExamModal");
    if(m && m.style.display !== "none") closeAddExamModal();
  }
});


function selectExam(id){
  // Guard: Kein Klausurwechsel, solange 'Eigene Karten' ge√∂ffnet ist
  try{
    if(state && state.examSwitchLocked){
      toast("examNotice","Klausurwechsel ist gesperrt, solange du im Modus ‚ÄöEigene Karten‚Äò bist. Bitte erst zur√ºck.");
      return;
    }
  }catch(_e){}
  state.activeExamId = id;
  try{ localStorage.setItem("currentExamId", id); }catch(_e){}
  highlightSelectedExam();
  toast("examNotice","Ausgew√§hlt: " + getExamTitle(id));
}

function highlightSelectedExam(){
  const list = document.getElementById("examList");
  [...list.children].forEach((el, idx)=>{
    const db = loadDB();
    const ex = db.exams[idx];
    const on = ex && ex.id === state.activeExamId;
    el.style.borderColor = on ? "rgba(107,191,174,.55)" : "rgba(0,0,0,.06)";
    el.style.boxShadow = on ? "0 12px 34px rgba(107,191,174,.18)" : "var(--shadow)";
  });
}

function goToMode(){
  // v39: self-heal activeExamId if missing (e.g. after back/refresh quirks)
  if(!state.activeExamId){
    try{
      const db = loadDB();
      if(db && Array.isArray(db.exams) && db.exams[0] && db.exams[0].id) state.activeExamId = db.exams[0].id;
    }catch(_e){}
  }
  if(!state.activeExamId){ toast("examNotice","Bitte eine Klausur ausw√§hlen."); return; }
  const hn = document.getElementById("hdrName2");
  const he = document.getElementById("hdrExam2");
  if(hn) hn.textContent = state.name || "‚Äì";
  if(he) he.textContent = getExamTitle(state.activeExamId);
  show("sMode");
}

function comingSoon(n){
  toast("modeNotice","Modus " + n + " kommt sp√§ter üôÇ");
}



function showSection(id){
  try{
    // Lock: Klausurwechsel ist gesperrt, solange der Screen 'Eigene Karten' (sCreate) offen ist
    try{ state.examSwitchLocked = (id==='sCreate'); }catch(_e){}
    document.querySelectorAll('.screen').forEach(s=>s.style.display='none');
    const el = document.getElementById(id);
    if(el) el.style.display = 'block';
    window.scrollTo(0,0);
    try{ updateModeCounts(); }catch(_e){}
    if(id==='sCards'){
      try{ restoreActiveExam(); }catch(_e){}
      try{
        const hn=document.getElementById('hdrName3');
        const he=document.getElementById('hdrExam3');
        if(hn) hn.textContent = (state.name || getUserName()) || '‚Äì';
        if(he) he.textContent = getExamTitle(state.activeExamId);
      }catch(_e){}
      try{ buildSession(); }catch(_e){}
      try{ showCurrent(); }catch(_e){}
    }
    // Hook: Quiz-Ansicht immer initialisieren (fix: sonst bleiben Buttons A/B/C/D)
    if(id==='sQuiz'){
      try{ buildQuiz(); }catch(_e){}
      try{ renderQuiz(); }catch(_e){}
    }
  }catch(_e){}
}


function openMode(n){
  // robust: never leave user on blank screen
  if(typeof showSection !== "function"){
    window.location.reload();
    return;
  }
  if(n===1){
    try{ startCards(); return; }catch(_e){}
    showSection('sCards');
  } else if(n===2){
    showSection('sCreate');
    try{ if(typeof m2_setTab==='function') m2_setTab('cards'); }catch(_e){}
    try{ renderOwnCards(); }catch(_e){}
  } else if(n===3){
    showSection('sQuiz');
    try{ buildQuiz(); }catch(_e){}
    try{ renderQuiz(); }catch(_e){}
  } else if(n===5){
    try{ startShare(); return; }catch(_e){}
    showSection('sShare');
  } else if(n===6){
    try{ startFav(); return; }catch(_e){}
    showSection('sFav');
  } else {
    comingSoon(n);
  }
}



/* ====== Mode 1 Cards ====== */
function startCards(){
  try{ restoreActiveExam(); }catch(_e){}
  document.getElementById("hdrName3").textContent = (state.name || getUserName()) || "‚Äì";
  document.getElementById("hdrExam3").textContent = getExamTitle(state.activeExamId);
  
  updateLevelUI();
  if(!(state && state.fromShare)) buildSession();
  show("sCards");
  showCurrent();
}

function buildSession(){
  const db = loadDB();
  const f = state.cardsFilter || "open";
  const q = (state.cardsSearch||"").trim().toLowerCase();

  let items = (db.cards||[])
    .filter(c=>c.examId===state.activeExamId);

  // Suche
  if(q){
    items = items.filter(c=>{
      const a = (c.front||"").toLowerCase();
      const b = (c.back||"").toLowerCase();
      const s = (c.source ? JSON.stringify(c.source) : "").toLowerCase();
      return a.includes(q) || b.includes(q) || s.includes(q);
    });
  }

  // Filter
  if(f==="open") items = items.filter(c=>!c.isSafe);
  else if(f==="safe") items = items.filter(c=>!!c.isSafe);
  else if(f==="fav") items = items.filter(c=>!!c.fav);
  else if(f==="hard"){
    items = items
      .filter(c=>(c.stats && c.stats.wrong) ? (c.stats.wrong>0) : false)
      .sort((a,b)=>((b.stats&&b.stats.wrong)||0) - ((a.stats&&a.stats.wrong)||0));
  }

  const ids = items.map(c=>c.id);

  state.session.ids = ids;
  state.session.i = 0;
}


// üîß Safety: currentCard Helper (verhindert ReferenceError)
function currentCard(){
  try{
    if(state && state.session && Array.isArray(state.session.ids)){
      const id = state.session.ids[state.session.i];
      if(!id) return null;
      const db = loadDB();
      return (db.cards||[]).find(c=>c.id===id) || null;
    }
  }catch(_e){}
  return null;
}

function showCurrent(){
  try{ updateOverviews(); }catch(_e){}
  const card = currentCard();
  const flash = document.getElementById("flash1");
  flash.classList.remove("revealed");
  if(!card){
    const f = state.cardsFilter || "open";
    document.getElementById("q1").textContent = (f==="open" ? "Keine offenen Karten f√ºr diesen Filter." : "Keine Karten f√ºr diesen Filter.");
    document.getElementById("a1").textContent = (f==="fav" ? "Tipp: Markiere Karten in Modus 1 mit ‚òÜ/‚≠ê." : "Tipp: √Ñndere den Filter oder importiere/erstelle Karten.");
    document.getElementById("favBtn1").textContent = "‚òÜ Favorit";
    return;
  }
  document.getElementById("q1").textContent = card.front || "‚Äî";
  document.getElementById("a1").textContent = card.back || "";
  try{
  const cs = document.getElementById("cardSource");
  if(cs){
    const txt = formatSource(card.source);
    cs.textContent = txt;
    cs.style.display = txt ? "block" : "none";
  }
  try{ updateVoteBars(); }catch(_e){}
}
catch(_e){}
  document.getElementById("favBtn1").textContent = card.fav ? "‚≠ê Favorit" : "‚òÜ Favorit";
  const sb = document.getElementById("shareBtn1");
  if(sb) sb.textContent = card.sharedClass ? "üë• Geteilt (lokal)" : "üë• An Klasse teilen";
}

function toggleAnswer(flashId){
  const el = document.getElementById(flashId);
  if(el) el.classList.toggle("revealed");
  // Karteikarten: Sicher-Button erst aktiv, wenn Antwort sichtbar (flash1)
  try{
    if(flashId === "flash1"){
      setCardSafeEnabled(!!(el && el.classList.contains("revealed")));
    }
  }catch(_e){}
}

function nextCard(){
  try{ setCardSafeEnabled(false); }catch(_e){}
  try{ lf_setNextEnabled('sCards', false); }catch(_e){}

  if(!state.session.ids.length){ toast("cardsNotice","Keine Karten vorhanden."); return; }
  state.session.i = (state.session.i + 1) % state.session.ids.length;
  showCurrent();
}

function rateCurrent(isRight){
  try{ lf_setNextEnabled('sCards', true); }catch(_e){}

  const db = loadDB();
  const id = state.session.ids[state.session.i];
  const card = db.cards.find(c=>c.id===id);
  if(!card){ toast("cardsNotice","Keine Karte."); return; }
  card.stats = card.stats || {};
  card.stats.seen = (card.stats.seen||0) + 1;
  if(isRight) { card.stats.correct = (card.stats.correct||0) + 1; try{ addPoint(); }catch(_e){} }
  else card.stats.wrong = (card.stats.wrong||0) + 1;
  saveDB(db);
  try{ updateOverviews(); }catch(_e){}
  toast("cardsNotice", isRight ? "‚úÖ Richtig" : "‚ùå Falsch");
}

function toggleFavCurrent(){
  // WICHTIG: Immer dieselbe DB-Instanz benutzen, sonst wird das Flag nicht persistiert.
  const db = loadDB();
  const id = state.session.ids[state.session.i];
  const card = db.cards.find(c=>c.id===id);
  if(!card){ return; }
  card.fav = !card.fav;
  saveDB(db);
  try{ updateOverviews(); }catch(_e){}

  // Favoritenliste sofort aktualisieren (ohne Funktionsverlust)
  try{ buildFav(); }catch(_e){}

  const b = document.getElementById("favBtn1");
  if(b) b.textContent = card.fav ? "‚≠ê Favorit" : "‚òÜ Favorit";

  const sb = document.getElementById("shareBtn1");
  if(sb) sb.textContent = card.sharedClass ? "üë• Geteilt (lokal)" : "üë• An Klasse teilen";

  toast("cardsNotice", card.fav ? "‚≠ê Favorit gesetzt (Modus 6)" : "‚òÜ Favorit entfernt");
}



/* ====== Modus 3: Quiz (1 Frage ‚Ä¢ 4 Antworten) ====== */

/* --- Quiz: Antwortreihenfolge ohne Muster (Shuffle) --- */
function quizGetOrderFor(id){
  try{
    state.quiz = state.quiz || {};
    state.quiz._orderCache = state.quiz._orderCache || {};
    if(state.quiz._orderCache[id]) return state.quiz._orderCache[id].slice();
    const arr=[0,1,2,3];
    // Fisher-Yates Shuffle
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      const tmp=arr[i]; arr[i]=arr[j]; arr[j]=tmp;
    }
    state.quiz._orderCache[id]=arr.slice();
    return arr;
  }catch(_e){
    return [0,1,2,3];
  }
}
function quizResetOrderFor(id){
  try{
    if(state && state.quiz && state.quiz._orderCache) delete state.quiz._orderCache[id];
  }catch(_e){}
}

function startQuiz(){
  document.getElementById("hdrNameQ").textContent = state.name || "‚Äì";
  document.getElementById("hdrExamQ").textContent = getExamTitle(state.activeExamId);
  
  updateLevelUI();
buildQuiz();
  show("sQuiz");
  renderQuiz();
}

function buildQuiz(){
  const db = loadDB();
  const f = state.quizFilter || "open";
  const q = (state.quizSearch||"").trim().toLowerCase();

  let items = (db.quiz||[])
    .filter(x=>x.examId===state.activeExamId);

  // Suche
  if(q){
    items = items.filter(x=>{
      const a = (x.question||"").toLowerCase();
      const b = (x.answers||[]).join(" ").toLowerCase();
      const s = (x.source ? JSON.stringify(x.source) : "").toLowerCase();
      return a.includes(q) || b.includes(q) || s.includes(q);
    });
  }

  // Filter
  if(f==="open") items = items.filter(x=>!x.isSafe);
  else if(f==="safe") items = items.filter(x=>!!x.isSafe);
  else if(f==="fav") items = items.filter(x=>!!x.fav);
  else if(f==="hard"){
    items = items
      .filter(x=>(x.stats && x.stats.wrong) ? (x.stats.wrong>0) : false)
      .sort((a,b)=>((b.stats&&b.stats.wrong)||0) - ((a.stats&&a.stats.wrong)||0));
  }

  const ids = items.map(x=>x.id);

  state.quiz.ids = ids;
  state.quiz.i = 0;
  state.quiz.locked = false;
  try{ state.quiz._orderCache = {}; }catch(_e){}
}

function currentQuiz(){
  const db = loadDB();
  const id = state.quiz.ids[state.quiz.i];
  return db.quiz.find(q=>q.id===id);
}

function renderQuiz(){
  try{ updateOverviews(); }catch(_e){}
  try{ const sb=document.getElementById('quizStatusBar'); if(sb){ sb.className='quiz-status neutral'; sb.textContent='Antwort ausw√§hlen'; } }catch(_e){}

  try{ setQuizButtonsEnabled(false); }catch(_e){}

  setQuizMasteryButtonsEnabled(false);
  state.quiz.locked = false;

  const box = document.getElementById("quizBox");
  const q = currentQuiz();
  state.quiz.locked = false;
  // reset button styles
  for(let i=0;i<4;i++){
    const b = document.getElementById("ans"+i);
    if(b){
      b.className = "btn secondary w100";
      b.disabled = false;
    }
  }
  if(!q){
    const f = state.quizFilter || "open";
    document.getElementById("quizQ").textContent = (f==="open" ? "Keine offenen Quiz-Fragen f√ºr diesen Filter." : "Keine Quiz-Fragen f√ºr diesen Filter.");
    toast("quizNotice", f==="fav" ? "Tipp: (Optional) Favoriten f√ºr Quiz k√∂nnen wir sp√§ter erg√§nzen." : "Tipp: Filter √§ndern oder Quiz-Fragen erstellen/importieren.");
    return;
  }
  document.getElementById("quizQ").textContent = q.question || "‚Äî";
  try{
    const qs = document.getElementById("quizSource");
    if(qs){
      const txt = formatSource(q.source);
      qs.textContent = txt;
      qs.style.display = txt ? "block" : "none";
    }
  }catch(_e){}
  q.answers = q.answers || ["‚Äî","‚Äî","‚Äî","‚Äî"];
  // Shuffle (stabil pro Frage)
  const order = quizGetOrderFor(q.id);
  state.quiz.order = order.slice();

  for(let i=0;i<4;i++){
    const b = document.getElementById("ans"+i);
    const orig = order[i] ?? i;
    if(b) b.textContent = (q.answers[orig] ?? "‚Äî");
  }
  const sb = document.getElementById("shareBtnQ");
  if(sb) sb.textContent = q.sharedClass ? "üë• Geteilt (lokal)" : "üë• An Klasse teilen";
  try{ updateVoteBars(); }catch(_e){}
}


function pickAnswer(idx){
  if(state.quiz.locked) return;
  const db = loadDB();
  const id = state.quiz.ids[state.quiz.i];
  const q = (db.quiz||[]).find(x=>x.id===id);
  if(!q) return;
  // idx ist die angeklickte Button-Position (0..3) ‚Äì wir mappen zur√ºck auf den originalen Antwortindex
  const order = (state.quiz && Array.isArray(state.quiz.order)) ? state.quiz.order : [0,1,2,3];
  const origIdx = Number(order[Number(idx)] ?? idx);
  const correct = Number(q.correctIndex) === Number(origIdx);
  state.quiz.locked = true;
  try{
    const sb=document.getElementById("quizStatusBar");
    if(sb){ sb.className="quiz-status " + (correct?"right":"wrong"); sb.textContent = correct?"‚úî Richtig":"‚úñ Falsch"; }
  }catch(_e){}
  try{ setQuizButtonsEnabled(true); }catch(_e){}


  // visual feedback: correct green gradient button, wrong red
  for(let i=0;i<4;i++){
    const b = document.getElementById("ans"+i);
    if(!b) continue;
    b.disabled = true;

    const orig = Number(order[i] ?? i);
    if(orig === Number(q.correctIndex)){
      b.className = "btn w100";
    }else if(i === idx && !correct){
      b.className = "btn danger w100";
    }else{
      b.className = "btn ghost w100";
    }
  }

  // stats
  q.stats = q.stats || {};
  q.stats.seen = (q.stats.seen||0)+1;
  if(correct) { q.stats.correct = (q.stats.correct||0)+1; try{ addPoint(); }catch(_e){} }
  else q.stats.wrong = (q.stats.wrong||0)+1;
  saveDB(db);

  // nach Antwortauswahl darf Sicher/Unsicher gedr√ºckt werden
  setQuizMasteryButtonsEnabled(true);

  toast("quizNotice", correct ? "‚úÖ Richtig!" : "‚ùå Falsch ‚Äì richtige Antwort markiert.");
}


function toggleShareQuizCurrent(){
  const db = loadDB();
  const id = state.quiz.ids[state.quiz.i];
  const q = (db.quiz||[]).find(x=>x.id===id);
  if(!q) return;
  q.sharedClass = !q.sharedClass;
  q.sharedAt = q.sharedClass ? Date.now() : null;
  saveDB(db);

  const btn = document.getElementById("shareBtnQ");
  if(btn) btn.textContent = q.sharedClass ? "üë• Geteilt (lokal)" : "üë• An Klasse teilen";

  toast("quizNotice", q.sharedClass ? "üë• Markiert als geteilt (lokal)" : "üë• Teilen-Markierung entfernt");  try{ updateModeCounts(); }catch(_e){}
  try{
    const s = document.getElementById('sShare');
    if(s && !s.classList.contains('hidden')){ renderShareList(); }
  }catch(_e){}
}
function nextQuiz(){
  if(!state.quiz.ids.length){ toast("quizNotice","Keine Quiz-Fragen."); return; }
  state.quiz.i = (state.quiz.i + 1) % state.quiz.ids.length;
  renderQuiz();
}


/* ===== Quiz Mastery (Unsicher/Sicher) ===== */
function setQuizMasteryButtonsEnabled(on){
  try{
    const u = document.getElementById("quizUnsureBtn2");
    const s = document.getElementById("quizSafeBtn2");
    if(u) u.disabled = !on;
    if(s) s.disabled = !on;
  }catch(_e){}
}

function markQuizMastery(isSafe){
  // Sicher/Unsicher darf erst nach Antwort-Auswahl gedr√ºckt werden
  if(!state.quiz.locked) { toast("quizNotice","Erst eine Antwort w√§hlen."); return; }

  const db = loadDB();
  const curId = state.quiz.ids[state.quiz.i];
  const q = (db.quiz||[]).find(x=>x.id===curId);
  if(!q) { toast("quizNotice","Frage nicht gefunden."); return; }

  q.isSafe = !!isSafe;
  saveDB(db);

  // Buttons wieder sperren bis n√§chste Antwort gew√§hlt wurde
  setQuizMasteryButtonsEnabled(false);
  state.quiz.locked = false;

  if(isSafe){
    // aus dem Pool entfernen
    state.quiz.ids = state.quiz.ids.filter(id=>id!==curId);
    if(state.quiz.i >= state.quiz.ids.length) state.quiz.i = 0;
  }else{
    // bei unsicher: einfach zur n√§chsten Frage weiter
    if(state.quiz.ids.length) state.quiz.i = (state.quiz.i + 1) % state.quiz.ids.length;
  }

  // letzte Karte Hinweis
  if(state.quiz.ids.length === 1){
    toast("quizNotice","‚ö†Ô∏è Letzte unsichere Frage in diesem Durchgang!");
  }

  // Reset, wenn alles sicher
  if(state.quiz.ids.length === 0){
    // alle Quizfragen dieser Klausur wieder unsicher setzen
    (db.quiz||[]).forEach(x=>{
      if(x.examId === state.activeExamId) x.isSafe = false;
    });
    saveDB(db);
    buildQuiz();
    toast("quizNotice","üéâ Alle Fragen sicher! Neuer Durchgang startet automatisch.");
  }

  renderQuiz();
}



/* ====== Modus 5: An Klasse teilen (lokal markieren) ====== */
function startShare(){
  document.getElementById("hdrName5").textContent = state.name || "‚Äì";
  document.getElementById("hdrExam5").textContent = getExamTitle(state.activeExamId);
  renderShareList();
  show("sShare");
  try{ shareShow("view"); }catch(_e){}
}


function shareShow(tab){
  const pCards = document.getElementById("sharePanelCards");
  const pQuiz  = document.getElementById("sharePanelQuiz");
  const pView  = document.getElementById("sharePanelView");
  if(pCards) pCards.style.display = (tab==="cards") ? "block" : "none";
  if(pQuiz)  pQuiz.style.display  = (tab==="quiz")  ? "block" : "none";
  if(pView)  pView.style.display  = (tab==="view")  ? "block" : "none";

  const bC = document.getElementById("shareHubBtnCards");
  const bQ = document.getElementById("shareHubBtnQuiz");
  const bV = document.getElementById("shareHubBtnView");
  if(bC) bC.classList.toggle("ok", tab==="cards");
  if(bQ) bQ.classList.toggle("ok", tab==="quiz");
  if(bV) bV.classList.toggle("ok", tab==="view");
}

function startSharedCards(){
  state.fromShare = true;
  const db = loadDB();
  const ids = (db.cards||[])
    .filter(c=>c.examId===state.activeExamId && c.sharedClass)
    .map(c=>c.id);

  if(!ids.length){
    toast("shareNotice","Keine geteilten Karteikarten zum Lernen.");
    shareShow("view");
    return;
  }

  state.session.ids = ids;
  state.session.i = 0;
  startCards();
}

function startSharedQuiz(){
  state.fromShare = true;
  const db = loadDB();
  const ids = (db.quiz||[])
    .filter(q=>q.examId===state.activeExamId && q.sharedClass)
    .map(q=>q.id);

  if(!ids.length){
    toast("shareNotice","Keine geteilten Quizfragen zum Lernen.");
    shareShow("view");
    return;
  }

  state.quiz.ids = ids;
  state.quiz.i = 0;
  state.quiz.locked = false;
  try{ setQuizMasteryButtonsEnabled(false); }catch(_e){}
  show("sQuiz");
  renderQuiz();
}

function toggleShareCurrent(){
  const db = loadDB();
  const id = state.session.ids[state.session.i];
  const card = db.cards.find(c=>c.id===id);
  if(!card){ return; }
  card.sharedClass = !card.sharedClass;
  card.sharedAt = card.sharedClass ? Date.now() : null;
  saveDB(db);

  const btn = document.getElementById("shareBtn1");
  if(btn) btn.textContent = card.sharedClass ? "üë• Geteilt (lokal)" : "üë• An Klasse teilen";

  toast("cardsNotice", card.sharedClass ? "üë• Markiert als geteilt (lokal)" : "üë• Teilen-Markierung entfernt");  try{ updateModeCounts(); }catch(_e){}
  try{
    const s = document.getElementById('sShare');
    if(s && !s.classList.contains('hidden')){ renderShareList(); }
  }catch(_e){}
}

function renderShareList(){
  const db = loadDB();
  const list = document.getElementById("shareList");
  if(!list) return;
  list.innerHTML = "";

  const user = (typeof getUserName === "function" ? (getUserName()||"") : "") || "anon";

  // Nur geteilte Inhalte dieser Klausur + NICHT ausgeblendet
  const cardItems = (db.cards||[])
    .filter(c => c.examId === state.activeExamId && c.sharedClass && !c.sharedHidden)
    .map(c=>({type:"card", id:c.id, front:c.front, sharedAt:c.sharedAt||0, likes:(c.likesCount||0), dislikes:(c.dislikesCount||0), vote: (c.votes && c.votes[user]) ? c.votes[user] : 0 }));

  const quizItems = (db.quiz||[])
    .filter(q => q.examId === state.activeExamId && q.sharedClass && !q.sharedHidden)
    .map(q=>({type:"quiz", id:q.id, front:q.question, sharedAt:q.sharedAt||0, likes:(q.likesCount||0), dislikes:(q.dislikesCount||0), vote: (q.votes && q.votes[user]) ? q.votes[user] : 0 }));

  const items = cardItems.concat(quizItems).sort((a,b)=>b.sharedAt-a.sharedAt);

  if(!items.length){
    list.innerHTML = '<div class="notice">Keine geteilten Karten/Quizfragen vorhanden.</div>';
    return;
  }

  items.forEach(item=>{
    const div = document.createElement("div");
    div.className = "tile";
    div.style.cursor = "default";

    const badge = item.type==="quiz" ? "Quiz" : "Karte";
    const likeActive = item.vote===1 ? "ok" : "";
    const disActive  = item.vote===-1 ? "danger" : "ghost";

    div.innerHTML =
      '<div class="t1">'+escapeHtml(item.front||"‚Äî")+'</div>'
      + '<div class="t2">'+badge+' ‚Ä¢ Markiert ‚Ä¢ (sp√§ter online sichtbar)</div>'
      + '<div class="row" style="margin-top:10px; gap:10px; flex-wrap:wrap;">'
      +   '<button class="btn '+likeActive+'" type="button" data-vote="1">üëç '+(item.likes||0)+'</button>'
      +   '<button class="btn '+disActive+'" type="button" data-vote="-1">üëé '+(item.dislikes||0)+'</button>'
      +   '<button class="btn danger" type="button" data-unshare="1">Entmarkieren</button>'
      + '</div>';

    // Voting
    div.querySelectorAll("button[data-vote]").forEach(btn=>{
      btn.onclick = ()=>{
        const v = Number(btn.getAttribute("data-vote"));
        voteShared(item.type, item.id, v);
      };
    });

    // Entmarkieren
    div.querySelector("button[data-unshare]").onclick = ()=>{
      const db2 = loadDB();
      if(item.type==="card"){
        const cc = (db2.cards||[]).find(x=>x.id===item.id);
        if(cc){ cc.sharedClass = false; cc.sharedAt = null; }
      }else{
        const qq = (db2.quiz||[]).find(x=>x.id===item.id);
        if(qq){ qq.sharedClass = false; qq.sharedAt = null; }
      }
      saveDB(db2);
      toast("shareNotice","Entmarkiert.");
      renderShareList();

      // UI-Buttons aktualisieren, falls aktuell sichtbar
      try{
        const cur = currentCard();
        if(cur && item.type==="card" && cur.id===item.id){
          const btn = document.getElementById("btnShareClass");
          if(btn) btn.classList.remove("ok");
        }
      }catch(_e){}
    };

    list.appendChild(div);
  });
}

function voteShared(type, id, vote){
  // vote: 1 like, -1 dislike
  const db = loadDB();
  const user = (typeof getUserName === "function" ? (getUserName()||"") : "") || "anon";
  const now = Date.now();

  let obj = null;
  if(type==="card"){
    obj = (db.cards||[]).find(x=>x.id===id);
  }else{
    obj = (db.quiz||[]).find(x=>x.id===id);
  }
  if(!obj) return;

  // init fields
  if(!obj.votes) obj.votes = {};
  if(typeof obj.likesCount !== "number") obj.likesCount = 0;
  if(typeof obj.dislikesCount !== "number") obj.dislikesCount = 0;

  const prev = Number(obj.votes[user] || 0);

  // Toggle logic: same vote again => remove vote
  let next = vote;
  if(prev === vote) next = 0;

  // Adjust counters
  if(prev === 1) obj.likesCount = Math.max(0, (obj.likesCount||0) - 1);
  if(prev === -1) obj.dislikesCount = Math.max(0, (obj.dislikesCount||0) - 1);

  if(next === 1) obj.likesCount = (obj.likesCount||0) + 1;
  if(next === -1) obj.dislikesCount = (obj.dislikesCount||0) + 1;

  if(next === 0){
    delete obj.votes[user];
  }else{
    obj.votes[user] = next;
  }

  // Auto-Ausblenden bei 5 Dislikes (NICHT l√∂schen)
  if((obj.dislikesCount||0) >= 5){
    obj.sharedHidden = true;
    obj.sharedHiddenAt = now;
    obj.sharedHiddenReason = "auto_dislike_5";
  }

  saveDB(db);

  if((obj.dislikesCount||0) >= 5){
    toast("shareNotice","Diese Karte wurde wegen 5 üëé ausgeblendet (Admin kann sie wiederherstellen).");
  }else{
    toast("shareNotice","Bewertung gespeichert.");
  }

  renderShareList();
}


/* ===== Admin: Ausgeblendete Inhalte (5x üëé) ===== */
function toggleHiddenShared(){
  const panel = document.getElementById("hiddenSharedPanel");
  if(!panel) return;
  const isOpen = panel.style.display !== "none";
  panel.style.display = isOpen ? "none" : "block";
  if(!isOpen){
    renderHiddenSharedList();
    try{ panel.scrollIntoView({behavior:'smooth', block:'start'}); }catch(_e){}
  }
}

function renderHiddenSharedList(){
  const db = loadDB();
  const list = document.getElementById("hiddenSharedList");
  if(!list) return;
  list.innerHTML = "";

  const cards = (db.cards||[]).filter(c=>c.examId===state.activeExamId && c.sharedClass && c.sharedHidden);
  const quiz  = (db.quiz||[]).filter(q=>q.examId===state.activeExamId && q.sharedClass && q.sharedHidden);

  const items = cards.map(c=>({type:"card", id:c.id, text:c.front||"‚Äî", dislikes:c.dislikesCount||0, likes:c.likesCount||0, hiddenAt:c.sharedHiddenAt||0}))
    .concat(quiz.map(q=>({type:"quiz", id:q.id, text:q.question||"‚Äî", dislikes:q.dislikesCount||0, likes:q.likesCount||0, hiddenAt:q.sharedHiddenAt||0})))
    .sort((a,b)=>b.hiddenAt-a.hiddenAt);

  if(!items.length){
    list.innerHTML = '<div class="small">Keine ausgeblendeten Inhalte in dieser Klausur.</div>';
    return;
  }

  items.forEach(it=>{
    const div = document.createElement("div");
    div.className = "tile";
    div.style.cursor = "default";
    const label = it.type==="quiz" ? "Quiz" : "Karte";
    div.innerHTML =
      '<div class="t1">'+escapeHtml(it.text)+'</div>'
      + '<div class="t2">'+label+' ‚Ä¢ ausgeblendet ‚Ä¢ üëç '+(it.likes||0)+' ‚Ä¢ üëé '+(it.dislikes||0)+'</div>'
      + '<div class="row" style="margin-top:10px; gap:10px; flex-wrap:wrap;">'
      +   '<button class="btn ok" type="button" onclick="restoreHiddenShared(\''+it.type+'\', \''+it.id+'\')">Wiederherstellen</button>'
      + '</div>';
    list.appendChild(div);
  });
}

function restoreHiddenShared(type, id){
  const db = loadDB();
  let obj = null;
  if(type==="card") obj = (db.cards||[]).find(x=>x.id===id);
  else obj = (db.quiz||[]).find(x=>x.id===id);
  if(!obj) return;

  obj.sharedHidden = false;
  obj.sharedHiddenAt = null;
  obj.sharedHiddenReason = null;

  saveDB(db);
  toast("shareNotice","Wiederhergestellt.");
  try{ renderHiddenSharedList(); }catch(_e){}
  try{ renderShareList(); }catch(_e){}
}



/* ====== Mode 6 Favorites (ALL) ====== */
function startFav(){
  document.getElementById("hdrName4").textContent = state.name || "‚Äì";
  buildFav();
  show("sFav");
  showFav();
}

function buildFav(){
  const db = loadDB();
  state.fav.ids = db.cards.filter(c=>c.fav).map(c=>c.id);
  state.fav.i = 0;
}

function favCard(){
  const db = loadDB();
  const id = state.fav.ids[state.fav.i];
  return db.cards.find(c=>c.id===id);
}

function showFav(){
  const flash = document.getElementById("flash6");
  flash.classList.remove("revealed");
  const card = favCard();
  if(!card){
    document.getElementById("q6").textContent = "Keine Favoriten gefunden.";
    document.getElementById("a6").textContent = "Tipp: Markiere Karten in Modus 1 mit ‚òÜ/‚≠ê.";
    document.getElementById("favBtn6").textContent = "‚≠ê Favorit";
    return;
  }
  document.getElementById("q6").textContent = card.front || "‚Äî";
  document.getElementById("a6").textContent = card.back || "";
  document.getElementById("favBtn6").textContent = card.fav ? "‚≠ê Favorit" : "‚òÜ Favorit";
}

function nextFav(){
  try{ lf_setNextEnabled('sFav', false); }catch(_e){}

  if(!state.fav.ids.length){ toast("favNotice","Keine Favoriten."); return; }
  state.fav.i = (state.fav.i + 1) % state.fav.ids.length;
  showFav();
}

function rateFav(isRight){
  try{ lf_setNextEnabled('sFav', true); }catch(_e){}

  const db = loadDB();
  const card = favCard();
  if(!card){ toast("favNotice","Keine Karte."); return; }
  card.stats = card.stats || {};
  card.stats.seen = (card.stats.seen||0) + 1;
  if(isRight) { card.stats.correct = (card.stats.correct||0) + 1; try{ addPoint(); }catch(_e){} }
  else card.stats.wrong = (card.stats.wrong||0) + 1;
  saveDB(db);
  toast("favNotice", isRight ? "‚úÖ Richtig gespeichert" : "‚ùå Falsch gespeichert");
  nextFav();
}

function toggleFavInFav(){
  const db = loadDB();
  const id = state.fav.ids[state.fav.i];
  const card = db.cards.find(c=>c.id===id);
  if(!card){ return; }
  card.fav = !card.fav;
  saveDB(db);

  // rebuild list so removed favorites disappear
  buildFav();
  showFav();
  toast("favNotice", card.fav ? "‚≠ê Favorit gesetzt" : "‚òÜ Aus Favoriten entfernt");
}

/* ===== Import / Export (Exam-level) ‚Äì Karten & Quiz getrennt ===== */
function triggerImport(kind){
  const map = {
    "cards-append": "importFileCardsAppend",
    "quiz-append": "importFileQuizAppend",
    "cards-replace": "importFileCardsReplace",
    "quiz-replace": "importFileQuizReplace"
  };
  const id = map[kind];
  const el = document.getElementById(id);
  if(el) el.click();
}

function downloadJson(payload, filename){
  const blob = new Blob([JSON.stringify(payload,null,2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 800);
}

function exportCards(){
  const db = loadDB();
  const examId = state.activeExamId || (db.exams[0]?.id||"");
  if(!examId){ toast("examNotice","Keine Klausur ausgew√§hlt."); return; }
  const exam = db.exams.find(e=>e.id===examId) || {id:examId,title:"Klausur",date:""};
  const cards = db.cards.filter(c=>c.examId===examId).map(c=>({
    id: c.id,
    front: c.front,
    back: c.back,
    fav: !!c.fav,
    sharedClass: !!c.sharedClass,
    sharedAt: c.sharedAt || null,
    source: (c.source && typeof c.source==="object") ? c.source : null
  }));
  const payload = {
    type: "cards-export",
    exam: { id: exam.id, title: exam.title, date: exam.date || "" },
    targetExamId: exam.id,
    cards
  };
  downloadJson(payload, (exam.title||"klausur").replace(/\s+/g,"_") + "_cards_export.json");
  toast("examNotice","Karten exportiert.");
}

function exportQuiz(){
  const db = loadDB();
  const examId = state.activeExamId || (db.exams[0]?.id||"");
  if(!examId){ toast("examNotice","Keine Klausur ausgew√§hlt."); return; }
  const exam = db.exams.find(e=>e.id===examId) || {id:examId,title:"Klausur",date:""};
  const quiz = (db.quiz||[]).filter(q=>q.examId===examId).map(q=>({
    id: q.id,
    question: q.question,
    answers: q.answers,
    correctIndex: q.correctIndex,
    sharedClass: !!q.sharedClass,
    sharedAt: q.sharedAt || null,
    source: (q.source && typeof q.source==="object") ? q.source : null
  }));
  const payload = {
    type: "quiz-export",
    exam: { id: exam.id, title: exam.title, date: exam.date || "" },
    targetExamId: exam.id,
    quiz
  };
  downloadJson(payload, (exam.title||"klausur").replace(/\s+/g,"_") + "_quiz_export.json");
  toast("examNotice","Quiz exportiert.");
}

function handleImport(ev, kind){
  const file = ev.target.files && ev.target.files[0];
  if(!file) return;

  const reader = new FileReader();
  reader.onload = () => {
    let obj = null;
    try{
      obj = JSON.parse(String(reader.result||""));
    }catch(_e){
      toast("examNotice","Import fehlgeschlagen: kein g√ºltiges JSON.");
      ev.target.value = "";
      return;
    }

    const db = loadDB();
    const fallbackExamId = state.activeExamId || (db.exams[0]?.id||"");

    // --- Import-Normalisierung: akzeptiere auch "Root-Arrays" (reine Listen) ---
    // Viele Nutzer exportieren/erstellen JSON als [ {...}, {...} ] ohne Wrapper.
    // Damit der Import nicht still fehlschl√§gt, wrappen wir es passend zu "kind".
    if(Array.isArray(obj)){
      const ex = db.exams.find(e=>e.id===fallbackExamId) || { id: (fallbackExamId||"IMPORT"), title: "Import", date: "" };
      if(kind.startsWith("cards-")){
        obj = { type: "cards-export", exam: ex, targetExamId: ex.id, cards: obj };
      }else if(kind.startsWith("quiz-")){
        obj = { type: "quiz-export", exam: ex, targetExamId: ex.id, quiz: obj };
      }
    }

    // ExamId ermitteln: prefer targetExamId, else exam.id, else aktive Klausur
    const targetExamId = obj.targetExamId || obj.exam?.id || fallbackExamId;
    if(!targetExamId){
      toast("examNotice","Import fehlgeschlagen: keine Klausur-ID.");
      ev.target.value = "";
      return;
    }

    // Stelle sicher, dass Klausur existiert (falls Datei nur Anh√§nge enth√§lt)
    if(!db.exams.find(e=>e.id===targetExamId)){
      const ex = obj.exam || { id: targetExamId, title: "Neue Klausur", date: "" };
      db.exams.push({ id: ex.id, title: ex.title || "Neue Klausur", date: ex.date || "" });
    }

    const newId = (prefix)=> prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now();

    const appendCards = (cards)=>{
      let added=0, skipped=0;
      (cards||[]).forEach(c=>{
        if(!c || !c.front) return;
        let id = String(c.id||"").trim() || newId("c");
        if(db.cards.some(x=>x.id===id)){ skipped++; return; } // sicher: keine √úberschreibung
        db.cards.push({
          id,
          examId: targetExamId,
          front: String(c.front||""),
          back: String(c.back||""),
          fav: !!c.fav,
          sharedClass: !!c.sharedClass,
          sharedAt: c.sharedAt || null,
          stats: c.stats || {},
          source: (c.source && typeof c.source==="object") ? c.source : null
        });
        added++;
      });
      return {added, skipped};
    };

    const replaceCards = (cards)=>{
      db.cards = db.cards.filter(c=>c.examId!==targetExamId);
      return appendCards(cards);
    };

    const appendQuiz = (quiz)=>{
      let added=0, skipped=0;
      if(!Array.isArray(db.quiz)) db.quiz = [];
      (quiz||[]).forEach(q=>{
        if(!q || !q.question || !Array.isArray(q.answers) || q.answers.length!==4) return;
        let id = String(q.id||"").trim() || newId("q");
        if(db.quiz.some(x=>x.id===id)){ skipped++; return; }
        db.quiz.push({
          id,
          examId: targetExamId,
          question: String(q.question||""),
          answers: q.answers.map(a=>String(a)),
          correctIndex: Number(q.correctIndex||0),
          sharedClass: !!q.sharedClass,
          sharedAt: q.sharedAt || null,
          stats: q.stats || {},
          source: (q.source && typeof q.source==="object") ? q.source : null
        });
        added++;
      });
      return {added, skipped};
    };

    const replaceQuiz = (quiz)=>{
      if(!Array.isArray(db.quiz)) db.quiz = [];
      db.quiz = db.quiz.filter(q=>q.examId!==targetExamId);
      return appendQuiz(quiz);
    };

    try{
      // Karten
      if(kind==="cards-append" || kind==="cards-replace"){
        const res = (kind==="cards-replace") ? replaceCards(obj.cards||[]) : appendCards(obj.cards||[]);
        saveDB(db);
        state.activeExamId = targetExamId;
        renderExams();
        highlightSelectedExam();
        toast("examNotice", `Karten importiert: +${res.added} ‚Ä¢ √ºbersprungen ${res.skipped}` + (kind==="cards-replace" ? " (ersetzt)" : ""));
      }
      // Quiz
      else if(kind==="quiz-append" || kind==="quiz-replace"){
        const res = (kind==="quiz-replace") ? replaceQuiz(obj.quiz||[]) : appendQuiz(obj.quiz||[]);
        saveDB(db);
        state.activeExamId = targetExamId;
        renderExams();
        highlightSelectedExam();
        toast("examNotice", `Quiz importiert: +${res.added} ‚Ä¢ √ºbersprungen ${res.skipped}` + (kind==="quiz-replace" ? " (ersetzt)" : ""));
      }else{
        toast("examNotice","Import-Typ unbekannt.");
      }
    }catch(_e){
      toast("examNotice","Import fehlgeschlagen: Format pr√ºfen.");
    }

    ev.target.value = "";
  };
  reader.readAsText(file);
}



/* ===== Level / Punkte (nutzerweit) ===== */
const PROFILE_KEY = "lt_profile_v1";
const LEVEL_STEP = 50;
const MAX_LEVEL = 20;

function loadProfile(){
  try{
    const raw = localStorage.getItem(PROFILE_KEY);
    if(raw){
      const p = JSON.parse(raw);
      if(p && typeof p.totalPoints === "number") return p;
    }
  }catch(_e){}
  return { totalPoints: 0, maxLevel: MAX_LEVEL };
}

function saveProfile(p){
  try{ localStorage.setItem(PROFILE_KEY, JSON.stringify(p)); }catch(_e){}
}

function calcLevel(totalPoints, maxLevel){
  const lvl = Math.floor(Math.max(0,totalPoints) / LEVEL_STEP) + 1;
  return Math.min(maxLevel || MAX_LEVEL, Math.max(1, lvl));
}

function pointsToNext(totalPoints){
  const inLevel = ((Math.max(0,totalPoints)) % LEVEL_STEP);
  return { inLevel, need: LEVEL_STEP - inLevel };
}


/* ===== Highscore Sync Helper: t√§gliche Sicher-Z√§hlung ===== */
function incrementDailySecure(){
  try{
    const today = new Date().toISOString().slice(0,10);
    const last = localStorage.getItem("dailyScoreDate");
    if(last !== today){
      localStorage.setItem("dailyScoreDate", today);
      localStorage.setItem("dailySecure", "0");
    }
    const cur = Number(localStorage.getItem("dailySecure") || 0);
    localStorage.setItem("dailySecure", String(cur + 1));
  }catch(_e){}
}
function lt_getExamId(){
  try{ if(window.state && state.activeExamId) return state.activeExamId; }catch(_e){}
  return localStorage.getItem("currentExamId") || "default";
}
function lt_masteryKey(){
  return "lt_mastered_" + lt_getExamId();
}
function lt_loadMasterySet(){
  try{
    const raw = localStorage.getItem(lt_masteryKey());
    const arr = raw ? JSON.parse(raw) : [];
    return new Set(Array.isArray(arr) ? arr : []);
  }catch(_e){
    return new Set();
  }
}
function lt_saveMasterySet(set){
  try{ localStorage.setItem(lt_masteryKey(), JSON.stringify(Array.from(set))); }catch(_e){}
}
function lt_markMastered(kind, id){
  if(!id) return;
  const set = lt_loadMasterySet();
  set.add(kind + ":" + String(id));
  lt_saveMasterySet(set);
}
function lt_getMasteryCounts(){
  const db = loadDB();
  const set = lt_loadMasterySet();
  const totalCards = (db.cards||[]).length;
  const totalQuiz  = (db.quiz||[]).length;
  const total = totalCards + totalQuiz;
  let mastered = 0;
  // Count only ids that exist in current DB (so imports/replace stay consistent)
  const valid = new Set();
  for(const c of (db.cards||[])) valid.add("card:"+String(c.id));
  for(const q of (db.quiz||[])) valid.add("quiz:"+String(q.id));
  for(const key of set){ if(valid.has(key)) mastered++; }
  return { mastered, total, totalCards, totalQuiz };
}

/* ===== /Highscore Sync Helper ===== */

function updateLevelUI(){
  const p = loadProfile();
  const lvl = calcLevel(p.totalPoints, p.maxLevel);
  const prog = pointsToNext(p.totalPoints);
  const txt = `${prog.inLevel}/${LEVEL_STEP}`;

  const pct = Math.max(0, Math.min(100, (prog.inLevel / LEVEL_STEP) * 100));


  const lc = document.getElementById("hdrLvlC");
  const xc = document.getElementById("hdrXpC");
  if(lc) lc.textContent = String(lvl);
  if(xc) xc.textContent = txt;

  const lq = document.getElementById("hdrLvlQ");
  const xq = document.getElementById("hdrXpQ");
  if(lq) lq.textContent = String(lvl);
  if(xq) xq.textContent = txt;

  const lm = document.getElementById("hdrLvlM");
  const xm = document.getElementById("hdrXpM");
  if(lm) lm.textContent = String(lvl);
  if(xm) xm.textContent = txt;

  const fc = document.getElementById("hdrXpFillC");
  const fq = document.getElementById("hdrXpFillQ");
  if(fc) fc.style.width = pct + "%";
  if(fq) fq.style.width = pct + "%";

  const fm = document.getElementById("hdrXpFillM");
  if(fm) fm.style.width = pct + "%";
}

function addPoint(){
  const p = loadProfile();
  p.totalPoints = (p.totalPoints||0) + 1;
  if(!p.maxLevel) p.maxLevel = MAX_LEVEL;
  saveProfile(p);
  updateLevelUI();

  const beforeLvl = calcLevel(p.totalPoints-1, p.maxLevel);
  const afterLvl  = calcLevel(p.totalPoints, p.maxLevel);
  if(afterLvl > beforeLvl){
    // kurze R√ºckmeldung, ohne Lernfluss zu st√∂ren
    try{
      toast("cardsNotice", `üéâ Level ${afterLvl} erreicht!`);
      toast("quizNotice", `üéâ Level ${afterLvl} erreicht!`);
    }catch(_e){}
  }
}

/* ===== Utils ===== */
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, (c)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
}


function formatSource(src){
  try{
    if(!src || typeof src !== "object") return "";
    const pres = String(src.presentation || src.present || src.p || "").trim();
    const slide = (src.slide ?? src.folie ?? src.page ?? "");
    const parts = [];
    if(pres) parts.push(pres);
    if(slide !== "" && slide !== null && slide !== undefined) parts.push("Folie " + slide);
    if(!parts.length) return "";
    return "Quelle: " + parts.join(" ‚Ä¢ ");
  }catch(_e){
    return "";
  }
}


/* ===== Boot ===== */
(function init(){
  // name
  try{
    const n = localStorage.getItem(NAME_KEY);
    if(n){ state.name = n; document.getElementById("nameInput").value = n; }
  }catch(_e){}
  // db ensure
  const db = loadDB();
  saveDB(db);
  
  // level/profile init
  try{ const p=loadProfile(); saveProfile(p); }catch(_e){}
  try{ updateLevelUI(); }catch(_e){}
// pick active exam
  if(!state.activeExamId && db.exams[0]) state.activeExamId = db.exams[0].id;
})();

/* ===== Count Karten / Quiz / Favoriten ===== */
function updateModeCounts(){
  try{
    const db = loadDB();

    // Karten liegen global in db.cards und sind √ºber examId an Klausuren gebunden
    const cardsThisExam = (db.cards||[]).filter(c => c.examId === state.activeExamId);
    const allCards = (db.cards||[]);
  const ownCards = allCards.filter(c => !!c.userCreated).length;

    // Favoriten (Modus 6) klausur√ºbergreifend
    const favsAll = allCards.filter(c => !!c.fav || !!c.fav || c.isFavorite).length;

    // Quiz: wenn separate Quiz-Liste existiert, nutze sie; sonst = Karten dieser Klausur
    const quizThisExam = (Array.isArray(db.quiz) && db.quiz.length)
      ? db.quiz.filter(q => (q.examId ? q.examId === state.activeExamId : true)).length
      : cardsThisExam.length;

    const cc = document.getElementById("countCards");
    const cq = document.getElementById("countQuiz");
    const cf = document.getElementById("countFav");

    if(cc) cc.textContent = cardsThisExam.length + " Karten";
    if(cq) cq.textContent = quizThisExam + " Fragen";
    if(cf) cf.textContent = favsAll + " ‚≠ê";
  

    const cs = document.getElementById("countShare");

    // "An Klasse teilen": z√§hlt alle geteilten Inhalte (klausur√ºbergreifend)
    const sharedCards = allCards.filter(c => !!c.sharedClass).length;
    const sharedQuiz  = (Array.isArray(db.quiz) ? db.quiz.filter(q => !!q.sharedClass).length : 0);
    const sharedAll = sharedCards + sharedQuiz;

    if(cs) cs.textContent = sharedAll + " geteilt";

}catch(_e){}
}
document.addEventListener("DOMContentLoaded", () => { try{ restoreActiveExam(); }catch(_e){} updateModeCounts(); setTimeout(updateModeCounts, 150); });


/* ===== Auto-Next helper (safe) ===== */
function autoNext(type){
  try{
    setTimeout(()=>{
      if(type === 'card' && typeof nextCard === 'function') nextCard();
      if(type === 'fav'  && typeof nextFav  === 'function') nextFav();
    }, 180);
  }catch(_e){}
}


/* ===== Karteikarten: Sicher-Logik (zus√§tzlich zu Richtig/Falsch) ===== */
function setCardSafeEnabled(on){
  try{
    const b = document.getElementById("cardSafeBtn");
    if(b) b.disabled = !on;
  }catch(_e){}
}

function markCardSafe(){
  // ‚úÖ Immer m√∂glich (auch wenn nur die Frage sichtbar ist)
  const box = document.getElementById("flash1");

  const db = loadDB();
  const id = state.session.ids[state.session.i];
  const card = (db.cards||[]).find(c=>c.id===id);
  if(!card){ toast("cardsNotice","Keine Karte."); return; }

  card.isSafe = true;
  saveDB(db);
  try{ lt_markMastered("card", card.id); }catch(_e){}

  try{ incrementDailySecure(); }catch(_e){}

  // aus Session entfernen
  state.session.ids = state.session.ids.filter(x=>x!==id);
  if(state.session.i >= state.session.ids.length) state.session.i = 0;

  // UI zur√ºcksetzen
  try{ if(box) box.classList.remove("revealed"); }catch(_e){}
  try{ setCardSafeEnabled(true); }catch(_e){}

  // letzte Karte Hinweis
  if(state.session.ids.length === 1){
    toast("cardsNotice","‚ö†Ô∏è Letzte unsichere Karte in diesem Durchgang!");
  }

  // Reset, wenn alles sicher
  if(state.session.ids.length === 0){
    // alle Karten der Klausur wieder unsicher
    (db.cards||[]).forEach(c=>{
      if(c.examId === state.activeExamId) c.isSafe = false;
    });
    saveDB(db);
    buildSession();
    toast("cardsNotice","üéâ Alle Karten sicher! Neuer Durchgang startet automatisch.");
  }else{
    toast("cardsNotice","üü¢ Als sicher markiert");
  }

  // weiter mit n√§chster Karte
  try{ showCurrent(); }catch(_e){ try{ nextCard(); }catch(__){} }
}


/* ===== OVERRIDE: setCardSafeEnabled ohne disabled-Attribut (verhindert Klick-Block) ===== */
function setCardSafeEnabled(on){
  try{
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.classList.toggle("isDisabled", !on);
  }catch(_e){}
}


/* ===== Quiz: Buttons wie Karteikarten ===== */
function setQuizButtonsEnabled(on){
  try{
    ["quizUnsureBtn2","quizSafeBtn2"].forEach(id=>{
      const b = document.getElementById(id);
      if(b) b.classList.toggle("isDisabled", !on);
    });
  }catch(_e){}
}

function quizRequireAnswered(){
  if(!state.quiz.locked){
    toast("quizNotice","Erst eine Antwort w√§hlen.");
    return false;
  }
  return true;
}

function quizMarkWrong(){
  if(!quizRequireAnswered()) return;
  // keine Punkte
  state.quiz.locked = false;
  setQuizButtonsEnabled(false);
  // weiter
  if(state.quiz.ids.length){
    state.quiz.i = (state.quiz.i + 1) % state.quiz.ids.length;
  }
  renderQuiz();
}

function quizMarkRight(){
  if(!quizRequireAnswered()) return;
  try{ addPoint(); }catch(_e){}
  state.quiz.locked = false;
  setQuizButtonsEnabled(false);
  if(state.quiz.ids.length){
    state.quiz.i = (state.quiz.i + 1) % state.quiz.ids.length;
  }
  renderQuiz();
}

function quizMarkSafe(){
  if(!quizRequireAnswered()) return;

  const db = loadDB();
  const curId = state.quiz.ids[state.quiz.i];
  const q = (db.quiz||[]).find(x=>x.id===curId);
  if(!q){ toast("quizNotice","Frage nicht gefunden."); return; }

  q.isSafe = true;
  saveDB(db);
  try{ lt_markMastered("quiz", q.id); }catch(_e){}

  try{ incrementDailySecure(); }catch(_e){}

  // aus Pool entfernen
  state.quiz.ids = state.quiz.ids.filter(id=>id!==curId);
  if(state.quiz.i >= state.quiz.ids.length) state.quiz.i = 0;

  state.quiz.locked = false;
  setQuizButtonsEnabled(false);

  if(state.quiz.ids.length === 1){
    toast("quizNotice","‚ö†Ô∏è Letzte unsichere Frage in diesem Durchgang!");
  }

  if(state.quiz.ids.length === 0){
    // Reset: alle Quizfragen der Klausur wieder unsicher
    (db.quiz||[]).forEach(x=>{
      if(x.examId === state.activeExamId) x.isSafe = false;
    });
    saveDB(db);
    buildQuiz();
    toast("quizNotice","üéâ Alle Fragen sicher! Neuer Durchgang startet automatisch.");
  }

  renderQuiz();
}


/* ===== √úbersicht: wie viele insgesamt / sicher (Karteikarten + Quiz) ===== */
function computeCounts(){
  const db = loadDB();
  const ex = state.activeExamId;
  const cards = (db.cards||[]).filter(c=>c.examId===ex);
  const quiz  = (db.quiz||[]).filter(q=>q.examId===ex);
  const cardSafe = cards.filter(c=>!!c.isSafe).length;
  const quizSafe = quiz.filter(q=>!!q.isSafe).length;
  return {
    cardsTotal: cards.length,
    cardsSafe: cardSafe,
    cardsOpen: Math.max(0, cards.length-cardSafe),
    quizTotal: quiz.length,
    quizSafe: quizSafe,
    quizOpen: Math.max(0, quiz.length-quizSafe),
  };
}

function renderOverview(elId, label, total, safe, open){
  const el = document.getElementById(elId);
  if(!el) return;

  const t = Number(total)||0;
  const s = Number(safe)||0;
  const o = Number(open)||0;
  const pct = (t>0) ? Math.round((s/t)*100) : 0;

  el.innerHTML = `
    <div class="ovLeft">
      <div class="ovTitle">${label}</div>
      <div class="ovStats" aria-label="Statistik √úbersicht">
        <span class="ovChip"><span class="ovChipLabel">Gesamt</span><span class="ovChipVal">${t}</span></span>
        <span class="ovChip"><span class="ovChipLabel">Offen</span><span class="ovChipVal">${o}</span></span>
        <span class="ovChip"><span class="ovChipLabel">Sicher</span><span class="ovChipVal">${s}</span></span>
      </div>
    </div>
    <div class="ovRight">
      <div class="pill ovPill" title="Sicher gelernt">${pct}% ‚Ä¢ üü¢ Sicher: ${s}/${t || 0}</div>
      <div class="ovBar" aria-label="Fortschritt sicher gelernt">
        <div class="ovBarFill" style="width:${pct}%"></div>
      </div>
    </div>
  `;
}



// ===== Filter State + Chips =====
state.cardsFilter = state.cardsFilter || "open"; // default: wie bisher (nur offene Karten)
state.cardsSearch = state.cardsSearch || "";
state.quizSearch  = state.quizSearch  || "";

state.quizFilter  = state.quizFilter  || "open"; // default: wie bisher (nur offene Quizfragen)
state._filterRowOpen = state._filterRowOpen || { cards:false, quiz:false };

function toggleFilterRow(kind){
  try{
    state._filterRowOpen[kind] = !state._filterRowOpen[kind];
    const row = document.getElementById(kind==="cards" ? "cardsFilterRow" : "quizFilterRow");
    if(row) row.style.display = state._filterRowOpen[kind] ? "flex" : "none";
  }catch(_e){}
  refreshFilterUI(kind);
}

function setFilter(kind, value){
  if(kind==="cards") state.cardsFilter = value;
  if(kind==="quiz")  state.quizFilter  = value;
  refreshFilterUI(kind);

  if(kind==="cards"){
    try{ buildSession(); }catch(_e){}
    try{ showCurrent(); }catch(_e){}
  }else{
    try{ buildQuiz(); }catch(_e){}
    try{ renderQuiz(); }catch(_e){}
  }
}


function setSearch(kind, value){
  try{
    value = (value||"").toString();
    if(kind==="cards") state.cardsSearch = value;
    if(kind==="quiz")  state.quizSearch  = value;

    if(kind==="cards"){
      try{ buildSession(); }catch(_e){}
      try{ showCurrent(); }catch(_e){}
    }else{
      try{ buildQuiz(); }catch(_e){}
      try{ renderQuiz(); }catch(_e){}
    }
  }catch(_e){}
}
function refreshFilterUI(kind){
  const active = (kind==="cards") ? state.cardsFilter : state.quizFilter;
  const btn = document.getElementById(kind==="cards" ? "cardsFilterBtn" : "quizFilterBtn");
  const chips = document.querySelectorAll('.chip[data-kind="'+kind+'"]');

  chips.forEach(c=>{
    c.classList.toggle("active", c.getAttribute("data-filter")===active);
  });

  // Button wird nur gr√ºn, wenn Filter NICHT im Standard "open" steht
  const isActive = active !== "open";
  if(btn) btn.classList.toggle("on", isActive);
  try{
    if(kind==="cards"){
      const si=document.getElementById("cardsFilterRow_search");
      if(si) si.value = state.cardsSearch || "";
    }else{
      const si=document.getElementById("quizFilterRow_search");
      if(si) si.value = state.quizSearch || "";
    }
  }catch(_e){}
}

// on load: UI initialisieren (Standard: open = kein gr√ºnes Zeichen)
document.addEventListener("DOMContentLoaded", function(){
  try{ refreshFilterUI("cards"); }catch(_e){}
  try{ refreshFilterUI("quiz"); }catch(_e){}
});

function updateOverviews(){
  try{
    const c = computeCounts();
    renderOverview("cardsOverview","üìö Karteikarten-√úbersicht", c.cardsTotal, c.cardsSafe, c.cardsOpen);
    renderOverview("quizOverview","üß† Quiz-√úbersicht", c.quizTotal, c.quizSafe, c.quizOpen);
  }catch(_e){}
}


// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<section class="screen" id="sCreate" style="display:none">
<div class="topbar">
<button aria-label="Zur√ºck zur Modus√ºbersicht" class="btn ghost" onclick="lt_backToModes()" title="Zur√ºck zur Modus√ºbersicht" type="button">‚Üê Zur√ºck</button>
<div class="topbarTitle">
<div class="kTitle">Eigene Karten</div>
<div id="m2Badges">
<div class="m2Badge" title="Anzahl deiner selbst erstellten Karten in dieser Klausur"><span class="dot"></span><div><div><span class="num" id="ownCountBadge">0</span> <small>Karten</small></div><small>Eigene Karten</small></div></div>
<div class="m2Badge" title="Anzahl deiner selbst erstellten Quizfragen in dieser Klausur"><span class="dot" style="background:#8b5cf6;box-shadow:0 0 0 5px rgba(139,92,246,.18)"></span><div><div><span class="num" id="ownQuizCountBadge">0</span> <small>Quiz</small></div><small>Eigene Quizfragen</small></div></div>
<div class="m2Badge" title="Teilen-Warteschlange (offline), wird sp√§ter online synchronisiert."><span class="dot" style="background:#ffb454;box-shadow:0 0 0 5px rgba(255,180,84,.18)"></span><div><div><span class="num" id="shareQueueBadge">0</span> <small>offen</small></div><small>Teilen‚ÄëQueue</small></div></div>
<div class="m2Badge" title="Quelle/Folie: hilft beim Nachschlagen."><span class="dot" style="background:#8aa8ff;box-shadow:0 0 0 5px rgba(138,168,255,.18)"></span><div><div><span class="num">üìå</span> <small>Quelle</small></div><small>f√ºrs Nachlesen</small></div></div>
</div>
<div class="kSub">Eigene Karteikarten erstellen &amp; optional an die Klasse teilen</div>
<div style="margin-top:6px;font-size:12px;color:#666">üîí Klausurwechsel ist gesperrt, solange du hier bist.</div>
</div>
</div>
<div style="padding:0 16px 14px 16px">
<div style="display:flex;gap:10px;flex-wrap:wrap">
<button class="btn" id="m2TabCards" onclick="m2_setTab('cards')" type="button">üìö Karteikarten</button>
<button class="btn ghost" id="m2TabQuiz" onclick="m2_setTab('quiz')" type="button">üß† Quizkarten</button>
</div>
<div style="margin-top:8px;font-size:12px;color:#666">Hier erstellst du <b>nur</b> Karteikarten oder <b>nur</b> Quizkarten ‚Äì komplett getrennt.</div>
</div>
<di<div class="wrap" style="max-width:1100px;margin:0 auto;padding:16px">
<div id="m2CardsArea">
<div class="card" style="padding:16px;border-radius:18px">
<div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
<div style="font-weight:800;font-size:18px">‚úçÔ∏è Neue Karte erstellen</div>
<div id="createStatus" style="font-size:12px;color:#666"></div>
</div>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px">
<div>
<label style="font-size:12px;color:#555;font-weight:700">Vorderseite (Frage)</label>
<textarea class="input" id="ccFront" placeholder="Frage" rows="4"></textarea>
</div>
<div>
<label style="font-size:12px;color:#555;font-weight:700">R√ºckseite (Antwort)</label>
<textarea class="input" id="ccBack" placeholder="Antwort" rows="4"></textarea>
</div>
</div>
<div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-top:12px">
<div>
<label style="font-size:12px;color:#555;font-weight:700">Quelle (optional)</label>
<input class="input" id="ccSource" placeholder="z.B. Eigene Notiz / Buch / Folie "/>
</div>
<div>
<label style="font-size:12px;color:#555;font-weight:700">Folie (optional)</label>
<input class="input" id="ccSlide" placeholder="z.B. Folie 7"/>
</div>
<div style="display:flex;align-items:flex-end;gap:10px">
<label style="display:flex;align-items:center;gap:8px;font-size:13px;color:#444">
<input id="ccShare" type="checkbox"/>
            üë• direkt an Klasse teilen
          </label>
</div>
</div>
<div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:14px">
<button class="btn" onclick="createOwnCard()">‚úÖ Karte speichern</button>
<button class="btn ghost" onclick="clearOwnCardForm()">üßπ Leeren</button>
</div>
<div style="margin-top:14px;font-size:12px;color:#666">
        Hinweis: ‚ÄûAn Klasse teilen‚Äú speichert offline eine <b>Warteschlange</b> und kann sp√§ter online synchronisiert werden.
      </div>
</div>
<div class="card" style="padding:16px;border-radius:18px;margin-top:14px">
<div aria-expanded="false" id="ownCardsHeaderRow" role="button" style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;cursor:pointer" tabindex="0">
<div style="display:flex;align-items:center;gap:10px">
<button aria-expanded="false" id="toggleOwnCardsBtn" style="width:34px;height:34px;border-radius:12px;border:1px solid rgba(0,0,0,.08);background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.06);font-weight:900;font-size:16px;line-height:1;display:flex;align-items:center;justify-content:center;cursor:pointer" type="button">‚ñ∏</button>
<div style="font-weight:800;font-size:18px">üìö Deine Karten</div>
</div>
<div id="ownCount" style="font-size:12px;color:#666"></div>
</div>
<div id="ownCardsList" style="margin-top:10px;display:grid;grid-template-columns:1fr;gap:10px"></div>
</div>
</div>
<!-- /m2CardsArea -->
<div id="m2QuizArea" style="display:none">
<div class="card" style="padding:16px;border-radius:18px">
<div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
<div style="font-weight:800;font-size:18px">üß† Neue Quizfrage erstellen</div>
<div id="createQuizStatus" style="font-size:12px;color:#666"></div>
</div>
<div style="margin-top:12px">
<label style="font-size:12px;color:#555;font-weight:700">Frage</label>
<textarea class="input" id="m2qQuestion" placeholder="z.B. Was kennzeichnet affektive St√∂rungen?" rows="3"></textarea>
</div>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px">
<div>
<label style="font-size:12px;color:#555;font-weight:700">Antwort A</label>
<input class="input" id="m2qA0" placeholder="Antwort A"/>
</div>
<div>
<label style="font-size:12px;color:#555;font-weight:700">Antwort B</label>
<input class="input" id="m2qA1" placeholder="Antwort B"/>
</div>
<div>
<label style="font-size:12px;color:#555;font-weight:700">Antwort C</label>
<input class="input" id="m2qA2" placeholder="Antwort C"/>
</div>
<div>
<label style="font-size:12px;color:#555;font-weight:700">Antwort D</label>
<input class="input" id="m2qA3" placeholder="Antwort D"/>
</div>
</div>
<div style="margin-top:12px;display:flex;justify-content:space-between;align-items:flex-end;gap:12px;flex-wrap:wrap">
<div>
<div style="font-size:12px;color:#555;font-weight:700;margin-bottom:6px">Richtige Antwort</div>
<div style="display:flex;gap:10px;flex-wrap:wrap">
<label style="display:flex;align-items:center;gap:6px;font-size:13px"><input checked="" name="m2qCorrect" type="radio" value="0"/> A</label>
<label style="display:flex;align-items:center;gap:6px;font-size:13px"><input name="m2qCorrect" type="radio" value="1"/> B</label>
<label style="display:flex;align-items:center;gap:6px;font-size:13px"><input name="m2qCorrect" type="radio" value="2"/> C</label>
<label style="display:flex;align-items:center;gap:6px;font-size:13px"><input name="m2qCorrect" type="radio" value="3"/> D</label>
</div>
</div>
<label style="display:flex;align-items:center;gap:8px;font-size:13px;color:#444">
<input id="m2qShare" type="checkbox"/>
        üë• direkt an Klasse teilen
      </label>
</div>
<div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:14px">
<button class="btn" onclick="createOwnQuiz()" type="button">‚úÖ Quizfrage speichern</button>
<button class="btn ghost" onclick="clearOwnQuizForm()" type="button">üßπ Leeren</button>
</div>
<div style="margin-top:14px;font-size:12px;color:#666">
      Tipp: Achte darauf, dass die richtige Antwort nicht immer die l√§ngste ist üòâ
    </div>
</div>
<div class="card" style="padding:16px;border-radius:18px;margin-top:14px">
<div aria-expanded="false" id="ownQuizHeaderRow" role="button" style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;cursor:pointer" tabindex="0">
<div style="display:flex;align-items:center;gap:10px">
<button class="miniBtn" id="toggleOwnQuizBtn" style="width:34px;height:34px;border-radius:10px;border:1px solid rgba(0,0,0,.08);background:rgba(255,255,255,.7);box-shadow:0 6px 16px rgba(0,0,0,.06);cursor:pointer">‚ñ∏</button>
<div style="font-weight:800;font-size:18px">üß† Deine Quizkarten</div>
</div>
<div id="ownQuizCount" style="font-size:12px;color:#666"></div>
</div>
<div id="ownQuizList" style="margin-top:10px;display:none;grid-template-columns:1fr;gap:10px"></div>
</div>
</div><!-- /m2QuizArea -->
</di<div></section>
<script>
/* =========================
   Eigene Karten (SAFE v24)
   Ziel: Speichern + Teilen ohne andere Modi zu zerst√∂ren.
   Alles defensiv mit try/catch.
========================= */
(function(){
  function safeJsonParse(x, fallback){
    try{ return JSON.parse(x); }catch(e){ return fallback; }
  }
  function getExamId(){
    try{
      if(window.state && state.activeExamId) return state.activeExamId;
    }catch(e){}
    try{
      return localStorage.getItem("currentExamId") || "default";
    }catch(e){ return "default"; }
  }
  function escapeHtml(str){
    str = (str==null) ? "" : String(str);
    return str
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#039;");
  }
  function loadDBSafe(){
    try{
      if(typeof window.loadDB === "function") return window.loadDB();
    }catch(e){}
    // fallback
    try{
      var raw = localStorage.getItem("lt_db_v1") || "{}";
      var db = safeJsonParse(raw, {});
      if(!db || typeof db !== "object") db = {};
      if(!Array.isArray(db.cards)) db.cards = [];
      if(!Array.isArray(db.quiz)) db.quiz = [];
      return db;
    }catch(e){
      return {cards:[], quiz:[]};
    }
  }
  function saveDBSafe(db){
    try{
      if(typeof window.saveDB === "function"){ window.saveDB(db); return; }
    }catch(e){}
    try{
      localStorage.setItem("lt_db_v1", JSON.stringify(db||{}));
    }catch(e){}
  }

  // Ensure showSection exists (some versions lost it)
  if(typeof window.showSection !== "function"){
    window.showSection = function(id){
      try{
        var screens = document.querySelectorAll(".screen");
        for(var i=0;i<screens.length;i++) screens[i].style.display="none";
        var el = document.getElementById(id);
        if(el) el.style.display="block";
        window.scrollTo(0,0);
      }catch(e){}
    };
  }

  // Robust openMode patch (only if missing mode 2)
  if(typeof window.openMode === "function"){
    var openModeOrig = window.openMode;
    window.openMode = function(n){
      try{
        if(n===2){
          window.showSection("sCreate");
          try{ window.renderOwnCards && window.renderOwnCards(); }catch(e){}
          return;
        }
      }catch(e){}
      try{ return openModeOrig(n); }catch(e){}
    };
  }

  // Expose functions used by inline onclick
  window.clearOwnCardForm = function(){
    try{
      var f=document.getElementById("ccFront");
      var b=document.getElementById("ccBack");
      var s=document.getElementById("ccSource");
      var sl=document.getElementById("ccSlide");
      var sh=document.getElementById("ccShare");
      if(f) f.value="";
      if(b) b.value="";
      if(s) s.value="";
      if(sl) sl.value="";
      if(sh) sh.checked=false;
      var st=document.getElementById("createStatus");
      if(st) st.textContent="";
    }catch(e){}
  };

  window.createOwnCard = function(){
    try{
      var front = (document.getElementById("ccFront")||{}).value || "";
      var back  = (document.getElementById("ccBack")||{}).value || "";
      var source= (document.getElementById("ccSource")||{}).value || "";
      var slide = (document.getElementById("ccSlide")||{}).value || "";
      var share = !!((document.getElementById("ccShare")||{}).checked);
      front = front.trim(); back = back.trim(); source=source.trim(); slide=slide.trim();

      var st=document.getElementById("createStatus");
      if(!front || !back){
        if(st) st.textContent="‚ö†Ô∏è Bitte Frage UND Antwort ausf√ºllen.";
        return;
      }

      var db = loadDBSafe();
      var examId = getExamId();
      var id = "u_" + Date.now() + "_" + Math.floor(Math.random()*1000000);

      var card = {
        id: id,
        examId: examId,
        front: front,
        back: back,
        userCreated: true,
        fav: false,
        isSafe: false,
        sourceText: (source || "Eigene Karte") + (slide ? (" ‚Ä¢ " + slide) : ""),
        sharedClass: false,
        sharedAt: null,
        createdAt: Date.now()
      };

      db.cards.push(card);

      if(share){
        card.sharedClass = true;
        card.sharedAt = Date.now();
        // optional outbox for later online sync
        try{
          var raw = localStorage.getItem("lt_share_outbox") || "[]";
          var out = safeJsonParse(raw, []);
          if(!Array.isArray(out)) out = [];
          out.push({
            kind:"card",
            examId: examId,
            id: id,
            front: front,
            back: back,
            sourceText: card.sourceText,
            createdAt: card.createdAt
          });
          localStorage.setItem("lt_share_outbox", JSON.stringify(out));
        }catch(e){}
      }

      saveDBSafe(db);

      if(st) st.textContent = share ? "‚úÖ gespeichert + geteilt" : "‚úÖ gespeichert";
      window.clearOwnCardForm();
      try{ window.renderOwnCards(); }catch(e){}

      try{ if(typeof window.updateModeCounts==="function") window.updateModeCounts(); }catch(e){}
    }catch(e){
      try{
        var st=document.getElementById("createStatus");
        if(st) st.textContent="‚ö†Ô∏è Fehler beim Speichern.";
      }catch(_e){}
    }
  };

  window.renderOwnCards = function(){
    try{
      var list=document.getElementById("ownCardsList");
      var countEl=document.getElementById("ownCount");
      var quizCountEl=document.getElementById("ownQuizCount");
      var countBadge=document.getElementById("ownCountBadge");
      var quizCountBadge=document.getElementById("ownQuizCountBadge");
      if(!list) return;

      var db=loadDBSafe();
      var examId=getExamId();
      var all=[];
      for(var i=0;i<db.cards.length;i++){
        var c=db.cards[i];
        if(c && c.userCreated && c.examId===examId) all.push(c);
      }
      if(countEl) countEl.textContent = all.length + " Karten";
      if(countBadge) countBadge.textContent = all.length + " Karten";

      // Quizfragen z√§hlen (eigene)
      var qAll=[];
      if(db && Array.isArray(db.quiz)){
        for(var qi=0;qi<db.quiz.length;qi++){
          var qq=db.quiz[qi];
          if(qq && qq.userCreated && qq.examId===examId) qAll.push(qq);
        }
      }
      if(quizCountEl) quizCountEl.textContent = qAll.length + " Quiz";
      if(quizCountBadge) quizCountBadge.textContent = qAll.length + " Quiz";

      list.innerHTML="";
      if(!all.length){
        var empty=document.createElement("div");
        empty.className="notice";
        empty.textContent="Noch keine eigenen Karten ‚Äì erstelle oben deine erste Karte.";
        list.appendChild(empty);
        return;
      }

      // newest first
      all.sort(function(a,b){ return (b.createdAt||0)-(a.createdAt||0); });

      for(var j=0;j<all.length;j++){
        (function(card){
          var row=document.createElement("div");
          row.style.padding="12px";
          row.style.borderRadius="14px";
          row.style.border="1px solid rgba(0,0,0,.07)";
          row.style.background="rgba(255,255,255,.6)";

          var top=document.createElement("div");
          top.style.display="flex";
          top.style.justifyContent="space-between";
          top.style.gap="10px";
          top.style.alignItems="flex-start";
          top.style.flexWrap="wrap";

          var left=document.createElement("div");
          left.style.flex="1";
          left.innerHTML =
            '<div style="font-weight:800">'+escapeHtml(card.front)+'</div>' +
            '<div style="margin-top:4px;color:#555">'+escapeHtml(card.back)+'</div>' +
            '<div style="margin-top:6px;font-size:12px;color:#777">'+escapeHtml(card.sourceText||"Eigene Karte")+'</div>';

          var right=document.createElement("div");
          right.style.display="flex";
          right.style.gap="8px";
          right.style.flexWrap="wrap";

          var btnShare=document.createElement("button");
          btnShare.className="btn ghost";
          btnShare.textContent = card.sharedClass ? "üë• geteilt" : "üë• teilen";
          btnShare.onclick=function(){
            try{
              var db2=loadDBSafe();
              for(var k=0;k<db2.cards.length;k++){
                if(db2.cards[k] && db2.cards[k].id===card.id){
                  db2.cards[k].sharedClass=true;
                  db2.cards[k].sharedAt=Date.now();
                  break;
                }
              }
              saveDBSafe(db2);
              window.renderOwnCards();
              try{ if(typeof window.updateModeCounts==="function") window.updateModeCounts(); }catch(e){}
            }catch(e){}
          };

          var btnDel=document.createElement("button");
          btnDel.className="btn ghost";
          btnDel.textContent="üóëÔ∏è l√∂schen";
          btnDel.onclick=function(){
            try{
              var db2=loadDBSafe();
              var next=[];
              for(var k=0;k<db2.cards.length;k++){
                var c=db2.cards[k];
                if(c && c.id!==card.id) next.push(c);
              }
              db2.cards = next;
              saveDBSafe(db2);
              window.renderOwnCards();
              try{ if(typeof window.updateModeCounts==="function") window.updateModeCounts(); }catch(e){}
            }catch(e){}
          };

          right.appendChild(btnShare);
          right.appendChild(btnDel);

          top.appendChild(left);
          top.appendChild(right);
          row.appendChild(top);
          list.appendChild(row);
        })(all[j]);
      }
    }catch(e){}
  };

  // Auto-render if we are already on mode 2
  document.addEventListener("DOMContentLoaded", function(){
    try{
      var sec=document.getElementById("sCreate");
      if(sec && sec.style.display!=="none"){
        window.renderOwnCards();
      }
    }catch(e){}
  });
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
// Back-button safety binder (v26)
document.addEventListener("DOMContentLoaded", function(){
  try{
    var btns = document.querySelectorAll("button.btn.ghost");
    for(var i=0;i<btns.length;i++){
      var b = btns[i];
      var txt = (b.textContent||"").trim();
      if(txt === "‚Üê Zur√ºck"){
        // ensure it is not a submit button
        b.setAttribute("type","button");
      }
    }
  }catch(e){}
});

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
// Global BACK handler (v28) ‚Äì context-aware:
// - inside a mode -> go to Modes (sMode)
// - already on Modes -> go to Klausur-Auswahl (sExam)
// - on Klausur-Auswahl -> go to Name/Login (sName)
(function(){
  function visibleScreenId(){
    try{
      var screens = document.querySelectorAll(".screen");
      for(var i=0;i<screens.length;i++){
        var s = screens[i];
        if(s && s.style.display !== "none"){
          // some screens might be visible via empty style; check offsetParent too
          if(s.offsetParent !== null) return s.id;
        }
      }
      // fallback: first non-none
      for(var i2=0;i2<screens.length;i2++){
        var s2 = screens[i2];
        if(s2 && s2.style.display !== "none") return s2.id;
      }
    }catch(e){}
    return null;
  }

  // ensure showSection exists
  if(typeof window.showSection !== "function"){
    window.showSection = function(id){
      try{
        var screens = document.querySelectorAll(".screen");
        for(var i=0;i<screens.length;i++) screens[i].style.display="none";
        var el = document.getElementById(id);
        if(el) el.style.display="block";
        window.scrollTo(0,0);
      }catch(e){}
    };
  }

  document.addEventListener("click", function(ev){
    try{
      var btn = ev.target && ev.target.closest ? ev.target.closest("button") : null;
      if(!btn) return;
      var txt = (btn.textContent||"").replace(/\s+/g," ").trim();
      if(txt !== "‚Üê Zur√ºck") return;

      ev.preventDefault();
      ev.stopPropagation();

      var cur = visibleScreenId();
      if(cur === "sMode"){
        window.showSection("sExam");
      }else if(cur === "sExam"){
        if(typeof window.enterNameStep==="function"){ window.enterNameStep(); } else { window.showSection("sName"); }
      }else{
        window.showSection("sMode");
      }
      try{ if(typeof window.updateModeCounts==="function") window.updateModeCounts(); }catch(e){}
    }catch(e){}
  }, true);
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
// goFromName FIX (v29) ‚Äì robust, no-crash, always navigates
(function(){
  function safeTrim(v){ try{ return String(v||"").trim(); }catch(e){ return ""; } }
  function safeToast(id,msg){
    try{ if(typeof window.toast==="function"){ window.toast(id,msg); return; } }catch(e){}
    try{
      var el=document.getElementById(id);
      if(el){ el.textContent = msg; el.style.display="block"; }
    }catch(e){}
  }
  function safeShow(id){
    try{ if(typeof window.show==="function"){ window.show(id); return; } }catch(e){}
    try{ if(typeof window.showSection==="function"){ window.showSection(id); return; } }catch(e){}
    try{ var el=document.getElementById(id); if(el) el.style.display="block"; }catch(e){}
  }

  window.goFromName = function(){
    try{
      var inp = document.getElementById("nameInput");
      var name = safeTrim(inp && inp.value);
      if(!name){ safeToast("nameNotice","Bitte Namen eingeben."); return; }

      // state
      try{ if(typeof state!=='undefined') state.name = name; }catch(e){}
      try{ if(window.state) window.state.name = name; }catch(e){}
      // persist
      try{ if(typeof window.NAME_KEY!=="undefined"){ localStorage.setItem(window.NAME_KEY, name); }
           else localStorage.setItem("lerntool_name_v1", name);
      }catch(e){}

      // header
      try{ var h=document.getElementById("hdrName1"); if(h) h.textContent=name; }catch(e){}

      // render exams (optional)
      try{ if(typeof window.renderExams==="function") window.renderExams(); }catch(e){}

      // navigate
      safeShow("sExam");
    }catch(e){
      // last resort: still navigate
      try{ safeShow("sExam"); }catch(_e){}
    }
  };

  // Extra safety: bind click handler to the "Weiter" button on sName
  document.addEventListener("DOMContentLoaded", function(){
    try{
      var sName=document.getElementById("sName");
      if(!sName) return;
      var btns=sName.querySelectorAll("button");
      for(var i=0;i<btns.length;i++){
        var b=btns[i];
        var t=(b.textContent||"").trim();
        if(t==="Weiter"){
          b.setAttribute("type","button");
          b.onclick = window.goFromName;
        }
      }
    }catch(e){}
  });
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
// Global WEITER handler (v32) ‚Äì makes "Weiter" on Name screen always work, even after navigating back
(function(){
  function visibleScreenId(){
    try{
      var screens = document.querySelectorAll(".screen");
      for(var i=0;i<screens.length;i++){
        var s = screens[i];
        if(s && s.style.display !== "none" && s.offsetParent !== null) return s.id;
      }
      for(var j=0;j<screens.length;j++){
        var s2 = screens[j];
        if(s2 && s2.style.display !== "none") return s2.id;
      }
    }catch(e){}
    return null;
  }

  // ensure goFromName exists (fallback)
  if(typeof window.goFromName !== "function"){
    window.goFromName = function(){
      try{
        var inp = document.getElementById("nameInput");
        var name = (inp && inp.value ? String(inp.value).trim() : "");
        if(!name){
          try{
            var n=document.getElementById("nameNotice");
            if(n) n.textContent="Bitte Namen eingeben.";
          }catch(e){}
          return;
        }
        try{ if(window.state) window.state.name = name; }catch(e){}
        try{ localStorage.setItem("lerntool_name_v1", name); }catch(e){}
        try{ if(typeof window.renderExams==="function") window.renderExams(); }catch(e){}
        try{ if(typeof window.showSection==="function") window.showSection("sExam"); else if(typeof window.show==="function") window.show("sExam"); }catch(e){}
      }catch(e){}
    };
  }

  // ensure Weiter buttons are not submit
  function normalizeWeiterButtons(){
    try{
      var sName = document.getElementById("sName");
      if(!sName) return;
      var btns = sName.querySelectorAll("button");
      for(var i=0;i<btns.length;i++){
        var b=btns[i];
        var t=(b.textContent||"").replace(/\s+/g," ").trim();
        if(t==="Weiter"){
          b.setAttribute("type","button");
        }
      }
    }catch(e){}
  }

  document.addEventListener("DOMContentLoaded", normalizeWeiterButtons);
  // also after any click that might switch screens
  document.addEventListener("click", function(){ setTimeout(normalizeWeiterButtons, 0); }, true);

  // capture clicks on "Weiter" when we're on name screen
  document.addEventListener("click", function(ev){
    try{
      var btn = ev.target && ev.target.closest ? ev.target.closest("button") : null;
      if(!btn) return;
      var txt = (btn.textContent||"").replace(/\s+/g," ").trim();
      if(txt !== "Weiter") return;
      var cur = visibleScreenId();
      if(cur !== "sName") return;

      ev.preventDefault();
      ev.stopPropagation();
      window.goFromName();
    }catch(e){}
  }, true);
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
// Name-Weiter HARD FIX (v33) ‚Äì direct bind + Enter key + direct navigation fallback
(function(){
  function ensureShowSection(){
    if(typeof window.showSection !== "function"){
      window.showSection = function(id){
        try{
          var screens = document.querySelectorAll(".screen");
          for(var i=0;i<screens.length;i++) screens[i].style.display="none";
          var el = document.getElementById(id);
          if(el) el.style.display="block";
          window.scrollTo(0,0);
        }catch(e){}
      };
    }
  }

  function doNameNext(){
    try{
      var inp = document.getElementById("nameInput");
      var name = (inp && inp.value ? String(inp.value).trim() : "");
      if(!name){
        var n = document.getElementById("nameNotice");
        if(n) n.textContent = "Bitte Namen eingeben.";
        return;
      }
      try{ if(window.state) window.state.name = name; }catch(e){}
      try{ localStorage.setItem("lerntool_name_v1", name); }catch(e){}
      try{ var h=document.getElementById("hdrName1"); if(h) h.textContent=name; }catch(e){}
      try{ if(typeof window.renderExams==="function") window.renderExams(); }catch(e){}
      ensureShowSection();
      window.showSection("sExam");
    }catch(e){
      ensureShowSection();
      try{ window.showSection("sExam"); }catch(_e){}
    }
  }

  function bind(){
    try{
      var btn = document.getElementById("nameNextBtn");
      if(btn){
        btn.setAttribute("type","button");
        // hard override (some browsers ignore inline after DOM changes)
        btn.onclick = function(ev){ try{ ev && ev.preventDefault && ev.preventDefault(); }catch(e){} doNameNext(); };
      }
      var inp = document.getElementById("nameInput");
      if(inp){
        inp.onkeydown = function(ev){
          try{
            if(ev && (ev.key==="Enter" || ev.keyCode===13)){
              ev.preventDefault();
              doNameNext();
            }
          }catch(e){}
        };
      }
    }catch(e){}
  }

  document.addEventListener("DOMContentLoaded", bind);
  // Re-bind after any navigation click (especially after back)
  document.addEventListener("click", function(){ setTimeout(bind, 0); }, true);
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
// showSection upgrade (v34): ensures only one screen visible + clickability
(function(){
  function hideAll(){
    try{
      var screens=document.querySelectorAll(".screen");
      for(var i=0;i<screens.length;i++){
        screens[i].style.display="none";
        screens[i].style.pointerEvents="none";
      }
    }catch(e){}
  }
  var orig = (typeof window.showSection==="function") ? window.showSection : null;
  window.showSection = function(id){
    try{ hideAll(); }catch(e){}
    try{
      var el=document.getElementById(id);
      if(el){
        el.style.display="block";
        el.style.pointerEvents="auto";
      }
      window.scrollTo(0,0);
    }catch(e){}
    // rebind Weiter after showing name screen
    try{
      if(id==="sName"){
        var btn=document.getElementById("nameNextBtn");
        if(btn){ btn.setAttribute("type","button"); }
      }
    }catch(e){}
    try{ if(typeof window.updateModeCounts==="function") window.updateModeCounts(); }catch(e){}
    try{ if(orig && orig!==window.showSection){ /* no-op */ } }catch(e){}
  };
  if(typeof window.show!=="function"){
    window.show = function(id){ window.showSection(id); };
  }
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
// showSection override (v35) ‚Äì force z-index + pointer-events + only one visible
(function(){
  function allScreens(){
    try{ return document.querySelectorAll(".screen"); }catch(e){ return []; }
  }
  window.showSection = function(id){
    try{
      var screens = allScreens();
      for(var i=0;i<screens.length;i++){
        screens[i].style.display="none";
        screens[i].style.pointerEvents="none";
        screens[i].style.zIndex="0";
      }
      var el = document.getElementById(id);
      if(el){
        el.style.display="block";
        el.style.pointerEvents="auto";
        el.style.zIndex="50";
      }
      // extra: ensure name screen is always on top and clickable
      if(id==="sName"){
        try{
          el.style.zIndex="200";
          var btn=document.getElementById("nameNextBtn");
          if(btn){
            btn.style.pointerEvents="auto";
            btn.style.zIndex="220";
            btn.disabled = false;
          }
        }catch(e){}
      }
      window.scrollTo(0,0);
    }catch(e){}
    try{ if(typeof window.updateModeCounts==="function") window.updateModeCounts(); }catch(e){}
  };
  if(typeof window.show!=="function"){
    window.show = function(id){ window.showSection(id); };
  }
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
// NameNext direct capture (v35)
(function(){
  function doNext(){
    try{
      if(typeof window.goFromName==="function") return window.goFromName();
    }catch(e){}
  }
  document.addEventListener("click", function(ev){
    try{
      var t = ev.target;
      if(!t) return;
      var btn = t.closest ? t.closest("#nameNextBtn") : null;
      if(btn){
        ev.preventDefault(); ev.stopPropagation();
        doNext();
      }
    }catch(e){}
  }, true);
  document.addEventListener("touchend", function(ev){
    try{
      var t = ev.target;
      if(!t) return;
      var btn = t.closest ? t.closest("#nameNextBtn") : null;
      if(btn){
        ev.preventDefault(); ev.stopPropagation();
        doNext();
      }
    }catch(e){}
  }, {capture:true, passive:false});
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
// enterNameStep (v36) ‚Äì re-initializes the name/login step so "Weiter" works after navigating back
(function(){
  function safeFocus(el){ try{ el.focus(); }catch(e){} }
  window.enterNameStep = function(){
    try{
      // Reset key parts of state so flow is consistent
      if(window.state){
        try{ state.currentMode = null; }catch(e){}
        try{ state.activeExamId = null; }catch(e){}
      }
    }catch(e){}

    // Show name screen
    try{
      if(typeof window.showSection === "function") if(typeof window.enterNameStep==="function"){ window.enterNameStep(); } else { window.showSection("sName"); }
      else if(typeof window.show === "function") if(typeof window.enterNameStep==="function"){ window.enterNameStep(); } else { window.show("sName"); }
    }catch(e){}

    // Ensure input is enabled and focused
    try{
      var inp = document.getElementById("nameInput");
      if(inp){
        inp.disabled = false;
        // set value from storage if missing
        try{
          if(!String(inp.value||"").trim()){
            var saved = localStorage.getItem("lerntool_name_v1") || localStorage.getItem("NAME") || "";
            if(saved) inp.value = saved;
          }
        }catch(e){}
        safeFocus(inp);
      }
    }catch(e){}

    // Clear notice
    try{
      var n = document.getElementById("nameNotice");
      if(n) n.textContent = "";
    }catch(e){}

    // Re-bind the Weiter button (in case handlers were lost)
    try{
      var btn = document.getElementById("nameNextBtn");
      if(btn){
        btn.disabled = false;
        btn.setAttribute("type","button");
        btn.onclick = function(ev){ try{ ev && ev.preventDefault && ev.preventDefault(); }catch(e){} try{ window.goFromName && window.goFromName(); }catch(e){} };
      }
    }catch(e){}
  };
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
// v37: enterExamStep + ensure exam screen is initialized on every visit
(function(){
  window.enterExamStep = function(){
    try{
      if(typeof window.showSection==="function") window.showSection("sExam");
      else if(typeof window.show==="function") window.show("sExam");
    }catch(e){}
    try{ if(typeof window.renderExams==="function") window.renderExams(); }catch(e){}
    try{
      if(!window.state) return;
      if(!state.activeExamId){
        try{
          var db = (typeof window.loadDB==="function") ? window.loadDB() : null;
          if(db && db.exams && db.exams[0]) state.activeExamId = db.exams[0].id;
        }catch(e){}
      }
    }catch(e){}
  };

  // Patch showSection so returning to sExam always refreshes list + selection
  var prevShowSection = window.showSection;
  window.showSection = function(id){
    try{ prevShowSection && prevShowSection(id); }catch(e){}
    try{
      if(id==="sExam"){ window.enterExamStep(); }
    }catch(e){}
  };
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
// v37: Capture-handler for Exam "Weiter" (Android safe)
(function(){
  function go(){
    try{
      if(typeof window.goToMode==="function") window.goToMode();
    }catch(e){}
  }
  function isExamWeiter(t){
    try{
      var btn = t.closest ? t.closest("button") : null;
      if(!btn) return false;
      if(btn.id==="examNextBtn") return true;
      // match the exact onclick
      var oc = btn.getAttribute("onclick") || "";
      if(oc.indexOf("goToMode")>=0) return true;
      if(btn.textContent && btn.textContent.trim()==="Weiter"){
        // only when inside sExam
        return !!(btn.closest && btn.closest("#sExam"));
      }
    }catch(e){}
    return false;
  }
  document.addEventListener("click", function(ev){
    if(isExamWeiter(ev.target)){
      ev.preventDefault(); ev.stopPropagation();
      go();
    }
  }, true);
  document.addEventListener("touchend", function(ev){
    if(isExamWeiter(ev.target)){
      ev.preventDefault(); ev.stopPropagation();
      go();
    }
  }, {capture:true, passive:false});
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
// v38: fix recursion in v37 showSection patch + robust exam init
(function(){
  // keep reference to current showSection (from v35)
  var base = window.showSection;
  if(!base) return;

  function ensureExamSelected(){
    try{
      if(!window.state) return;
      if(state.activeExamId) return;
      var db = null;
      try{ db = (typeof window.loadDB==="function") ? window.loadDB() : null; }catch(e){}
      if(db && Array.isArray(db.exams) && db.exams.length){
        state.activeExamId = db.exams[0].id;
        // highlight selection if UI supports it
        try{
          if(typeof window.renderExams==="function") window.renderExams();
        }catch(e){}
      }
    }catch(e){}
  }

  // replace showSection with non-recursive wrapper
  window.showSection = function(id){
    try{ base(id); }catch(e){}
    try{
      if(id === "sExam"){
        try{ if(typeof window.renderExams==="function") window.renderExams(); }catch(e){}
        ensureExamSelected();
      }
      if(id === "sName"){
        // keep name step consistent after back
        try{ if(typeof window.enterNameStep==="function") window.enterNameStep(); }catch(e){}
      }
    }catch(e){}
  };

  // also ensure first time we land on sExam, selection exists
  try{
    var cur = document.querySelector(".screen.active");
    if(cur && cur.id === "sExam"){
      try{ if(typeof window.renderExams==="function") window.renderExams(); }catch(e){}
      ensureExamSelected();
    }
  }catch(e){}
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
// v39: robust click binding for Exam "Weiter" (no closest dependency)
(function(){
  function bindExamWeiter(){
    var btn = document.getElementById("examNextBtn");
    if(!btn) return;
    // avoid double-binding
    if(btn._boundV39) return;
    btn._boundV39 = true;
    var handler = function(ev){
      try{ ev && ev.preventDefault && ev.preventDefault(); }catch(e){}
      try{ ev && ev.stopPropagation && ev.stopPropagation(); }catch(e){}
      try{ if(typeof window.goToMode==="function") window.goToMode(); }catch(e){}
      return false;
    };
    btn.addEventListener("click", handler, true);
    btn.addEventListener("touchend", handler, {capture:true, passive:false});
  }

  // patch show() to re-bind every time sExam becomes visible
  var _show = window.show;
  window.show = function(id){
    try{ _show && _show(id); }catch(e){}
    try{
      if(id==="sExam"){
        try{ if(typeof window.renderExams==="function") window.renderExams(); }catch(e){}
        bindExamWeiter();
      }
      if(id==="sName"){
        try{ if(typeof window.enterNameStep==="function") window.enterNameStep(); }catch(e){}
      }
    }catch(e){}
  };

  if(document.readyState==="loading"){
    document.addEventListener("DOMContentLoaded", function(){
      bindExamWeiter();
    });
  }else{
    bindExamWeiter();
  }
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<button id="dbgBtn" type="button">Debug</button>
<div id="dbgErr"><b>Fehler erkannt</b><div id="dbgErrMsg">‚Äì</div></div>
<div aria-live="polite" id="dbgWrap">
<div id="dbgHead">Debug-Protokoll <span id="dbgBadge">v41</span></div>
<div id="dbgBody">Start</div>
</div>
<script>
// v40: deterministic logging + global error capture
(function(){
  const $ = (id)=>document.getElementById(id);
  const wrap = $("dbgWrap"), body = $("dbgBody"), btn=$("dbgBtn"), err=$("dbgErr"), errMsg=$("dbgErrMsg");
  function log(msg){
    try{
      const t = new Date().toISOString().slice(11,19);
      body.textContent += "\n[" + t + "] " + msg;
      body.scrollTop = body.scrollHeight;
    }catch(e){}
  }
  function showErr(title, detail){
    try{
      err.style.display="block";
      errMsg.textContent = (title||"") + (detail?(" ‚Äî " + detail):"");
      log("ERROR: " + errMsg.textContent);
    }catch(e){}
  }
  window.__dbgLog = log;
  window.addEventListener("error", function(e){
    try{ showErr(e.message||"JS-Error", (e.filename||"") + ":" + (e.lineno||"") ); }catch(_){}
  });
  window.addEventListener("unhandledrejection", function(e){
    try{ showErr("Promise-Rejection", (e.reason && (e.reason.message||String(e.reason))) || "unknown"); }catch(_){}
  });
  if(btn){
    btn.addEventListener("click", ()=>{
      if(!wrap) return;
      wrap.style.display = (wrap.style.display==="none" || !wrap.style.display) ? "block" : "none";
    });
  }
  log("Init ok. UA=" + navigator.userAgent);
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
// v41: stable Exam/Weiter fix (no recursion), keeps all existing features
(function(){
  const $ = (id)=>document.getElementById(id);
  function log(m){ try{ window.__dbgLog && window.__dbgLog(m); }catch(e){} }

  // --- guards against re-entrancy / call-stack overflows ---
  let __examEnterLock = false;
  let __renderExamsLock = false;
  let __bindLock = false;

  function loadDBSafe(){
    try{ return (typeof window.loadDB==="function") ? window.loadDB() : null; }
    catch(e){ log("loadDB error: "+e.message); return null; }
  }

  function safeRenderExams(){
    if(__renderExamsLock) { log("safeRenderExams skipped (lock)"); return; }
    __renderExamsLock = true;
    try{
      if(typeof window.renderExams==="function"){
        window.renderExams();
        log("renderExams() ausgef√ºhrt (safe)");
      }else{
        log("renderExams() fehlt (ok)");
      }
    }catch(e){
      log("renderExams crash: " + e.message);
    }finally{
      __renderExamsLock = false;
    }
  }

  function ensureActiveExam(){
    try{
      if(!window.state) window.state = {};
      if(state.activeExamId) return state.activeExamId;

      const db = loadDBSafe();
      if(db && Array.isArray(db.exams) && db.exams.length){
        state.activeExamId = db.exams[0].id;
        log("activeExamId gesetzt (db.exams[0]): " + state.activeExamId);
        return state.activeExamId;
      }

      const sel = document.querySelector('[data-exam-id].selected,[data-exam-id][aria-selected="true"]');
      if(sel){
        state.activeExamId = sel.getAttribute("data-exam-id");
        log("activeExamId gesetzt (DOM selected): " + state.activeExamId);
        return state.activeExamId;
      }

      const any = document.querySelector('[data-exam-id]');
      if(any){
        state.activeExamId = any.getAttribute("data-exam-id");
        log("activeExamId gesetzt (DOM first): " + state.activeExamId);
        try{ any.classList.add("selected"); any.setAttribute("aria-selected","true"); }catch(e){}
        return state.activeExamId;
      }

      log("activeExamId NICHT setzbar (keine exams gefunden).");
      return null;
    }catch(e){
      log("ensureActiveExam crash: " + e.message);
      return null;
    }
  }

  function goToModeSafe(){
    try{
      const id = ensureActiveExam();
      if(!id){
        alert("Keine Klausur gefunden/ausgew√§hlt. Bitte erst eine Klausur anlegen oder pr√ºfen ob die Liste geladen ist.");
        log("Weiter abgebrochen: keine activeExamId.");
        return;
      }
      // IMPORTANT: do NOT call renderExams here (prevents recursion)
      if(typeof window.goToMode==="function"){
        log("goToMode() mit activeExamId=" + id);
        return window.goToMode();
      }
      log("goToMode fehlt -> fallback showSection(sMode)");
      if(typeof window.showSection==="function") window.showSection("sMode");
      else if(typeof window.show==="function") window.show("sMode");
    }catch(e){
      log("goToModeSafe crash: "+e.message);
      alert("Fehler beim Weiter: " + e.message);
    }
  }

  function bindExamWeiter(){
    if(__bindLock){ log("bindExamWeiter skipped (lock)"); return; }
    __bindLock = true;

    try{
      const sExam = $("sExam") || document.getElementById("sExam");
      if(!sExam){ log("bindExamWeiter: sExam nicht gefunden"); return; }

      // locate Weiter button robustly
      let btn = document.getElementById("examNextBtn");
      if(!btn){
        const cands = Array.from(sExam.querySelectorAll("button"));
        btn = cands.find(b => (b.textContent||"").trim()==="Weiter") || null;
        if(btn) btn.id = "examNextBtn";
      }
      if(!btn){ log("bindExamWeiter: Weiter-Button nicht gefunden"); return; }

      // ensure clickable
      btn.disabled = false;
      btn.type = "button";
      btn.style.pointerEvents = "auto";
      btn.style.zIndex = 9999;

      // remove potential duplicated listeners by overwriting handlers
      btn.onclick = function(ev){
        try{ ev && ev.preventDefault && ev.preventDefault(); }catch(e){}
        goToModeSafe();
      };

      // capture listeners (single-instance) using a guard flag on window
      if(!window.__examWeiterCaptureBound){
        window.__examWeiterCaptureBound = true;

        document.addEventListener("click", function(ev){
          try{
            const t = ev.target;
            const hit = t && t.closest ? t.closest("#examNextBtn") : null;
            if(hit){
              ev.preventDefault(); ev.stopPropagation();
              goToModeSafe();
            }
          }catch(e){}
        }, true);

        document.addEventListener("touchend", function(ev){
          try{
            const t = ev.target;
            const hit = t && t.closest ? t.closest("#examNextBtn") : null;
            if(hit){
              ev.preventDefault(); ev.stopPropagation();
              goToModeSafe();
            }
          }catch(e){}
        }, {capture:true, passive:false});
      }

      log("Exam-Weiter gebunden. id=" + btn.id);
    }finally{
      __bindLock = false;
    }
  }

  function onExamEnter(){
    // schedule to avoid synchronous recursion when showSection/show are called by other functions
    if(__examEnterLock){ log("onExamEnter skipped (lock)"); return; }
    __examEnterLock = true;

    setTimeout(()=>{
      try{
        safeRenderExams();          // safe + guarded
        ensureActiveExam();         // sets default selection
        bindExamWeiter();           // binds Weiter once
      }catch(e){
        log("onExamEnter crash: " + e.message);
      }finally{
        __examEnterLock = false;
      }
    }, 0);
  }

  // Hook showSection/show without creating recursion
  if(!window.__v41ShowHooked && typeof window.showSection === "function"){
    window.__v41ShowHooked = true;
    const prevShowSection = window.showSection;
    window.showSection = function(id){
      const r = prevShowSection(id);
      try{ if(id==="sExam") onExamEnter(); }catch(e){}
      return r;
    };
    log("showSection gehookt (v41).");
  }else{
    log("showSection hook √ºbersprungen (bereits/fehlt).");
  }

  if(!window.__v41ShowAltHooked && typeof window.show === "function"){
    window.__v41ShowAltHooked = true;
    const prevShow = window.show;
    window.show = function(id){
      const r = prevShow(id);
      try{ if(id==="sExam") onExamEnter(); }catch(e){}
      return r;
    };
    log("show() gehookt (v41).");
  }

  // Initial check
  setTimeout(()=>{
    try{
      const sExam = document.getElementById("sExam");
      const vis = sExam && (sExam.style.display!=="none") && sExam.offsetParent!==null;
      if(vis) onExamEnter();
    }catch(e){}
  }, 300);

  window.__ensureActiveExam = ensureActiveExam;
  window.__goToModeSafe = goToModeSafe;
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
/* v42 ‚Äì NAVIGATION HARD FIX (sauber + konfliktfrei)
   Ziel: EIN Screen-System, keine Mischform aus show()/showSection(), keine Endlos-Locks.
   - setScreen(): r√§umt sowohl .active als auch inline display auf.
   - show() + showSection() werden vereinheitlicht.
   - goToMode() wird robust √ºberschrieben (kein rekursives Re-Render).
   - "Weiter" (Exam) wird IMMER gebunden (click + touchend + keydown Enter).
*/
(function(){
  const log = (msg)=>{ try{ if(window.__dbg){ window.__dbg(msg); } }catch(_e){} };
  const screensSel = ".screen";

  function setScreen(id){
    try{
      document.querySelectorAll(screensSel).forEach(s=>{
        s.classList.remove("active");
        s.style.display = "none";
      });
      const el = document.getElementById(id);
      if(el){
        el.style.display = "block";
        el.classList.add("active");
      }
      try{ window.scrollTo(0,0); }catch(_e){}
    }catch(e){
      console.error(e);
    }
  }
  window.setScreen = setScreen;

  // unify both APIs
  window.show = setScreen;
  window.showSection = setScreen;

  // ensure a selected exam exists
  function ensureExamSelected(){
    try{
      if(!window.state) return;
      if(state.activeExamId) return;
      const db = (typeof window.loadDB==="function") ? window.loadDB() : null;
      if(db && Array.isArray(db.exams) && db.exams.length){
        state.activeExamId = db.exams[0].id;
        try{ if(typeof window.highlightSelectedExam==="function") window.highlightSelectedExam(); }catch(_e){}
      }
    }catch(_e){}
  }

  // robust goToMode (override any buggy prior versions)
  window.goToMode = function(){
    ensureExamSelected();
    if(!window.state || !state.activeExamId){
      try{ if(typeof window.toast==="function") toast("examNotice","Bitte zuerst eine Klausur ausw√§hlen."); }catch(_e){}
      return;
    }
    try{
      if(typeof window.updateModeCounts==="function") updateModeCounts();
      if(typeof window.updateMastery==="function") updateMastery();
      if(typeof window.updateHighscoreUI==="function") updateHighscoreUI();
    }catch(_e){}
    setScreen("sMode");
  };

  // robust goBack: if in a mode/screen -> back to mode, else to exam
  window.goBack = function(){
    const active = document.querySelector(`${screensSel}.active`);
    const id = active ? active.id : "";
    if(id && id !== "sMode" && id !== "sExam" && id !== "sName"){
      setScreen("sMode");
      try{
        if(typeof window.updateModeCounts==="function") updateModeCounts();
        if(typeof window.updateMastery==="function") updateMastery();
        if(typeof window.updateHighscoreUI==="function") updateHighscoreUI();
      }catch(_e){}
      return;
    }
    if(id === "sMode"){
      setScreen("sExam");
      try{ if(typeof window.renderExams==="function") renderExams(); }catch(_e){}
      return;
    }
    setScreen("sName");
  };

  // bind "Weiter" (Exam) once, with event delegation (works even if DOM re-renders)
  function isExamWeiter(t){
    if(!t) return false;
    const el = t.closest ? t.closest("#examNextBtn") : null;
    return !!el;
  }
  function onWeiter(){
    try{
      ensureExamSelected();
      window.goToMode();
      log("Weiter -> goToMode()");
    }catch(e){
      console.error(e);
    }
  }

  document.addEventListener("click", function(ev){
    if(isExamWeiter(ev.target)){
      ev.preventDefault();
      ev.stopPropagation();
      onWeiter();
    }
  }, true);

  document.addEventListener("touchend", function(ev){
    if(isExamWeiter(ev.target)){
      ev.preventDefault();
      ev.stopPropagation();
      onWeiter();
    }
  }, {capture:true, passive:false});

  document.addEventListener("keydown", function(ev){
    // Enter on exam screen triggers weiter
    if(ev.key === "Enter"){
      const active = document.querySelector(`${screensSel}.active`);
      if(active && active.id === "sExam"){
        ev.preventDefault();
        onWeiter();
      }
    }
  }, true);

  // initial cleanup: enforce one screen mode
  try{
    // if multiple screens were set inline by older patches, normalize:
    const active = document.querySelector(`${screensSel}.active`);
    if(active){
      setScreen(active.id);
    }else{
      // fallback: prefer exam if name exists, else name
      try{
        const uname = localStorage.getItem("lern_user_name") || "";
        if(uname.trim()){
          setScreen("sExam");
          try{ if(typeof window.renderExams==="function") renderExams(); }catch(_e){}
        }else{
          setScreen("sName");
        }
      }catch(_e){
        setScreen("sName");
      }
    }
  }catch(_e){}
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
  // ===== PIN (pro Klausur) =====
  const RESET_PIN = "1234"; // Klausur-PIN hier setzen

  function resetExamCardsWithPin(){
    try{ lt_makeAutoBackup("resetExamCardsWithPin"); }catch(_e){}

    const pin = (document.getElementById("resetPinInput")?.value || "").trim();
    if(pin !== RESET_PIN){
      try{ toast("examNotice","Falscher PIN."); }catch(_e){ alert("Falscher PIN."); }
      return;
    }

    const db = loadDB();
    const examId = state.activeExamId || (db.exams[0]?.id||"");
    if(!examId){
      try{ toast("examNotice","Keine Klausur ausgew√§hlt."); }catch(_e){ alert("Keine Klausur ausgew√§hlt."); }
      return;
    }

    const nCards = db.cards.filter(c=>c.examId===examId).length;
    const nQuiz  = db.quiz.filter(q=>q.examId===examId).length;

    if(!confirm(`Wirklich ALLE Karten dieser Klausur l√∂schen?\n\nKarteikarten: ${nCards}\nQuiz: ${nQuiz}\n\nDiese Aktion kann nicht r√ºckg√§ngig gemacht werden.`)){
      return;
    }

    db.cards = db.cards.filter(c=>c.examId!==examId);
    db.quiz  = db.quiz.filter(q=>q.examId!==examId);
    saveDB(db);

    // optional: pin field leeren
    const inp = document.getElementById("resetPinInput");
    if(inp) inp.value = "";

    try{ toast("examNotice","Karten gel√∂scht."); }catch(_e){}
    location.reload();
  }

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
  // ===== PIN =====
  const EXAM_DELETE_PIN = "1234"; // gleicher PIN oder eigener m√∂glich

  
  function resetHighscoreWithPin(){
    try{ lt_makeAutoBackup("resetHighscoreWithPin"); }catch(_e){}

    const pin = (document.getElementById("resetHsPinInput")?.value || "").trim();
    if(pin !== RESET_PIN){
      try{ toast("examNotice","Falscher PIN."); }catch(_e){ alert("Falscher PIN."); }
      return;
    }

    const db = loadDB();
    const examId = state.activeExamId || (db.exams[0]?.id||"");
    if(!examId){
      try{ toast("examNotice","Keine Klausur ausgew√§hlt."); }catch(_e){ alert("Keine Klausur ausgew√§hlt."); }
      return;
    }

    try{
      // Klausur-spezifische Ranglisten (lokal) l√∂schen
      localStorage.removeItem("top10_xp_" + examId);
      localStorage.removeItem("top10_secure_" + examId);
      localStorage.removeItem("top10_streak_" + examId);

      // UI-Cache (falls genutzt) ebenfalls leeren
      localStorage.removeItem("top10_xp");
      localStorage.removeItem("top10_secure");
      localStorage.removeItem("top10_streak");

      // Marker f√ºr sp√§tere Online-Implementierung / Nachvollziehbarkeit
      localStorage.setItem("highscoreResetAt_" + examId, String(Date.now()));
    }catch(_e){}

    // Eingabe leeren + Feedback
    const el = document.getElementById("resetHsPinInput");
    if(el) el.value = "";

    try{ toast("examNotice","Highscore zur√ºckgesetzt (Klausur)."); }catch(_e){ alert("Highscore zur√ºckgesetzt (Klausur)."); }

    // Wenn Highscore-UI offen ist: neu rendern
    try{ if(typeof renderHighscore === "function") renderHighscore(); }catch(_e){}
  }


  function deleteExamWithPin(){
    try{ lt_makeAutoBackup("deleteExamWithPin"); }catch(_e){}

    const pin = (document.getElementById("deleteExamPinInput")?.value || "").trim();
    if(pin !== EXAM_DELETE_PIN){
      try{ toast("examNotice","Falscher PIN."); }catch(_e){ alert("Falscher PIN."); }
      return;
    }

    const db = loadDB();
    const examId = state.activeExamId;
    if(!examId){
      try{ toast("examNotice","Keine Klausur ausgew√§hlt."); }catch(_e){ alert("Keine Klausur ausgew√§hlt."); }
      return;
    }

    const exam = db.exams.find(e=>e.id===examId);
    const examName = exam?.name || "diese Klausur";

    const nCards = db.cards.filter(c=>c.examId===examId).length;
    const nQuiz  = db.quiz.filter(q=>q.examId===examId).length;

    if(!confirm(
      `Klausur wirklich l√∂schen?\n\n` +
      `Name: ${examName}\n` +
      `Karteikarten: ${nCards}\nQuiz: ${nQuiz}\n\n` +
      `‚ö†Ô∏è Diese Aktion ist endg√ºltig!`
    )) return;

    // remove exam
    db.exams = db.exams.filter(e=>e.id!==examId);
    // remove related content
    db.cards = db.cards.filter(c=>c.examId!==examId);
    db.quiz  = db.quiz.filter(q=>q.examId!==examId);

    saveDB(db);

    try{ toast("examNotice","Klausur gel√∂scht."); }catch(_e){}
    location.reload();
  }

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
/* Karteikarte: Tap/Klick auf die Karte dreht sie (ohne Funktionsverlust) */
(function(){
  function attachFlip(){
    try{
      var card = document.querySelector('#flash1 .lf-card3d');
      if(!card) return;
      // keyboard access
      if(!card.hasAttribute('tabindex')) card.setAttribute('tabindex','0');
      if(!card.getAttribute('role')) card.setAttribute('role','button');
      card.setAttribute('aria-label','Karte umdrehen');
      // click/tap
      card.addEventListener('click', function(){
        if(typeof toggleAnswer === 'function') toggleAnswer('flash1');
      }, {passive:true});
      // Enter/Space
      card.addEventListener('keydown', function(e){
        if(e.key === 'Enter' || e.key === ' '){
          e.preventDefault();
          if(typeof toggleAnswer === 'function') toggleAnswer('flash1');
        }
      });
    }catch(_e){}
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', attachFlip);
  }else{
    attachFlip();
  }
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
(function(){
  if (typeof window.openAddExamModal !== "function") {
    window.openAddExamModal = function () {
      alert("Neue Klausur\n\nDiese Funktion ist vorbereitet, aber noch nicht aktiv.\n\nDu kannst trotzdem normal weiterlernen.");
    };
  }
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
function toggleStartPanel(id){
  try{
    const panels = ["masteryBox","highscorePanel","cardsCreateBox","quizCreateBox"];
    const el = document.getElementById(id);
    if(!el) return;

    const isHidden = (getComputedStyle(el).display === "none");

    if(isHidden){
      // close all other panels first
      panels.forEach(pid=>{
        if(pid !== id){
          const p = document.getElementById(pid);
          if(p && getComputedStyle(p).display !== "none"){
            p.style.display = "none";
          }
        }
      });
    }

    el.style.display = isHidden ? "block" : "none";
    if(isHidden){
      setTimeout(()=>{ try{ el.scrollIntoView({behavior:"smooth", block:"start"}); }catch(_e){} }, 50);
    }
  }catch(_e){}
}

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<!-- INSPECTOR HELPER v74 (nur zum Herausfinden von Klassen/IDs) -->
<style>
#inspectBtn{
  position:fixed; right:18px; bottom:92px;
  z-index:99999;
  border:1px solid rgba(0,0,0,.12);
  background:rgba(255,255,255,.92);
  border-radius:16px;
  padding:10px 12px;
  font-weight:900;
  box-shadow:0 10px 28px rgba(0,0,0,.18);
  cursor:pointer;
}
#inspectBtn.active{ outline:3px solid rgba(0,140,255,.35); }
#inspectToast{
  position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
  z-index:99999;
  max-width:min(920px, calc(100vw - 24px));
  padding:12px 14px;
  border-radius:16px;
  background:rgba(20,20,20,.88);
  color:#fff;
  font-size:14px;
  line-height:1.35;
  box-shadow:0 10px 30px rgba(0,0,0,.35);
  display:none;
}
#inspectToast code{ color:#a8ffcf; font-weight:800; }
#inspectToast .hint{ opacity:.75; font-size:12px; margin-top:6px; }
.inspectOutline{
  outline:3px solid rgba(0,140,255,.55) !important;
  outline-offset:2px !important;
}

/* üîß Dark Mode Button Fix (vB10.1) */
html.dark button,
html.dark .btn{
  color: #e8f1ef !important;
}

html.dark .btn.primary{
  color: #eafff6 !important;
}

html.dark .btn.danger{
  color: #ffecec !important;
}

html.dark button:disabled,
html.dark .btn:disabled{
  color: rgba(232,241,239,.45) !important;
}


/* üîß Dark Mode Readability Fix 2 (vB10.2) */
html.dark .lf-overview{
  background: rgba(255,255,255,.06) !important;
  border-color: rgba(255,255,255,.12) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 10px 24px rgba(0,0,0,.35) !important;
}
html.dark .lf-overview small{
  color: rgba(232,241,239,.78) !important;
  opacity: 1 !important;
}
html.dark .lf-overview .pill{
  background: rgba(232,241,239,.10) !important;
  border-color: rgba(232,241,239,.18) !important;
  color: rgba(232,241,239,.92) !important;
}

/* Filter-Chips im Dark Mode */
html.dark .chip{
  background: rgba(255,255,255,.08) !important;
  border-color: rgba(255,255,255,.18) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 6px 16px rgba(0,0,0,.25) !important;
}
html.dark .chip:active{ transform: translateY(1px); }


/* üîß Dark Mode Fix #3 ‚Äì Frage-Button Lesbarkeit */
html.dark .question-label,
html.dark .frage,
html.dark .question,
html.dark .card-front .label,
html.dark .frage-button{
  color: #0b1f1a !important;
  background: #eafff6 !important;
  font-weight: 700 !important;
  text-shadow: none !important;
}

html.dark .card-front{
  background: linear-gradient(180deg, #1e2b2a, #121b1a) !important;
}


/* üî• Dark Mode Kontrast-Overhaul (Final Analyse Fix) */

/* 1Ô∏è‚É£ Alle Texte pauschal heller */
html.dark body,
html.dark p,
html.dark span,
html.dark div,
html.dark h1,
html.dark h2,
html.dark h3,
html.dark h4,
html.dark h5,
html.dark h6,
html.dark label{
  color: #eaf4f2 !important;
}

/* 2Ô∏è‚É£ Frage / Antwort Badge */
html.dark .frage,
html.dark .antwort,
html.dark .question-label{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  font-weight: 800 !important;
  letter-spacing: 1px;
}

/* 3Ô∏è‚É£ Statistik (Gesamt / Offen / Sicher) */
html.dark .stat,
html.dark .stat span,
html.dark .stat-value{
  color: #ffffff !important;
  font-weight: 700;
}

/* 4Ô∏è‚É£ Chips & Filter */
html.dark .chip{
  background: #223332 !important;
  color: #ffffff !important;
  border: 1px solid #3d5c5a !important;
}

/* 5Ô∏è‚É£ Karteninhalt */
html.dark .card,
html.dark .card-front,
html.dark .card-back{
  background: #162221 !important;
  color: #ffffff !important;
}

/* 6Ô∏è‚É£ Platzhalter / disabled */
html.dark .muted,
html.dark .disabled{
  color: #9fb6b2 !important;
}


/* ‚úÖ Dark Mode Fix #5 ‚Äì "FRAGE" Label (Pseudo-Element & echtes Label) */
html.dark .lf-front::before,
html.dark .lf-frontLabel{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  border-color: rgba(255,255,255,.22) !important;
  text-shadow: none !important;
  font-weight: 900 !important;
}

html.dark .lf-front::before{
  box-shadow: 0 10px 30px rgba(0,0,0,.35) !important;
}

/* Falls irgendwo die Label-Farbe nochmal √ºberschrieben wird */
html.dark .lf-frontLabel *{
  color: #0b1f1a !important;
}


/* ‚úÖ Sicher gelernt IMMER sichtbar */
#cardSafeBtn{
  display:flex !important;
  opacity:1 !important;
  pointer-events:auto !important;
}

</style>
<button id="inspectBtn" title="Inspector an/aus" type="button">üîé Inspect</button>
<div id="inspectToast"></div>
<script>
(function(){
  const btn = document.getElementById("inspectBtn");
  const toast = document.getElementById("inspectToast");
  let on = false;
  let lastEl = null;

  function show(msg){
    toast.innerHTML = msg;
    toast.style.display = "block";
    clearTimeout(show._t);
    show._t = setTimeout(()=>{ toast.style.display="none"; }, 7000);
  }
  function selectorOf(el){
    if(!el) return "";
    const tag = (el.tagName||"").toLowerCase();
    const id = el.id ? ("#" + el.id) : "";
    const cls = (el.classList && el.classList.length) ? ("." + Array.from(el.classList).join(".")) : "";
    return (tag + id + cls) || "(kein selector)";
  }

  btn.addEventListener("click", ()=>{
    on = !on;
    btn.classList.toggle("active", on);
    show(on
      ? 'Inspector <b>AN</b> ‚úÖ ‚Äì Tippe jetzt auf das Element (z.B. Karte, ‚úÖ/‚ùå Button).<div class="hint">Danach bekommst du Tag/ID/Klassen. Tippe erneut auf üîé um auszuschalten.</div>'
      : 'Inspector <b>AUS</b>.'
    );
  });

  document.addEventListener("click", (e)=>{
    if(!on) return;
    // prevent normal action when inspecting (avoid answering cards etc.)
    e.preventDefault();
    e.stopPropagation();

    if(lastEl) lastEl.classList.remove("inspectOutline");
    const el = e.target;
    lastEl = el;
    el.classList.add("inspectOutline");

    const tag = (el.tagName||"").toLowerCase();
    const id = el.id || "(kein id)";
    const cls = (el.className && (""+el.className).trim()) ? (""+el.className).trim() : "(keine class)";
    const sel = selectorOf(el);

    const msg = `Element: <code>${tag}</code> ¬∑ id: <code>${id}</code> ¬∑ class: <code>${cls}</code><div class="hint">Selector: <code>${sel}</code> ¬∑ (Wenn m√∂glich: wurde in Zwischenablage kopiert.)</div>`;
    show(msg);

    try{
      const toCopy = `tag=${tag}\nid=${id}\nclass=${cls}\nselector=${sel}`;
      if(navigator.clipboard && navigator.clipboard.writeText){
        navigator.clipboard.writeText(toCopy).catch(()=>{});
      }
    }catch(_e){}
  }, true);
})();


// ===== Admin Gate (PIN 1234) =====
let __adminUnlocked = false;

function __applyAdminGate(){
  const root = document.documentElement;
  if(__adminUnlocked){
    root.classList.add('admin-unlocked');
    const btn = document.getElementById('adminBtn');
    if(btn) btn.textContent = 'Admin ‚úì';
  }else{
    root.classList.remove('admin-unlocked');
    const btn = document.getElementById('adminBtn');
    if(btn) btn.textContent = 'Admin';
  }
}

function openAdminGate(){
  if(__adminUnlocked){
    // already unlocked -> just ensure visible
    __applyAdminGate();
    const el = document.getElementById('adminControls');
    if(el) el.scrollIntoView({behavior:'smooth', block:'center'});
    return;
  }
  const pin = prompt('Admin-PIN eingeben:');
  if(pin === null) return;
  if(String(pin).trim() === '1234'){
    __adminUnlocked = true;
    __applyAdminGate();
    const el = document.getElementById('adminControls');
    if(el) el.scrollIntoView({behavior:'smooth', block:'center'});
  }else{
    alert('Kein Zugriff.');
  }
}

document.addEventListener('DOMContentLoaded', () => {
  __applyAdminGate();
});

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<!-- Quizkarten-Overlay (Fix: "Quizkarten erstellen" √∂ffnet Erstellen statt Quiz) -->
<style>
#quizCreateOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:9999;padding:18px;background:rgba(0,0,0,.25);backdrop-filter:blur(6px)}
#quizCreateOverlay .qco{width:min(860px,100%);max-height:92vh;overflow:auto;background:#fff;border-radius:22px;box-shadow:0 20px 70px rgba(0,0,0,.22);padding:18px 18px 16px}
#quizCreateOverlay .qcoHead{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:10px}
#quizCreateOverlay .qcoHead h2{margin:0;font-size:28px;letter-spacing:.2px}
#quizCreateOverlay .qcoHead .btnX{border:none;background:#f1f3f5;border-radius:999px;padding:10px 14px;font-weight:700;cursor:pointer}
#quizCreateOverlay .qcoGrid{display:grid;grid-template-columns:1fr;gap:10px}
#quizCreateOverlay label{font-size:13px;color:#444}
#quizCreateOverlay input[type="text"], #quizCreateOverlay textarea{width:100%;border:1px solid #e5e7eb;border-radius:14px;padding:12px 12px;font-size:16px;outline:none}
#quizCreateOverlay textarea{min-height:92px;resize:vertical}
#quizCreateOverlay .answers{display:grid;grid-template-columns:1fr;gap:10px}
#quizCreateOverlay .ansRow{display:flex;gap:10px;align-items:center}
#quizCreateOverlay .ansRow .radio{width:22px;height:22px}
#quizCreateOverlay .actions{display:flex;gap:10px;justify-content:flex-end;margin-top:10px;flex-wrap:wrap}
#quizCreateOverlay .btnP{border:none;border-radius:14px;padding:12px 14px;font-size:16px;font-weight:700;cursor:pointer}
#quizCreateOverlay .btnP.primary{background:#0ea5e9;color:#fff}
#quizCreateOverlay .btnP.ghost{background:#f3f4f6;color:#111827}
#quizCreateOverlay .hint{font-size:13px;color:#6b7280;margin-top:6px}

/* üîß Dark Mode Button Fix (vB10.1) */
html.dark button,
html.dark .btn{
  color: #e8f1ef !important;
}

html.dark .btn.primary{
  color: #eafff6 !important;
}

html.dark .btn.danger{
  color: #ffecec !important;
}

html.dark button:disabled,
html.dark .btn:disabled{
  color: rgba(232,241,239,.45) !important;
}


/* üîß Dark Mode Readability Fix 2 (vB10.2) */
html.dark .lf-overview{
  background: rgba(255,255,255,.06) !important;
  border-color: rgba(255,255,255,.12) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 10px 24px rgba(0,0,0,.35) !important;
}
html.dark .lf-overview small{
  color: rgba(232,241,239,.78) !important;
  opacity: 1 !important;
}
html.dark .lf-overview .pill{
  background: rgba(232,241,239,.10) !important;
  border-color: rgba(232,241,239,.18) !important;
  color: rgba(232,241,239,.92) !important;
}

/* Filter-Chips im Dark Mode */
html.dark .chip{
  background: rgba(255,255,255,.08) !important;
  border-color: rgba(255,255,255,.18) !important;
  color: rgba(232,241,239,.92) !important;
  box-shadow: 0 6px 16px rgba(0,0,0,.25) !important;
}
html.dark .chip:active{ transform: translateY(1px); }


/* üîß Dark Mode Fix #3 ‚Äì Frage-Button Lesbarkeit */
html.dark .question-label,
html.dark .frage,
html.dark .question,
html.dark .card-front .label,
html.dark .frage-button{
  color: #0b1f1a !important;
  background: #eafff6 !important;
  font-weight: 700 !important;
  text-shadow: none !important;
}

html.dark .card-front{
  background: linear-gradient(180deg, #1e2b2a, #121b1a) !important;
}


/* üî• Dark Mode Kontrast-Overhaul (Final Analyse Fix) */

/* 1Ô∏è‚É£ Alle Texte pauschal heller */
html.dark body,
html.dark p,
html.dark span,
html.dark div,
html.dark h1,
html.dark h2,
html.dark h3,
html.dark h4,
html.dark h5,
html.dark h6,
html.dark label{
  color: #eaf4f2 !important;
}

/* 2Ô∏è‚É£ Frage / Antwort Badge */
html.dark .frage,
html.dark .antwort,
html.dark .question-label{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  font-weight: 800 !important;
  letter-spacing: 1px;
}

/* 3Ô∏è‚É£ Statistik (Gesamt / Offen / Sicher) */
html.dark .stat,
html.dark .stat span,
html.dark .stat-value{
  color: #ffffff !important;
  font-weight: 700;
}

/* 4Ô∏è‚É£ Chips & Filter */
html.dark .chip{
  background: #223332 !important;
  color: #ffffff !important;
  border: 1px solid #3d5c5a !important;
}

/* 5Ô∏è‚É£ Karteninhalt */
html.dark .card,
html.dark .card-front,
html.dark .card-back{
  background: #162221 !important;
  color: #ffffff !important;
}

/* 6Ô∏è‚É£ Platzhalter / disabled */
html.dark .muted,
html.dark .disabled{
  color: #9fb6b2 !important;
}


/* ‚úÖ Dark Mode Fix #5 ‚Äì "FRAGE" Label (Pseudo-Element & echtes Label) */
html.dark .lf-front::before,
html.dark .lf-frontLabel{
  background: #f2fffb !important;
  color: #0b1f1a !important;
  border-color: rgba(255,255,255,.22) !important;
  text-shadow: none !important;
  font-weight: 900 !important;
}

html.dark .lf-front::before{
  box-shadow: 0 10px 30px rgba(0,0,0,.35) !important;
}

/* Falls irgendwo die Label-Farbe nochmal √ºberschrieben wird */
html.dark .lf-frontLabel *{
  color: #0b1f1a !important;
}


/* ‚úÖ Dark Mode Fix #6 ‚Äì Quiz: "Antwort ausw√§hlen" & Antworten Lesbarkeit */
html.dark .quiz-status{
  background: #223332 !important;
  color: #ffffff !important;
  border: 1px solid rgba(255,255,255,.16) !important;
}

html.dark .quiz-status.neutral{
  background: #223332 !important;
  color: #ffffff !important;
}

html.dark .quiz-status.right,
html.dark .quiz-status.correct{
  background: rgba(60, 170, 120, .22) !important;
  color: #eafff6 !important;
  border: 1px solid rgba(60,170,120,.35) !important;
}

html.dark .quiz-status.wrong,
html.dark .quiz-status.bad{
  background: rgba(220, 90, 90, .22) !important;
  color: #ffecec !important;
  border: 1px solid rgba(220,90,90,.35) !important;
}

/* Antwort-Buttons im Quiz (nur im Antworten-Bereich) */
html.dark .answers button,
html.dark .answers .btn{
  background: #1d2b2a !important;
  color: #ffffff !important;
  border: 1px solid rgba(255,255,255,.14) !important;
}

html.dark .answers button:hover{
  filter: brightness(1.08);
}

html.dark .answers button:disabled{
  background: rgba(29,43,42,.55) !important;
  color: rgba(255,255,255,.55) !important;
}


/* ‚úÖ Layout Fix: Quiz-Frage unter Filter */
#quizQ{ margin-top: 10px !important; margin-bottom: 12px !important; }


/* ‚úÖ Quiz: Frage unter Filter ‚Äì Abst√§nde */
#quizQ{
  margin-top: 12px !important;
  margin-bottom: 12px !important;
}


/* ‚úÖ Quiz Frage-Block: stabil unter Filter */
#quizQ{ display:block !important; width:100% !important; }


/* ‚úÖ Quiz Frage: unter Filter h√ºbscher Abstand */
#quizQ{ margin-top: 12px !important; margin-bottom: 12px !important; }


/* ‚úÖ Sicher gelernt IMMER sichtbar */
#cardSafeBtn{
  display:flex !important;
  opacity:1 !important;
  pointer-events:auto !important;
}

</style>
<div aria-label="Quizkarten erstellen" aria-modal="true" id="quizCreateOverlay" role="dialog">
<div class="qco">
<div class="qcoHead">
<h2>üß† Quizkarten erstellen</h2>
<button class="btnX" onclick="closeQuizCreateOverlay()" type="button">‚úï</button>
</div>
<div class="qcoGrid">
<div>
<label>Frage</label>
<textarea id="qc_question" placeholder="z.B. Was kennzeichnet affektive St√∂rungen?"></textarea>
</div>
<div class="answers">
<div class="ansRow">
<input checked="" class="radio" name="qc_correct" type="radio" value="0"/>
<input id="qc_a0" placeholder="Antwort A" type="text"/>
</div>
<div class="ansRow">
<input class="radio" name="qc_correct" type="radio" value="1"/>
<input id="qc_a1" placeholder="Antwort B" type="text"/>
</div>
<div class="ansRow">
<input class="radio" name="qc_correct" type="radio" value="2"/>
<input id="qc_a2" placeholder="Antwort C" type="text"/>
</div>
<div class="ansRow">
<input class="radio" name="qc_correct" type="radio" value="3"/>
<input id="qc_a3" placeholder="Antwort D" type="text"/>
</div>
</div>
<div class="hint">Tipp: Markiere links die richtige Antwort. (Nur lokal gespeichert.)</div>
<div class="actions">
<button class="btnP ghost" onclick="qc_clearForm()" type="button">Leeren</button>
<button class="btnP primary" onclick="qc_saveQuiz()" type="button">Speichern</button>
</div>
</div>
</div>
</div>
<script>
/* =========================
   v35: QUIZ-ERSTELLEN als eigener Bereich (ohne Overlay)
   - Overlay bleibt erhalten (kein Funktionsverlust)
   - Quiz & Karteikarten im Erstellen-Modus komplett getrennt
========================= */

function m2_setTab(tab){
  try{
    var cards=document.getElementById("m2CardsArea");
    var quiz=document.getElementById("m2QuizArea");
    var bC=document.getElementById("m2TabCards");
    var bQ=document.getElementById("m2TabQuiz");
    if(cards) cards.style.display = (tab==="quiz") ? "none" : "block";
    if(quiz)  quiz.style.display  = (tab==="quiz") ? "block" : "none";
    if(bC && bQ){
      if(tab==="quiz"){
        bC.className="btn ghost";
        bQ.className="btn";
      }else{
        bC.className="btn";
        bQ.className="btn ghost";
      }
    }
    if(tab==="quiz"){
      try{ if(typeof renderOwnQuiz==="function") renderOwnQuiz(); }catch(_e){}
    }else{
      try{ if(typeof window.renderOwnCards==="function") window.renderOwnCards(); }catch(_e){}
    }
  }catch(_e){}
}

function openCreateQuiz(){
  try{
    if(typeof openMode==="function") openMode(2);
    // nach dem Wechsel in den Erstellen-Modus direkt den Quiz-Tab √∂ffnen
    setTimeout(function(){ m2_setTab("quiz"); }, 50);
  }catch(_e){}
}

/* ---------- Quiz (Eigene Fragen) ---------- */
function clearOwnQuizForm(){
  try{
    ["m2qQuestion","m2qA0","m2qA1","m2qA2","m2qA3"].forEach(function(id){
      var el=document.getElementById(id); if(el) el.value="";
    });
    var r=document.querySelector('input[name="m2qCorrect"][value="0"]');
    if(r) r.checked=true;
    var st=document.getElementById("createQuizStatus");
    if(st) st.textContent="";
  }catch(_e){}
}

function m2_getCorrectIndex(){
  try{
    var r=document.querySelector('input[name="m2qCorrect"]:checked');
    return r ? Number(r.value) : 0;
  }catch(_e){ return 0; }
}

function createOwnQuiz(){
  try{
    var q = String((document.getElementById("m2qQuestion")||{}).value||"").trim();
    var a0= String((document.getElementById("m2qA0")||{}).value||"").trim();
    var a1= String((document.getElementById("m2qA1")||{}).value||"").trim();
    var a2= String((document.getElementById("m2qA2")||{}).value||"").trim();
    var a3= String((document.getElementById("m2qA3")||{}).value||"").trim();
    var share= !!((document.getElementById("m2qShare")||{}).checked);

    var st=document.getElementById("createQuizStatus");
    if(!q || !a0 || !a1 || !a2 || !a3){
      if(st) st.textContent="‚ö†Ô∏è Bitte Frage + alle 4 Antworten ausf√ºllen.";
      return;
    }

    var db = (typeof loadDB==="function") ? loadDB() : null;
    if(!db){ if(st) st.textContent="‚ùå DB nicht verf√ºgbar."; return; }

    var examId = (typeof state!=="undefined" && state.activeExamId) ? state.activeExamId : (db.exams && db.exams[0] ? db.exams[0].id : "");
    if(!examId){
      if(st) st.textContent="‚ö†Ô∏è Keine Klausur ausgew√§hlt.";
      return;
    }

    if(!Array.isArray(db.quiz)) db.quiz=[];
    var id = (typeof newId==="function") ? newId("q") : ("q_"+Date.now()+"_"+Math.random().toString(16).slice(2));

    var item = {
      id: id,
      examId: examId,
      question: q,
      answers: [a0,a1,a2,a3],
      correctIndex: m2_getCorrectIndex(),
      sharedClass: false,
      sharedAt: null,
      stats: {},
      source: null,
      userCreated: true,
      createdAt: Date.now()
    };

    db.quiz.push(item);

    if(share){
      item.sharedClass=true;
      item.sharedAt=Date.now();
      // offline queue (wie bei Karten)
      try{
        var raw=localStorage.getItem("lt_share_outbox")||"[]";
        var out=JSON.parse(raw);
        if(!Array.isArray(out)) out=[];
        out.push({
          kind:"quiz",
          examId: examId,
          id: id,
          question: q,
          answers: [a0,a1,a2,a3],
          correctIndex: item.correctIndex,
          createdAt: item.createdAt
        });
        localStorage.setItem("lt_share_outbox", JSON.stringify(out));
      }catch(_e){}
    }

    if(typeof saveDB==="function") saveDB(db);

    if(st) st.textContent = share ? "‚úÖ gespeichert + geteilt" : "‚úÖ gespeichert";
    clearOwnQuizForm();
    try{ renderOwnQuiz(); }catch(_e){}
    try{ if(typeof window.updateModeCounts==="function") window.updateModeCounts(); }catch(_e){}
    try{ if(typeof updateOverviews==="function") updateOverviews(); }catch(_e){}
  }catch(e){
    console.error(e);
    var st=document.getElementById("createQuizStatus");
    if(st) st.textContent="‚ùå Fehler beim Speichern.";
    alert("Fehler beim Speichern der Quizfrage.");
  }
}

function renderOwnQuiz(){
  try{
    var list=document.getElementById("ownQuizList");
    var countEl=document.getElementById("ownQuizCount");
    if(!list) return;

    var db = (typeof loadDB==="function") ? loadDB() : null;
    if(!db || !Array.isArray(db.quiz)) { list.innerHTML=""; if(countEl) countEl.textContent="0"; return; }

    var examId = (typeof state!=="undefined" && state.activeExamId) ? state.activeExamId : (db.exams && db.exams[0] ? db.exams[0].id : "");
    var all=[];
    for(var i=0;i<db.quiz.length;i++){
      var q=db.quiz[i];
      if(q && q.examId===examId && (q.userCreated || q.createdAt)) all.push(q);
    }
    if(countEl) countEl.textContent = all.length + " Quizkarten";

    list.innerHTML="";
    if(!all.length){
      var empty=document.createElement("div");
      empty.className="notice";
      empty.textContent="Noch keine eigenen Quizkarten ‚Äì erstelle oben deine erste Quizfrage.";
      list.appendChild(empty);
      return;
    }

    all.sort(function(a,b){ return (b.createdAt||0)-(a.createdAt||0); });

    for(var j=0;j<all.length;j++){
      (function(item){
        var row=document.createElement("div");
        row.style.padding="12px";
        row.style.borderRadius="14px";
        row.style.background="#fff";
        row.style.boxShadow="0 2px 8px rgba(0,0,0,.06)";
        row.style.border="1px solid rgba(0,0,0,.06)";

        var q=document.createElement("div");
        q.style.fontWeight="800";
        q.style.marginBottom="6px";
        q.textContent=item.question || "‚Äì";
        row.appendChild(q);

        var a=document.createElement("div");
        a.style.fontSize="12px";
        a.style.color="#666";
        var ci = Number(item.correctIndex||0);
        var label = ["A","B","C","D"][ci] || "A";
        a.textContent="Richtig: " + label;
        row.appendChild(a);

        list.appendChild(row);
      })(all[j]);
    }
  }catch(e){ console.error(e); }
}

// Wenn der Erstellen-Modus ge√∂ffnet wird, Standard: Karteikarten-Tab
document.addEventListener("DOMContentLoaded", function(){
  try{
    // defensive: falls beim Laden schon im Erstellen-Modus
    m2_setTab("cards");
  }catch(_e){}
});

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
function openQuizCreateOverlay(){
  // optional: stay consistent with navigation (open create mode in background)
  try{ if(typeof openMode === "function") openMode(2); }catch(_e){}
  const o=document.getElementById("quizCreateOverlay");
  if(o){ o.style.display="flex"; }
  // focus
  setTimeout(()=>{ const t=document.getElementById("qc_question"); if(t) t.focus(); }, 50);
}
function closeQuizCreateOverlay(){
  const o=document.getElementById("quizCreateOverlay");
  if(o) o.style.display="none";
}
function qc_clearForm(){
  ["qc_question","qc_a0","qc_a1","qc_a2","qc_a3"].forEach(id=>{ const el=document.getElementById(id); if(el) el.value=""; });
  const r=document.querySelector('#quizCreateOverlay input[name="qc_correct"][value="0"]');
  if(r) r.checked=true;
}
function qc_getCorrectIndex(){
  const r=document.querySelector('#quizCreateOverlay input[name="qc_correct"]:checked');
  return r ? Number(r.value) : 0;
}
function qc_saveQuiz(){
  try{
    const qEl=document.getElementById("qc_question");
    const q=String(qEl?.value||"").trim();
    const a0=String(document.getElementById("qc_a0")?.value||"").trim();
    const a1=String(document.getElementById("qc_a1")?.value||"").trim();
    const a2=String(document.getElementById("qc_a2")?.value||"").trim();
    const a3=String(document.getElementById("qc_a3")?.value||"").trim();
    if(!q || !a0 || !a1 || !a2 || !a3){
      if(typeof toast==="function") toast("examNotice","Bitte Frage + alle 4 Antworten ausf√ºllen.");
      else alert("Bitte Frage + alle 4 Antworten ausf√ºllen.");
      return;
    }

    const db = (typeof loadDB==="function") ? loadDB() : null;
    if(!db){ alert("DB nicht verf√ºgbar."); return; }

    const examId = (typeof state!=="undefined" && state.activeExamId) ? state.activeExamId : (db.exams?.[0]?.id||"");
    if(!examId){
      if(typeof toast==="function") toast("examNotice","Keine Klausur ausgew√§hlt.");
      else alert("Keine Klausur ausgew√§hlt.");
      return;
    }

    if(!Array.isArray(db.quiz)) db.quiz = [];
    const id = (typeof newId==="function") ? newId("q") : ("q_"+Date.now()+"_"+Math.random().toString(16).slice(2));
    db.quiz.push({
      id,
      examId,
      question: q,
      answers: [a0,a1,a2,a3],
      correctIndex: qc_getCorrectIndex(),
      sharedClass: false,
      sharedAt: null,
      stats: {},
      source: null,
      userCreated: true,
      createdAt: Date.now()
    });

    if(typeof saveDB==="function") saveDB(db);
    if(typeof updateOverviews==="function") try{ updateOverviews(); }catch(_e){}
    if(typeof renderQuiz==="function") try{ renderQuiz(); }catch(_e){}
    if(typeof toast==="function") toast("examNotice","‚úÖ Quizkarte gespeichert.");
    qc_clearForm();
    closeQuizCreateOverlay();
  }catch(e){
    console.error(e);
    alert("Fehler beim Speichern.");
  }
}
// close on backdrop click
document.addEventListener("click", (e)=>{
  const o=document.getElementById("quizCreateOverlay");
  if(!o || o.style.display!=="flex") return;
  if(e.target===o) closeQuizCreateOverlay();
});
document.addEventListener("keydown",(e)=>{
  if(e.key==="Escape") closeQuizCreateOverlay();
});

/* ===== Eigene Karten: einklappen/ausklappen (Start = eingeklappt) ===== */
function setupOwnCardsCollapse(){
  try{
    const KEY = 'lt_own_cards_collapsed_v1';
    const btn = document.getElementById('toggleOwnCardsBtn');
    const list = document.getElementById('ownCardsList');
    const header = document.getElementById('ownCardsHeaderRow');
    if(!btn || !list || !header) return;

    const saved = localStorage.getItem(KEY);
    let collapsed = (saved === null) ? true : (saved === '1');

    const apply = () => {
      list.style.display = collapsed ? 'none' : 'grid';
      btn.textContent = collapsed ? '‚ñ∏' : '‚ñæ';
      btn.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
      header.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
    };

    const toggle = () => {
      collapsed = !collapsed;
      localStorage.setItem(KEY, collapsed ? '1' : '0');
      apply();
    };

    btn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); toggle(); });

    header.addEventListener('click', (e)=>{
      // wenn jemand auf den kleinen Pfeil klickt, macht der Button-Handler das schon
      if(e.target && (e.target === btn || e.target.closest('#toggleOwnCardsBtn'))) return;
      // sonst: √ºberall toggeln
      toggle();
    });

    header.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter' || e.key === ' '){
        e.preventDefault();
        toggle();
      }
    });

    apply();
  }catch(_e){}
}


function setupOwnQuizCollapse(){
  try{
    const KEY = 'lt_own_quiz_collapsed_v1';
    const btn = document.getElementById('toggleOwnQuizBtn');
    const row = document.getElementById('ownQuizHeaderRow');
    const list = document.getElementById('ownQuizList');
    if(!btn || !row || !list) return;

    // IMPORTANT: Always start collapsed (start position), regardless of any previous stored state.
    const apply = (forceCollapsed = false)=>{
      let collapsed = true;
      if(forceCollapsed){
        collapsed = true;
        localStorage.setItem(KEY,'1');
      }else{
        const raw = localStorage.getItem(KEY);
        collapsed = (raw === null) ? true : (raw === '1');
        if(raw === null) localStorage.setItem(KEY,'1');
      }
      list.style.display = collapsed ? 'none' : 'grid';
      btn.textContent = collapsed ? '‚ñ∂' : '‚ñº';
      row.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
    };

    const setCollapsed = (collapsed)=>{
      localStorage.setItem(KEY, collapsed ? '1' : '0');
      apply(false);
    };

    const toggle = (e)=>{
      if(e){ e.preventDefault?.(); e.stopPropagation?.(); }
      const raw = localStorage.getItem(KEY);
      const collapsed = (raw === null) ? true : (raw === '1');
      setCollapsed(!collapsed);
    };

    // Force collapsed at boot (start position)
    apply(true);

    // Click anywhere on header row toggles (including icon/text). Button also toggles.
    btn.addEventListener('click', toggle);
    row.addEventListener('click', (e)=>{
      if(e.target && (e.target.closest && e.target.closest('#toggleOwnQuizBtn'))) return;
      toggle(e);
    });

    row.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter' || e.key === ' '){ toggle(e); }
    });

  }catch(_e){}
}


document.addEventListener('DOMContentLoaded', ()=>{ try{ setupOwnCardsCollapse();
  setupOwnQuizCollapse(); }catch(_e){} });


// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
(function(){
  const storeKey = 'quizVotes';
  const votes = JSON.parse(localStorage.getItem(storeKey)||'{}');
  function save(){localStorage.setItem(storeKey, JSON.stringify(votes));}
  window.renderQuizVotes = function(cardEl, qid){
    if(!votes[qid]) votes[qid]={up:0,down:0};
    const wrap=document.createElement('div');
    wrap.className='quiz-votes';
    const up=document.createElement('button');
    up.className='quiz-vote-btn up';
    up.textContent='üëç';
    const down=document.createElement('button');
    down.className='quiz-vote-btn down';
    down.textContent='üëé';
    up.onclick=()=>{votes[qid].up++; up.classList.add('active'); save();};
    down.onclick=()=>{votes[qid].down++; down.classList.add('active'); save(); checkHide(cardEl,qid);};
    wrap.append(up,down);
    cardEl.appendChild(wrap);
    checkHide(cardEl,qid);
  }
  function checkHide(cardEl,qid){
    if(votes[qid] && votes[qid].down>=5 && !window.isAdmin){
      cardEl.classList.add('quiz-hidden');
    }
  }
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script>
/* ===== Quiz: Daumen hoch/runter wie bei Karteikarten (lokal, 1 Stimme pro Nutzer) =====
   - Speichert in db.quiz: likesCount, dislikesCount, votes{user: 1/-1/0}, localHidden
   - Ab 5 Dislikes: localHidden=true (f√ºr Nicht-Admin ausgeblendet)
   - Admin (PIN 1234 -> admin-unlocked): sieht alles + kann wiederherstellen
*/
(function(){
  function isAdmin(){
    try{ return document.documentElement.classList.contains('admin-unlocked'); }catch(_e){ return false; }
  }

  function getUser(){
    try{
      const u = (typeof getUserName === "function") ? (getUserName()||"") : "";
      return u || "anon";
    }catch(_e){ return "anon"; }
  }

  function getQuizById(db, id){
    try{ return (db.quiz||[]).find(q=>q.id===id) || null; }catch(_e){ return null; }
  }

  function setVote(db, q, user, nextVote){
    // nextVote: 1, -1, 0
    if(!q.votes) q.votes = {};
    if(typeof q.likesCount !== "number") q.likesCount = q.likesCount||0;
    if(typeof q.dislikesCount !== "number") q.dislikesCount = q.dislikesCount||0;

    const prev = Number(q.votes[user] || 0);
    if(prev === nextVote) return; // no-op

    // remove prev
    if(prev === 1) q.likesCount = Math.max(0, (q.likesCount||0) - 1);
    if(prev === -1) q.dislikesCount = Math.max(0, (q.dislikesCount||0) - 1);

    // add next
    if(nextVote === 1) q.likesCount = (q.likesCount||0) + 1;
    if(nextVote === -1) q.dislikesCount = (q.dislikesCount||0) + 1;

    if(nextVote === 0) delete q.votes[user];
    else q.votes[user] = nextVote;

    // auto hide
    if((q.dislikesCount||0) >= 5){
      q.localHidden = true;
    }
  }

  window.renderQuizLocalVoteBar = function(qid){
    const bar = document.getElementById("voteBarQuizLocal");
    if(!bar) return;

    const db = (typeof loadDB==="function") ? loadDB() : null;
    if(!db) { bar.style.display="none"; return; }

    const q = getQuizById(db, qid);
    if(!q) { bar.style.display="none"; return; }

    // ‚úÖ Voting-Daumen nur bei "Klasse teilen" (sharedClass) anzeigen
    if(!q.sharedClass){
      bar.style.display="none";
      return;
    }

    // Hide bar if card hidden and not admin (because question will be skipped anyway)
    if(q.localHidden && !isAdmin()){
      bar.style.display="none";
      return;
    }

    const user = getUser();
    const vote = Number((q.votes && q.votes[user]) ? q.votes[user] : 0);

    bar.style.display = "flex";
    bar.innerHTML = "";

    const up = document.createElement("button");
    up.type = "button";
    up.className = "votePill " + (vote===1 ? "ok" : "ghost");
    up.textContent = "üëç " + (q.likesCount||0);
    up.onclick = ()=>{
      const db2 = loadDB();
      const q2 = getQuizById(db2, qid);
      if(!q2) return;
      setVote(db2, q2, user, 1);
      saveDB(db2);
      window.renderQuizLocalVoteBar(qid);
    };

    const down = document.createElement("button");
    down.type = "button";
    down.className = "votePill " + (vote===-1 ? "danger" : "ghost");
    down.textContent = "üëé " + (q.dislikesCount||0);
    down.onclick = ()=>{
      const db2 = loadDB();
      const q2 = getQuizById(db2, qid);
      if(!q2) return;
      setVote(db2, q2, user, -1);
      saveDB(db2);

      // if hidden now and not admin -> directly next
      if(q2.localHidden && !isAdmin()){
        try{ if(typeof nextQuiz==="function") nextQuiz(); }catch(_e){}
        return;
      }
      window.renderQuizLocalVoteBar(qid);
    };

    bar.appendChild(up);
    bar.appendChild(down);

    // Admin restore button
    if(isAdmin() && q.localHidden){
      const restore = document.createElement("button");
      restore.type = "button";
      restore.className = "votePill ghost";
      restore.textContent = "‚ôªÔ∏è Wiederherstellen";
      restore.onclick = ()=>{
        const db2 = loadDB();
        const q2 = getQuizById(db2, qid);
        if(!q2) return;
        q2.localHidden = false;
        saveDB(db2);
        window.renderQuizLocalVoteBar(qid);
        try{ if(typeof toast==="function") toast("quizNotice","Admin: Frage wiederhergestellt."); }catch(_e){}
      };
      bar.appendChild(restore);
    }
  };

  // Patch renderQuiz (ohne Funktionsverlust): nach dem normalen Rendern VoteBar anzeigen + ggf. hidden √ºberspringen
  if(typeof window.renderQuiz === "function" && !window.__patchedQuizVotes){
    const _orig = window.renderQuiz;
    window.renderQuiz = function(){
      _orig.apply(this, arguments);
      try{
        const q = (typeof currentQuiz==="function") ? currentQuiz() : null;
        if(q && q.id){
          // if hidden and not admin -> skip immediately
          try{
            const db = loadDB();
            const qdb = getQuizById(db, q.id);
            if(qdb && qdb.localHidden && !isAdmin()){
              if(typeof nextQuiz==="function") nextQuiz();
              return;
            }
          }catch(_e){}
          window.renderQuizLocalVoteBar(q.id);
        }else{
          const bar=document.getElementById("voteBarQuizLocal");
          if(bar) bar.style.display="none";
        }
      }catch(_e){}
    };
    window.__patchedQuizVotes = true;
  }
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>
<script id="ltDashScript" style=" font-size: 200%">
/* ===== Dashboard (Lernstand) ‚Äì Anzeige-only, keine Funktionsverluste =====
   - Loggt Aktivit√§t (letzte Antwortzeit), Lerntage (Streak) und letzte 50 Antworten f√ºr Readiness
   - Nutzt bestehende DB-Felder: card.stats / quiz.stats, isSafe, points/level
*/
(function(){
  const KEY_PREFIX = "lt_exam_";
  function examId(){ try{ return (window.state && window.state.activeExamId) ? String(window.state.activeExamId) : "none"; }catch(_e){ return "none"; } }
  function K(s){ return KEY_PREFIX + examId() + "_" + s; }
  const KEY_LAST = () => K("lastActivity");
  const KEY_DAYS = () => K("activityDays");
  const KEY_LAST50 = () => K("last50");
  const KEY_TIME = () => K("time_total_ms");
  const KEY_TIME_LASTSTART = () => K("time_lastStart");
  
  function now(){ return Date.now(); }
  function isoDay(ts){
    const d = new Date(ts);
    return d.toISOString().slice(0,10);
  }
  function safeJSONGet(k, def){
    try{ const raw = localStorage.getItem(k); if(!raw) return def; const v = JSON.parse(raw); return v ?? def; }catch(_e){ return def; }
  }
  function safeJSONSet(k, v){
    try{ localStorage.setItem(k, JSON.stringify(v)); }catch(_e){}
  }

  function startTimerIfNeeded(){
    // optional: counts "app open time" only while tool is active
    try{
      if(!localStorage.getItem(KEY_TIME_LASTSTART())){
        localStorage.setItem(KEY_TIME_LASTSTART(), String(now()));
      }
    }catch(_e){}
  }
  function stopTimer(){
    try{
      const s = Number(localStorage.getItem(KEY_TIME_LASTSTART())||0);
      if(s>0){
        const acc = Number(localStorage.getItem(KEY_TIME())||0);
        const add = Math.max(0, now()-s);
        localStorage.setItem(KEY_TIME(), String(acc+add));
        localStorage.removeItem(KEY_TIME_LASTSTART());
      }
    }catch(_e){}
  }
  window.addEventListener("visibilitychange", ()=>{ if(document.hidden) stopTimer(); else startTimerIfNeeded(); });
  window.addEventListener("beforeunload", ()=>{ stopTimer(); });
  startTimerIfNeeded();

  function recordDay(ts){
    const day = isoDay(ts);
    const days = safeJSONGet(KEY_DAYS(), []);
    if(!Array.isArray(days)) return;
    if(days[days.length-1] !== day){
      // keep only recent 365 days
      days.push(day);
      while(days.length > 365) days.shift();
      safeJSONSet(KEY_DAYS(), days);
    }
  }

  function recordLast50(entry){
    const arr = safeJSONGet(KEY_LAST50(), []);
    const list = Array.isArray(arr) ? arr : [];
    list.push(entry);
    while(list.length > 50) list.shift();
    safeJSONSet(KEY_LAST50(), list);
  }

  // Public helper to log answers (called via wrappers)
  window.lt_recordAnswer = function(kind, id, correct){
    try{
      const ts = now();
      localStorage.setItem(KEY_LAST(), String(ts));
      recordDay(ts);
      recordLast50({ ts, examId: examId(), kind, id, correct: !!correct });
    }catch(_e){}
  };

  function streakFromDays(days){
    if(!Array.isArray(days) || !days.length) return 0;
    // calculate consecutive streak ending today or yesterday depending on last activity
    const last = days[days.length-1];
    const lastDate = new Date(last+"T00:00:00Z");
    const today = new Date(new Date().toISOString().slice(0,10)+"T00:00:00Z");
    const diffDays = Math.round((today - lastDate)/86400000);
    if(diffDays > 1) return 0; // streak broken
    let streak = 1;
    for(let i=days.length-1;i>0;i--){
      const a = new Date(days[i]+"T00:00:00Z");
      const b = new Date(days[i-1]+"T00:00:00Z");
      const d = Math.round((a-b)/86400000);
      if(d===1) streak++;
      else break;
    }
    return streak;
  }

  function fmtDateTime(ts){
    if(!ts) return "‚Äî";
    try{
      const d = new Date(Number(ts));
      const dd = String(d.getDate()).padStart(2,"0");
      const mm = String(d.getMonth()+1).padStart(2,"0");
      const yy = d.getFullYear();
      const hh = String(d.getHours()).padStart(2,"0");
      const mi = String(d.getMinutes()).padStart(2,"0");
      return `${dd}.${mm}.${yy} ¬∑ ${hh}:${mi}`;
    }catch(_e){ return "‚Äî"; }
  }

  function fmtDuration(ms){
    if(!ms || ms<=0) return "‚Äî";
    const s = Math.floor(ms/1000);
    const h = Math.floor(s/3600);
    const m = Math.floor((s%3600)/60);
    if(h<=0) return `${m} min`;
    return `${h} h ${String(m).padStart(2,"0")} min`;
  }

  function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }

  function renderDashboard(){
    try{
      if(typeof loadDB!=="function" || typeof state==="undefined") return;
      const db = loadDB();
      const ex = state.activeExamId;
      const cards = (db.cards||[]).filter(c=>c.examId===ex);
      const quiz  = (db.quiz||[]).filter(q=>q.examId===ex);

      // counts safe/open
      let cardsSafe = cards.filter(c=>!!c.isSafe).length;
      let quizSafe  = quiz.filter(q=>!!q.isSafe).length;
      let cardsTotal = cards.length;
      let quizTotal = quiz.length;
      let cardsOpen = Math.max(0, cardsTotal-cardsSafe);
      let quizOpen  = Math.max(0, quizTotal-quizSafe);

      // ring %
      const pc = cardsTotal>0 ? Math.round((cardsSafe/cardsTotal)*100) : 0;
      const pq = quizTotal>0 ? Math.round((quizSafe/quizTotal)*100) : 0;
      const ringCards = document.getElementById("ringCards");
      const ringQuiz = document.getElementById("ringQuiz");
      if(ringCards){ ringCards.style.setProperty("--deg", (pc/100*360).toFixed(0)+"deg"); ringCards.textContent = pc+"%"; }
      if(ringQuiz){ ringQuiz.style.setProperty("--deg", (pq/100*360).toFixed(0)+"deg"); ringQuiz.textContent = pq+"%"; }
      const txtCards = document.getElementById("txtCards");
      const txtQuiz  = document.getElementById("txtQuiz");
      if(txtCards) txtCards.textContent = `${cardsSafe} sicher ¬∑ ${cardsOpen} offen ¬∑ ${cardsTotal} gesamt`;
      if(txtQuiz)  txtQuiz.textContent  = `${quizSafe} sicher ¬∑ ${quizOpen} offen ¬∑ ${quizTotal} gesamt`;

      // quality: avg correct & attempts from stats
      function sumStats(items){
        let seen=0, correct=0, wrong=0;
        for(const it of items){
          const s = it && it.stats ? it.stats : null;
          if(!s) continue;
          seen += Number(s.seen||0);
          correct += Number(s.correct||0);
          wrong += Number(s.wrong||0);
        }
        return { seen, correct, wrong };
      }
      const cs = sumStats(cards);
      const qs = sumStats(quiz);
      const seen = cs.seen + qs.seen;
      const correct = cs.correct + qs.correct;
      const wrong = cs.wrong + qs.wrong;
      const attempts = (correct + wrong) || seen; // prefer explicit answers
      const correctPct = attempts>0 ? Math.round((correct/attempts)*100) : 0;

      const barCorrect = document.getElementById("barCorrect");
      const txtCorrect = document.getElementById("txtCorrect");
      if(barCorrect) barCorrect.style.setProperty("--w", clamp(correctPct,0,100)+"%");
      if(txtCorrect) txtCorrect.textContent = attempts>0 ? `${correctPct}% korrekt (${correct}/${attempts})` : "‚Äî";

      const txtAttempts = document.getElementById("txtAttempts");
      const avgAttempts = (cardsTotal + quizTotal) > 0 ? (attempts / (cardsTotal + quizTotal)) : 0;
      if(txtAttempts) txtAttempts.textContent = avgAttempts>0 ? avgAttempts.toFixed(1).replace(".",",") + " Versuche" : "‚Äî";

      // activity
      const last = Number(localStorage.getItem(KEY_LAST())||0);
      const txtLast = document.getElementById("txtLast");
      if(txtLast) txtLast.textContent = fmtDateTime(last);

      const totalMs = Number(localStorage.getItem(KEY_TIME())||0);
      const txtLearnTime = document.getElementById("txtLearnTime");
      if(txtLearnTime) txtLearnTime.textContent = fmtDuration(totalMs);

      // streak
      const days = safeJSONGet(KEY_DAYS(), []);
      const st = streakFromDays(days);
      const txtStreak = document.getElementById("txtStreak");
      if(txtStreak){
        const flames = st>0 ? "üî•".repeat(Math.min(10, st)) : "üî•";
        txtStreak.textContent = `${flames} ${st} Tage`;
      }

      // level/xp (klausur-abh√§ngig, Anzeige-only)
      const step = 50; // 50 XP pro Level (Anzeige)
      const examXP = Math.max(0, correct); // XP = richtige Antworten dieser Klausur (Anzeige)
      const lvl = Math.max(1, Math.floor(examXP/step)+1);
      const inLevel = examXP % step;
      const xpPct = step>0 ? Math.round((inLevel/step)*100) : 0;
      const txtLevel = document.getElementById("txtLevel");
      const txtXP = document.getElementById("txtXP");
      const barXP = document.getElementById("barXP");
      if(txtLevel) txtLevel.textContent = `Level ${lvl}`;
      if(txtXP) txtXP.textContent = `${inLevel} / ${step} XP`;
      if(barXP) barXP.style.setProperty("--w", xpPct+"%");

      // readiness (last 50 answers)
      const last50All = safeJSONGet(KEY_LAST50(), []);
      const last50 = Array.isArray(last50All) ? last50All.filter(x=>x && x.examId===examId()) : [];
      let r = 0;
      if(Array.isArray(last50) && last50.length){
        const n = last50.length;
        const ok = last50.filter(x=>x && x.correct===true).length;
        const perf = ok/n; // 0..1
        // Combine with safe ratio and streak lightly (as discussed)
        const safeTotal = cardsTotal + quizTotal;
        const safeRatio = safeTotal>0 ? (cardsSafe+quizSafe)/safeTotal : 0;
        const streakRatio = clamp(st/7, 0, 1); // saturate at 7 days
        r = Math.round((perf*0.40 + safeRatio*0.25 + perf*0.20 + streakRatio*0.15)*100);
      }else{
        // fallback: use correctPct + safeRatio
        const safeTotal = cardsTotal + quizTotal;
        const safeRatio = safeTotal>0 ? (cardsSafe+quizSafe)/safeTotal : 0;
        r = Math.round(( (correctPct/100)*0.65 + safeRatio*0.35 )*100);
      }
      r = clamp(r,0,100);
      const txtReady = document.getElementById("txtReady");
      if(txtReady) txtReady.textContent = `${r}% bereit`;
      const needle = document.getElementById("needleReady");
      if(needle){
        // map 0..100 to 0..180deg
        const ang = (r/100)*180;
        needle.style.setProperty("--a", ang.toFixed(0)+"deg");
      }

      // keep existing mastery bar text if present
      try{
        if(typeof lt_getMasteryCounts==="function"){
          const { mastered, total } = lt_getMasteryCounts();
          const pct = total>0 ? Math.round((mastered/total)*100) : 0;
          const t = document.getElementById("masteryText");
          const b = document.getElementById("masteryBar");
          if(t) t.textContent = `${mastered}/${total} gemeistert (${pct}%)`;
          if(b) b.style.width = pct + "%";
        }
      }catch(_e){}
    }catch(_e){}
  }

  // render periodically
  window.lt_renderDashboard = renderDashboard;
  // Aktualisierung nur beim √ñffnen des Lernstands
// Hook into show() so dashboard updates when panel opens
  if(typeof window.toggleStartPanel==="function" && !window.__patchedDashToggle){
    const _origT = window.toggleStartPanel;
    window.toggleStartPanel = function(id){
      const r = _origT.apply(this, arguments);
      try{ const mb=document.getElementById("masteryBox"); if(id==="masteryBox" && mb && getComputedStyle(mb).display!=="none") renderDashboard(); }catch(_e){}
      return r;
    };
    window.__patchedDashToggle = true;
  }

  // Wrap answer functions to record activity (no behavior changes)
  function wrap(name, kind){
    const fn = window[name];
    if(typeof fn!=="function" || fn.__wrapped) return;
    const wrapped = function(){
      // call original
      const ret = fn.apply(this, arguments);
      try{
        // We infer correctness from first arg when possible
        if(kind==="card"){
          const correct = !!arguments[0];
          const id = (window.state && window.state.session && window.state.session.ids) ? window.state.session.ids[window.state.session.i] : "";
          window.lt_recordAnswer("card", id, correct);
        }else if(kind==="quiz"){
          // chooseQuizAnswer already knows correct internally; we read last status if available
          const id = (window.state && window.state.quiz && window.state.quiz.ids) ? window.state.quiz.ids[window.state.quiz.i] : "";
          const sb = document.getElementById("quizStatusBar");
          const correct = sb && sb.classList.contains("right");
          window.lt_recordAnswer("quiz", id, !!correct);
        }
      }catch(_e){}
      return ret;
    };
    wrapped.__wrapped = true;
    window[name] = wrapped;
  }

  // These exist in your tool:
  wrap("rateCurrent","card");
  wrap("chooseQuizAnswer","quiz");

  // initial
})();

// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>

<script>
/* ===== Dark Mode Toggle (vB10) ===== */
(function(){
  const KEY = "lt_theme";
  const btn = ()=>document.getElementById("themeToggle");

  function prefersDark(){
    try{ return window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches; }catch(e){ return false; }
  }

  function applyThemeFromStorage(){
    try{
      const v = localStorage.getItem(KEY);
      const dark = (v === "dark") ? true : (v === "light") ? false : prefersDark();
      document.documentElement.classList.toggle("dark", !!dark);
      const b = btn();
      if(b){
        b.textContent = dark ? "‚òÄÔ∏è" : "üåô";
        b.title = dark ? "Light Mode" : "Dark Mode";
        b.setAttribute("aria-label", dark ? "Light Mode umschalten" : "Dark Mode umschalten");
      }
    }catch(e){}
  }

  function toggleTheme(){
    try{
      const isDark = document.documentElement.classList.contains("dark");
      localStorage.setItem(KEY, isDark ? "light" : "dark");
      applyThemeFromStorage();
    }catch(e){}
  }

  document.addEventListener("DOMContentLoaded", function(){
    applyThemeFromStorage();
    const b = btn();
    if(b) b.addEventListener("click", toggleTheme);

    // If user never chose a theme, react to OS changes
    try{
      const mq = window.matchMedia("(prefers-color-scheme: dark)");
      if(mq && mq.addEventListener){
        mq.addEventListener("change", function(){
          if(!localStorage.getItem(KEY)) applyThemeFromStorage();
        });
      }
    }catch(e){}
  });

  window.applyThemeFromStorage = applyThemeFromStorage;
})();


// üîß Layout-Fix: Quiz-Frage direkt unter Filter platzieren (ohne Funktions√§nderung)
function _placeQuizQuestionUnderFilter(){
  try{
    const q = document.getElementById('quizQ');
    if(!q) return;
    // m√∂gliche Filter-Container
    const filterAnchor =
      document.getElementById('quizFilterRow') ||
      document.querySelector('.quizFilterRow') ||
      document.querySelector('.quiz-filters') ||
      document.querySelector('#quiz .filters') ||
      document.querySelector('#quizFilters') ||
      document.querySelector('[data-quiz-filters]') ||
      document.querySelector('.quizTop') ||
      document.querySelector('.quizHeader');
    // Falls ein Filter-Label existiert (Text "Filter"), nimm dessen Parent-Block
    const filterLabel = Array.from(document.querySelectorAll('#quiz *')).find(el => (el.textContent||'').trim() === 'Filter');
    const anchor = (filterLabel && filterLabel.parentElement) ? filterLabel.parentElement : filterAnchor;
    if(!anchor) return;

    // Frage-Block direkt nach dem Filter-Block einf√ºgen
    const parent = anchor.parentElement;
    if(!parent) return;
    if(q.parentElement === parent && q.previousElementSibling === anchor) return;

    parent.insertBefore(q, anchor.nextSibling);
  }catch(e){}
}



// Auto: sobald Quiz-Inhalt sich √§ndert, Frage richtig platzieren
(function(){
  const target = document.getElementById('quiz') || document.querySelector('#quiz');
  if(!target || target._qObs) return;
  const obs = new MutationObserver(()=>_placeQuizQuestionUnderFilter());
  obs.observe(target, {childList:true, subtree:true});
  target._qObs = obs;
  // erster Versuch
  setTimeout(_placeQuizQuestionUnderFilter, 50);
  setTimeout(_placeQuizQuestionUnderFilter, 250);
})();



// ‚úÖ Quiz Layout Final: Frage DIREKT unter Filter platzieren (oberhalb von "W√§hle 1 Antwort.")
function _placeQuizQuestionUnderFilterRow(){
  try{
    const q = document.getElementById('quizQ');
    if(!q) return;

    const quizRoot = document.getElementById('quiz') || document.querySelector('#quiz');
    if(!quizRoot) return;

    // 1) Suche den sichtbaren "Filter"-Block (Label + Button) und nimm dessen gemeinsamen Container
    const filterTextEl = Array.from(quizRoot.querySelectorAll('*'))
      .find(el => (el.textContent || '').trim() === 'Filter');

    let anchor = null;

    if(filterTextEl){
      // wenn es mehrere "Filter" gibt, nimm das, das am ehesten ein Section-Header ist (kurzer Text, kein Button)
      // und finde einen Container der auch den Filter-Button enth√§lt
      const candidates = [];
      let cur = filterTextEl;
      for(let i=0;i<6 && cur; i++){
        const parent = cur.parentElement;
        if(!parent) break;
        const hasFilterBtn = Array.from(parent.querySelectorAll('button, .btn')).some(b => (b.textContent||'').trim()==='Filter');
        const hasChips = parent.querySelector('.chip, .chips, [data-chip]') != null;
        candidates.push({node: parent, score: (hasFilterBtn?10:0) + (hasChips?3:0) + i});
        cur = parent;
      }
      candidates.sort((a,b)=>b.score-a.score);
      anchor = candidates[0]?.node || null;
    }

    // Fallback: explizite Klassen/IDs, falls vorhanden
    anchor = anchor
      || quizRoot.querySelector('#quizFilterRow')
      || quizRoot.querySelector('.quizFilterRow')
      || quizRoot.querySelector('.quiz-filters')
      || quizRoot.querySelector('#quizFilters')
      || quizRoot.querySelector('[data-quiz-filters]');

    if(!anchor || !anchor.parentElement) return;

    const parent = anchor.parentElement;

    // Wenn Frage schon direkt nach Filter sitzt -> fertig
    if(q.parentElement === parent && q.previousElementSibling === anchor) return;

    // Setze Frage direkt nach Filter-Block
    parent.insertBefore(q, anchor.nextSibling);
  }catch(e){}
}

// Beobachte Quiz-Bereich und positioniere immer wieder korrekt
(function(){
  const quizRoot = document.getElementById('quiz') || document.querySelector('#quiz');
  if(!quizRoot) return;

  if(quizRoot._qObsFinal) return;
  const obs = new MutationObserver(()=>_placeQuizQuestionUnderFilterRow());
  obs.observe(quizRoot, {childList:true, subtree:true});
  quizRoot._qObsFinal = obs;

  // initial tries
  setTimeout(_placeQuizQuestionUnderFilterRow, 30);
  setTimeout(_placeQuizQuestionUnderFilterRow, 120);
  setTimeout(_placeQuizQuestionUnderFilterRow, 350);
})();



// ‚úÖ Quiz Layout v4: Frage garantiert UNTER Filter und VOR Antworten
function _placeQuizQuestionGuaranteed(){
  try{
    const quizRoot = document.getElementById('quiz') || document.querySelector('#quiz');
    const q = document.getElementById('quizQ');
    if(!quizRoot || !q) return;

    // Antworten-Container finden (robust)
    const answers =
      quizRoot.querySelector('.answers') ||
      quizRoot.querySelector('#answers') ||
      quizRoot.querySelector('[data-answers]') ||
      // fallback: parent of first answer button
      (function(){
        const btn = quizRoot.querySelector('button[data-ans], button.answer, .answerBtn, .answers button');
        return btn ? btn.parentElement : null;
      })();

    // Filter-Block finden: Container der Label "Filter" + ggf. Filter-Button enth√§lt
    const filterLabel = Array.from(quizRoot.querySelectorAll('*')).find(el => (el.textContent||'').trim() === 'Filter');
    let filterBlock = null;
    if(filterLabel){
      let cur = filterLabel;
      for(let i=0;i<7 && cur; i++){
        const p = cur.parentElement;
        if(!p) break;
        const hasFilterBtn = Array.from(p.querySelectorAll('button, .btn')).some(b => (b.textContent||'').trim()==='Filter');
        // wir suchen den Block, der optisch wie die Zeile "Filter .... [Button]" wirkt
        if(hasFilterBtn){ filterBlock = p; break; }
        cur = p;
      }
    }

    // 1) Falls Filter-Block existiert: Frage direkt dahinter
    if(filterBlock && filterBlock.parentElement){
      const parent = filterBlock.parentElement;
      if(q.parentElement !== parent || q.previousElementSibling !== filterBlock){
        parent.insertBefore(q, filterBlock.nextSibling);
      }
      // Stelle sicher, dass Frage VOR Antworten steht (falls Antworten im selben Parent)
      if(answers && answers.parentElement === parent){
        parent.insertBefore(q, answers);
        // und dann wieder direkt hinter FilterBlock
        parent.insertBefore(q, filterBlock.nextSibling);
      }
      return;
    }

    // 2) Fallback: Frage direkt VOR Antworten (damit sie nicht mehr oben h√§ngt)
    if(answers && answers.parentElement){
      answers.parentElement.insertBefore(q, answers);
      return;
    }
  }catch(e){}
}

// Immer wieder anwenden, weil Quiz dynamisch rendert
(function(){
  const quizRoot = document.getElementById('quiz') || document.querySelector('#quiz');
  if(!quizRoot) return;
  if(quizRoot._qObsV4) return;

  const obs = new MutationObserver(()=>_placeQuizQuestionGuaranteed());
  obs.observe(quizRoot, {childList:true, subtree:true});
  quizRoot._qObsV4 = obs;

  setTimeout(_placeQuizQuestionGuaranteed, 20);
  setTimeout(_placeQuizQuestionGuaranteed, 120);
  setTimeout(_placeQuizQuestionGuaranteed, 300);
  window.addEventListener('load', ()=>setTimeout(_placeQuizQuestionGuaranteed, 50));
})();



// ‚úÖ Quiz Layout v5: Frage (#quizQ) direkt UNTER FilterWrap und √úBER "W√§hle 1 Antwort."
function _placeQuizQUnderQuizFilter(){
  try{
    const box = document.getElementById('quizBox');
    const q = document.getElementById('quizQ');
    if(!box || !q) return;

    // Instruction: exakt der Block "W√§hle 1 Antwort."
    const instruction = Array.from(box.querySelectorAll('div'))
      .find(el => (el.textContent||'').trim() === 'W√§hle 1 Antwort.');
    if(!instruction) return;

    // Wenn Frage schon direkt davor steht -> fertig
    if(q.nextElementSibling === instruction) return;

    instruction.parentElement.insertBefore(q, instruction);
  }catch(e){}
}

(function(){
  const box = document.getElementById('quizBox');
  if(!box) return;
  if(box._qObsV5) return;

  const obs = new MutationObserver(()=>_placeQuizQUnderQuizFilter());
  obs.observe(box, {childList:true, subtree:true});
  box._qObsV5 = obs;

  // initial tries
  setTimeout(_placeQuizQUnderQuizFilter, 10);
  setTimeout(_placeQuizQUnderQuizFilter, 80);
  setTimeout(_placeQuizQUnderQuizFilter, 250);
  window.addEventListener('load', ()=>setTimeout(_placeQuizQUnderQuizFilter, 50));
})();


// ‚úÖ Sicher gelernt immer sichtbar & klickbar (Safety Net)
(function(){
  function forceSafeBtn(){
    const b = document.getElementById("cardSafeBtn");
    if(!b) return;
    b.style.display = "flex";
    b.disabled = false;
    b.style.opacity = "1";
    b.style.pointerEvents = "auto";
  }
  setInterval(forceSafeBtn, 300);
})();

</script>

<script>

// ===== ‚òÅÔ∏è Cloud Sync (Firebase) ‚Äì optional, update‚Äë & kartensicher =====
const CLOUD_CFG_KEY = "lt_cloud_firebase_cfg_v1";
const CLOUD_ENABLED_KEY = "lt_cloud_enabled_v1";
const CLOUD_AUTOSYNC_KEY = "lt_cloud_autosync_v1";
const CLOUD_LASTSYNC_KEY = "lt_cloud_lastsync_v1";

const CloudSync = {
  enabled:false,
  autosync:false,
  cfg:null,
  ready:false,
  uid:null,
  userKey:null,
  _loading:false,
  _debounce:null,
  _fb:{app:null, auth:null, db:null, firestore:null},
};

// ===== Cloud UserKey (Name-basiert) =====
// Wichtig: Damit Handy + Tablet mit gleichem Namen auf dieselben Daten zugreifen k√∂nnen,
// speichern wir NICHT mehr unter der anonymen Firebase-UID (die ist pro Ger√§t), sondern unter
// einem stabilen Key aus dem Namen.
// ‚ö†Ô∏è Sicherheit: "nur Name" = jeder kann denselben Namen eingeben. Sp√§ter kann man auf Login/PIN umstellen.
function cloudUserKeyFromName(name){
  const n = String(name||"").trim().toLowerCase();
  if(!n) return null;
  // FNV-1a 32-bit Hash (klein, schnell, reicht hier)
  let h = 0x811c9dc5;
  for(let i=0;i<n.length;i++){
    h ^= n.charCodeAt(i);
    h = (h * 0x01000193) >>> 0;
  }
  return "name_" + ("00000000" + h.toString(16)).slice(-8);
}

function _cloudSetPill(ok, text){
  const dot = document.getElementById('cloudDot');
  const t = document.getElementById('cloudStatusText');
  if(dot) dot.style.background = ok===true ? '#4caf50' : (ok===false ? '#f44336' : '#999');
  if(t) t.textContent = text;

  const dot2 = document.getElementById('cloudInlineDot');
  const t2 = document.getElementById('cloudInlineText');
  if(dot2) dot2.style.background = ok===true ? '#4caf50' : (ok===false ? '#f44336' : '#999');
  if(t2) t2.textContent = text;
}

function openCloudModal(){
  try{
    const modal = document.getElementById('cloudModal');
    if(!modal) return;
    // load settings
    const enabled = localStorage.getItem(CLOUD_ENABLED_KEY)==='1';
    const autosync = localStorage.getItem(CLOUD_AUTOSYNC_KEY)==='1';
    const cfgRaw = localStorage.getItem(CLOUD_CFG_KEY) || '';
    const t = document.getElementById('cloudEnableToggle');
    const a = document.getElementById('cloudAutoSyncToggle');
    const c = document.getElementById('cloudConfigInput');
    if(t) t.checked = enabled;
    if(a) a.checked = autosync;
    if(c) c.value = cfgRaw;
    modal.style.display = 'block';
    _cloudSetPill(CloudSync.ready?true:null, CloudSync.ready?`Cloud: verbunden (${CloudSync.userKey||'?'})`:(enabled?'Cloud: bereit‚Ä¶':'Cloud: aus'));
  }catch(_e){}
}

function closeCloudModal(){
  const modal = document.getElementById('cloudModal');
  if(modal) modal.style.display='none';
}

function cloudToggleChanged(){
  // just UI; persist with Save
}

function cloudSaveSettings(){
  const enabled = !!document.getElementById('cloudEnableToggle')?.checked;
  const autosync = !!document.getElementById('cloudAutoSyncToggle')?.checked;
  const cfgRaw = (document.getElementById('cloudConfigInput')?.value || '').trim();

  localStorage.setItem(CLOUD_ENABLED_KEY, enabled?'1':'0');
  localStorage.setItem(CLOUD_AUTOSYNC_KEY, autosync?'1':'0');
  if(cfgRaw) localStorage.setItem(CLOUD_CFG_KEY, cfgRaw);
  else localStorage.removeItem(CLOUD_CFG_KEY);

  CloudSync.enabled = enabled;
  CloudSync.autosync = autosync;

  if(enabled){
    cloudInit().then(()=>{
      _cloudSetPill(true, `Cloud: verbunden (${CloudSync.userKey||'OK'})`);
      toast?.('cloud','Cloud aktiv.');
    }).catch((e)=>{
      console.warn(e);
      _cloudSetPill(false, 'Cloud: Fehler');
      alert('Cloud konnte nicht verbunden werden. Pr√ºfe Firebase Config + Internet.');
    });
  }else{
    _cloudSetPill(null, 'Cloud: aus');
    toast?.('cloud','Cloud deaktiviert.');
  }
  closeCloudModal();
}

function _cloudGetRelevantLocalStorage(){
  const data = {};
  const prefixes = ['lt_', 'lerntool_', 'top10_', 'daily', 'currentExamId', 'highscoreResetAt_'];
  for(let i=0;i<localStorage.length;i++){
    const k = localStorage.key(i);
    if(!k) continue;
    if(prefixes.some(p=>k.startsWith(p))){
      data[k] = localStorage.getItem(k);
    }
  }
  // ensure main DB keys exist if used differently
  try{
    if(typeof DB_KEY==='string' && localStorage.getItem(DB_KEY)!==null) data[DB_KEY]=localStorage.getItem(DB_KEY);
    if(typeof NAME_KEY==='string' && localStorage.getItem(NAME_KEY)!==null) data[NAME_KEY]=localStorage.getItem(NAME_KEY);
  }catch(_e){}
  return data;
}

function _cloudApplySnapshot(snapshot){
  if(!snapshot || typeof snapshot!=='object') return 0;
  let count=0;
  for(const [k,v] of Object.entries(snapshot)){
    try{
      if(typeof v === 'string' || v === null){
        if(v===null) localStorage.removeItem(k);
        else localStorage.setItem(k, v);
        count++;
      }
    }catch(_e){}
  }
  return count;
}

function _cloudParseConfig(raw){
  if(!raw) return null;
  try{
    const cfg = JSON.parse(raw);
    if(!cfg || !cfg.apiKey || !cfg.projectId || !cfg.appId) return null;
    return cfg;
  }catch(_e){
    return null;
  }
}

function _cloudLoadScriptOnce(src){
  return new Promise((resolve,reject)=>{
    if(document.querySelector(`script[data-src="${src}"]`)) return resolve();
    const s=document.createElement('script');
    s.src=src;
    s.async=true;
    s.defer=true;
    s.dataset.src=src;
    s.onload=()=>resolve();
    s.onerror=()=>reject(new Error('Failed to load '+src));
    document.head.appendChild(s);
  });
}

async function cloudInit(){
  if(CloudSync.ready || CloudSync._loading) return;
  CloudSync._loading = true;

  const enabled = localStorage.getItem(CLOUD_ENABLED_KEY)==='1';
  const autosync = localStorage.getItem(CLOUD_AUTOSYNC_KEY)==='1';
  const cfgRaw = (localStorage.getItem(CLOUD_CFG_KEY) || '').trim();
  const cfg = _cloudParseConfig(cfgRaw);

  CloudSync.enabled = enabled;
  CloudSync.autosync = autosync;
  CloudSync.cfg = cfg;

  if(!enabled){
    CloudSync._loading = false;
    _cloudSetPill(null,'Cloud: aus');
    return;
  }
  if(!cfg){
    CloudSync._loading = false;
    _cloudSetPill(false,'Cloud: Config fehlt');
    throw new Error('Firebase config missing/invalid');
  }

  // Offline? Dann Tool l√§uft weiter lokal, Cloud erst sp√§ter.
  try{
    if(typeof navigator !== 'undefined' && navigator && navigator.onLine === false){
      CloudSync._loading = false;
      CloudSync.ready = false;
      _cloudSetPill(null,'Cloud: offline');
      return;
    }
  }catch(_e){}

  // Load Firebase compat scripts only when needed
  await _cloudLoadScriptOnce('https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js');
  await _cloudLoadScriptOnce('https://www.gstatic.com/firebasejs/10.12.5/firebase-auth-compat.js');
  await _cloudLoadScriptOnce('https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore-compat.js');

  if(!window.firebase) throw new Error('Firebase not available');

  // init app once
  if(!firebase.apps || !firebase.apps.length){
    firebase.initializeApp(cfg);
  }
  const auth = firebase.auth();
  const db = firebase.firestore();

  CloudSync._fb = {app: firebase.app(), auth, db, firestore: firebase.firestore};

  // ‚ÄúName reicht‚Äù: UI asks only for name, but we still use anonymous auth internally (safe, no effort)
  const currentName = (localStorage.getItem(NAME_KEY)||'').trim();
  const userKey = cloudUserKeyFromName(currentName);
  if(!userKey){
    CloudSync._loading = false;
    CloudSync.ready = false;
    CloudSync.userKey = null;
    _cloudSetPill(false,'Cloud: Name fehlt');
    throw new Error('Name missing');
  }
  CloudSync.userKey = userKey;

  if(!auth.currentUser){
    await auth.signInAnonymously();
  }
  CloudSync.uid = auth.currentUser?.uid || null;

  // store display name + mapping (optional)
  try{
    if(currentName){
      await db.collection('users').doc(CloudSync.uid).set({
        displayName: currentName,
        userKey: CloudSync.userKey,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      }, {merge:true});
    }
  }catch(_e){}

  // Migration (einmalig): Falls alte Daten noch unter ger√§te-UID liegen, kopieren wir sie in den Namen-Speicher.
  // Damit verlieren bestehende Nutzer nichts, wenn wir von UID ‚Üí Name umstellen.
  try{
    const nameDocRef = db.collection('syncByName').doc(CloudSync.userKey);
    const nameDoc = await nameDocRef.get();
    if(!nameDoc.exists){
      const oldDoc = await db.collection('sync').doc(CloudSync.uid).get();
      if(oldDoc.exists){
        const oldData = oldDoc.data() || {};
        if(oldData && oldData.snapshot){
          await nameDocRef.set({snapshot: oldData.snapshot, migratedFromUid: CloudSync.uid, migratedAt: Date.now()}, {merge:true});
        }
      }
    }
  }catch(_e){}

  CloudSync.ready = true;
  CloudSync._loading = false;
  _cloudSetPill(true, `Cloud: verbunden (${CloudSync.userKey||'OK'})`);
}

async function cloudUploadNow(){
  try{
    await cloudInit();
    if(!CloudSync.ready) return;
    const snap = _cloudGetRelevantLocalStorage();
    const payload = { snapshot: snap, clientUpdatedAt: Date.now() };
    await CloudSync._fb.db.collection('syncByName').doc(CloudSync.userKey).set(payload, {merge:true});
    localStorage.setItem(CLOUD_LASTSYNC_KEY, String(Date.now()));
    _cloudSetPill(true,'Cloud: hochgeladen');
    toast?.('cloud','Cloud Upload ok.');
  }catch(e){
    console.warn(e);
    _cloudSetPill(false,'Cloud: Fehler');
    alert('Cloud Upload fehlgeschlagen. Pr√ºfe Internet/Firebase.');
  }
}

async function cloudDownloadNow(){
  try{
    await cloudInit();
    if(!CloudSync.ready) return;
    const doc = await CloudSync._fb.db.collection('syncByName').doc(CloudSync.userKey).get();
    if(!doc.exists){
      toast?.('cloud','Keine Cloud-Daten gefunden.');
      _cloudSetPill(true,'Cloud: leer');
      return;
    }
    const data = doc.data() || {};
    const snap = data.snapshot || {};
    const applied = _cloudApplySnapshot(snap);
    localStorage.setItem(CLOUD_LASTSYNC_KEY, String(Date.now()));
    _cloudSetPill(true,`Cloud: geladen (${applied})`);
    toast?.('cloud',`Cloud geladen (${applied}).`);
    // refresh UI
    try{ location.reload(); }catch(_e){}
  }catch(e){
    console.warn(e);
    _cloudSetPill(false,'Cloud: Fehler');
    alert('Cloud Download fehlgeschlagen. Pr√ºfe Internet/Firebase.');
  }
}

function cloudMaybeAutoSync(){
  try{
    if(!CloudSync.enabled) return;
    if(localStorage.getItem(CLOUD_AUTOSYNC_KEY)!=='1') return;
    if(CloudSync._debounce) clearTimeout(CloudSync._debounce);
    CloudSync._debounce = setTimeout(()=>{ cloudUploadNow(); }, 800);
  }catch(_e){}
}

// Patch saveDB so changes sync automatically (wenn aktiviert)
try{
  const __origSaveDB = saveDB;
  saveDB = function(db){
    __origSaveDB(db);
    cloudMaybeAutoSync();
  };
}catch(_e){}


// Online/Offline UI: Tool bleibt offline nutzbar, Cloud zeigt Status.
window.addEventListener('offline', ()=>{
  try{
    if(localStorage.getItem(CLOUD_ENABLED_KEY)==='1'){
      _cloudSetPill(null,'Cloud: offline');
    }
  }catch(_e){}
});
window.addEventListener('online', ()=>{
  try{
    const enabled = localStorage.getItem(CLOUD_ENABLED_KEY)==='1';
    if(!enabled) return;
    _cloudSetPill(null,'Cloud: bereit‚Ä¶');
    // optional: Auto-Sync beim Wieder-online
    const autosync = localStorage.getItem(CLOUD_AUTOSYNC_KEY)==='1';
    if(autosync){
      cloudInit().then(()=> cloudUploadNow()).catch(()=>{});
    }else{
      cloudInit().catch(()=>{});
    }
  }catch(_e){}
});

// Initialize pill on load
(function(){
  try{
    const enabled = localStorage.getItem(CLOUD_ENABLED_KEY)==='1';
    _cloudSetPill(null, enabled?'Cloud: bereit‚Ä¶':'Cloud: aus');
    if(enabled){
      cloudInit().catch(()=>{});
    }
  }catch(_e){}
})();

</script>

</body>
</html>